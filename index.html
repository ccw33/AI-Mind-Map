<!DOCTYPE html><html lang=""><head><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,user-scalable=no,initial-scale=1,maximum-scale=1,minimum-scale=1"><link rel="icon" href="dist/logo.ico"><title>思绪思维导图</title><script>// 自定义静态资源的路径
      window.externalPublicPath = './dist/'
      // 接管应用
      window.takeOverApp = false</script><script charset="UTF-8" id="LA_COLLECT" src="//sdk.51.la/js-sdk-pro.min.js"></script><script>try {
        LA.init({
          id: 'KRO0WxK8GT66tYCQ',
          ck: 'KRO0WxK8GT66tYCQ',
          autoTrack: false
        })
      } catch (error) {
        console.log(error)
      }</script><link href="dist/css/chunk-vendors.css?685589f1058f5fbca0d2" rel="stylesheet"><link href="dist/css/app.css?685589f1058f5fbca0d2" rel="stylesheet"></head><body><noscript><strong>We're sorry but thoughts doesn't work properly without JavaScript enabled. Please enable it to continue.</strong></noscript><div id="app"></div>

<!-- AI聊天浮窗 -->
<div id="aiChatBot" class="ai-chat-bot" style="display: none;">
  <div class="chat-header" onclick="toggleMinimize()">
    <div class="header-left">
      <span class="ai-icon">🤖</span>
      <span class="title">AI助手</span>
      <span id="contextInfo" class="context-info"></span>
    </div>
    <div class="header-actions">
      <button onclick="syncCurrentActiveNode()" title="同步当前选中节点" style="background: #4CAF50; color: white; border: none; border-radius: 4px; padding: 4px 6px; margin-right: 4px;">🔄</button>
      <button onclick="clearMessages()" title="清除记录">🗑️</button>
      <button onclick="showConfig()" title="设置">⚙️</button>
      <button onclick="toggleMinimize()" id="minimizeBtn" title="最小化">⬇️</button>
    </div>
  </div>

  <div id="chatMessages" class="chat-messages">
    <div class="welcome-message">
      <div class="welcome-content">
        <span class="ai-icon">🤖</span>
        <h3>AI思维导图助手</h3>
        <p>点击思维导图节点开始对话</p>
      </div>
    </div>
  </div>

  <div id="chatInput" class="chat-input">
    <div class="input-container">
      <textarea
        id="messageInput"
        class="message-input"
        placeholder="请先选择思维导图节点"
        rows="2"
        onkeydown="handleKeyDown(event)"
      ></textarea>
      <div class="input-actions">
        <button id="sendBtn" class="send-btn" onclick="sendMessage()">发送</button>
      </div>
    </div>
  </div>
</div>

<!-- AI配置面板 -->
<div id="aiConfigPanel" class="ai-config-panel" style="display: none;">
  <div class="config-header">
    <h4>AI配置</h4>
    <button onclick="closeConfig()">❌</button>
  </div>
  <div class="config-content">
    <div class="config-item">
      <label>AI提供商:</label>
      <select id="aiProvider">
        <option value="openai">OpenAI</option>
        <option value="deepseek">DeepSeek</option>
        <option value="ollama">Ollama</option>
      </select>
    </div>
    <div class="config-item">
      <label>API Key:</label>
      <input id="apiKey" type="password" placeholder="请输入API Key">
    </div>
    <div class="config-item">
      <label>模型:</label>
      <input id="aiModel" placeholder="gpt-3.5-turbo">
    </div>
    <div class="config-item">
      <label>基础URL:</label>
      <input id="baseURL" placeholder="https://api.openai.com/v1">
    </div>
    <div class="config-actions">
      <button onclick="saveConfig()">保存配置</button>
      <button onclick="testConnection()">测试连接</button>
    </div>
  </div>
</div>

<style>
/* AI聊天浮窗样式 */
.ai-chat-bot {
  position: fixed;
  bottom: 20px;
  right: 20px;
  width: 380px;
  max-height: 600px;
  background: #fff;
  border-radius: 12px;
  box-shadow: 0 8px 32px rgba(0, 0, 0, 0.12);
  border: 1px solid #e8e8e8;
  display: flex;
  flex-direction: column;
  z-index: 10000;
  font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
  transition: all 0.3s ease;
}

.ai-chat-bot.minimized {
  max-height: 50px;
}

.ai-chat-bot.minimized .chat-messages,
.ai-chat-bot.minimized .chat-input {
  display: none;
}

.chat-header {
  display: flex;
  align-items: center;
  justify-content: space-between;
  padding: 12px 16px;
  background: #f8f9fa;
  border-bottom: 1px solid #e8e8e8;
  border-radius: 12px 12px 0 0;
  cursor: pointer;
  user-select: none;
}

.header-left {
  display: flex;
  align-items: center;
  flex: 1;
  min-width: 0;
}

.ai-icon {
  font-size: 18px;
  margin-right: 8px;
}

.title {
  font-weight: 600;
  color: #333;
  margin-right: 8px;
}

.context-info {
  font-size: 12px;
  color: #666;
  overflow: hidden;
  text-overflow: ellipsis;
  white-space: nowrap;
}

.header-actions {
  display: flex;
  align-items: center;
  gap: 4px;
}

.header-actions button {
  background: none;
  border: none;
  cursor: pointer;
  padding: 4px;
  border-radius: 4px;
  font-size: 14px;
}

.header-actions button:hover {
  background: rgba(0, 0, 0, 0.1);
}

.chat-messages {
  flex: 1;
  padding: 16px;
  overflow-y: auto;
  max-height: 400px;
  background: #fff;
}

.welcome-message {
  text-align: center;
  padding: 20px;
  color: #666;
}

.welcome-content .ai-icon {
  font-size: 32px;
  margin-bottom: 12px;
  display: block;
}

.welcome-content h3 {
  margin: 0 0 8px 0;
  color: #333;
  font-size: 16px;
}

.welcome-content p {
  margin: 0 0 16px 0;
  font-size: 14px;
}

.quick-actions {
  display: flex;
  flex-wrap: wrap;
  gap: 8px;
  justify-content: center;
}

.quick-actions button {
  padding: 6px 12px;
  background: #409eff;
  color: white;
  border: none;
  border-radius: 16px;
  cursor: pointer;
  font-size: 12px;
}

.quick-actions button:hover {
  background: #337ecc;
}

.message-item {
  display: flex;
  margin-bottom: 16px;
  align-items: flex-start;
}

.message-item.user {
  flex-direction: row-reverse;
}

.message-item.user .message-content {
  background: #409eff;
  color: #fff;
  margin-right: 12px;
  margin-left: 0;
}

.message-item.assistant .message-content {
  background: #f5f5f5;
  color: #333;
  margin-left: 12px;
}

.message-item.system {
  justify-content: center;
}

.message-item.system .message-content {
  background: #e8f4fd;
  color: #409eff;
  font-size: 12px;
  padding: 8px 12px;
  border-radius: 16px;
  margin: 0;
}

.message-avatar {
  width: 32px;
  height: 32px;
  border-radius: 50%;
  background: #fff;
  border: 1px solid #e8e8e8;
  display: flex;
  align-items: center;
  justify-content: center;
  flex-shrink: 0;
  font-size: 16px;
}

.message-content {
  max-width: 280px;
  padding: 12px 16px;
  border-radius: 12px;
  position: relative;
}

.message-text {
  font-size: 14px;
  line-height: 1.5;
  word-wrap: break-word;
  white-space: pre-wrap;
}

.suggestions {
  margin-top: 12px;
  padding-top: 12px;
  border-top: 1px solid rgba(0, 0, 0, 0.1);
}

.suggestions-title {
  font-size: 12px;
  color: #666;
  margin-bottom: 8px;
}

.suggestions-list {
  display: flex;
  flex-wrap: wrap;
  gap: 6px;
}

.suggestion-btn {
  font-size: 12px;
  padding: 4px 8px;
  background: #409eff;
  color: white;
  border: none;
  border-radius: 12px;
  cursor: pointer;
}

.suggestion-btn:hover {
  background: #337ecc;
}

.chat-input {
  border-top: 1px solid #e8e8e8;
  padding: 12px 16px;
  background: #fff;
  border-radius: 0 0 12px 12px;
}

.input-container {
  display: flex;
  flex-direction: column;
  gap: 8px;
}

.message-input {
  width: 100%;
  border: 1px solid #e8e8e8;
  border-radius: 8px;
  padding: 8px 12px;
  font-size: 14px;
  resize: none;
  outline: none;
  font-family: inherit;
}

.message-input:focus {
  border-color: #409eff;
}

.message-input:disabled {
  background: #f5f5f5;
  color: #999;
}

.input-actions {
  display: flex;
  justify-content: flex-end;
}

.send-btn {
  padding: 8px 16px;
  background: #409eff;
  color: white;
  border: none;
  border-radius: 6px;
  cursor: pointer;
  font-size: 14px;
}

.send-btn:hover:not(:disabled) {
  background: #337ecc;
}

.send-btn:disabled {
  background: #ccc;
  cursor: not-allowed;
}

/* AI配置面板样式 */
.ai-config-panel {
  position: fixed;
  bottom: 20px;
  right: 420px;
  width: 350px;
  background: white;
  border-radius: 12px;
  box-shadow: 0 8px 32px rgba(0, 0, 0, 0.12);
  border: 1px solid #e8e8e8;
  z-index: 10001;
  font-family: inherit;
}

.config-header {
  display: flex;
  justify-content: space-between;
  align-items: center;
  padding: 16px;
  border-bottom: 1px solid #e8e8e8;
  background: #f8f9fa;
  border-radius: 12px 12px 0 0;
}

.config-header h4 {
  margin: 0;
  color: #333;
}

.config-header button {
  background: none;
  border: none;
  cursor: pointer;
  font-size: 16px;
}

.config-content {
  padding: 16px;
}

.config-item {
  margin-bottom: 16px;
}

.config-item label {
  display: block;
  margin-bottom: 4px;
  font-size: 14px;
  color: #333;
}

.config-item input,
.config-item select {
  width: 100%;
  padding: 8px 12px;
  border: 1px solid #e8e8e8;
  border-radius: 6px;
  font-size: 14px;
}

.config-actions {
  display: flex;
  gap: 8px;
  margin-top: 20px;
}

.config-actions button {
  flex: 1;
  padding: 10px;
  border: none;
  border-radius: 6px;
  cursor: pointer;
  font-size: 14px;
}

.config-actions button:first-child {
  background: #409eff;
  color: white;
}

.config-actions button:last-child {
  background: #f5f5f5;
  color: #333;
}

.loading {
  animation: pulse 1.5s ease-in-out infinite;
}

/* 结构化分点样式 */
.structured-points {
  margin-top: 12px;
  padding-top: 12px;
  border-top: 1px solid rgba(0, 0, 0, 0.1);
}

.points-header {
  display: flex;
  justify-content: space-between;
  align-items: center;
  margin-bottom: 12px;
}

.points-title {
  font-size: 12px;
  color: #666;
  font-weight: 600;
}

.points-actions {
  display: flex;
  gap: 6px;
}

.select-all-btn,
.add-selected-btn {
  font-size: 11px;
  padding: 3px 8px;
  border: 1px solid #409eff;
  background: white;
  color: #409eff;
  border-radius: 10px;
  cursor: pointer;
}

.select-all-btn:hover,
.add-selected-btn:hover {
  background: #409eff;
  color: white;
}

.add-selected-btn {
  background: #409eff;
  color: white;
}

.add-selected-btn:hover {
  background: #337ecc;
}

.points-list {
  display: flex;
  flex-direction: column;
  gap: 8px;
}

.structured-point {
  border: 1px solid #e8e8e8;
  border-radius: 6px;
  padding: 8px;
  background: #fafafa;
}

.point-header {
  display: flex;
  align-items: center;
  gap: 6px;
  margin-bottom: 4px;
}

.point-checkbox {
  margin: 0;
  cursor: pointer;
}

.point-title {
  font-size: 13px;
  font-weight: 600;
  color: #333;
  cursor: pointer;
  margin: 0;
}

.point-content {
  font-size: 12px;
  color: #666;
  line-height: 1.4;
  margin-bottom: 6px;
  padding-left: 20px;
}

.point-keywords {
  display: flex;
  flex-wrap: wrap;
  gap: 4px;
  padding-left: 20px;
}

.keyword {
  font-size: 10px;
  padding: 2px 6px;
  background: #e8f4fd;
  color: #409eff;
  border-radius: 8px;
  border: 1px solid #b3d8ff;
}

/* 选中节点显示样式 */
.selected-node-display {
  padding: 12px 16px;
  background: linear-gradient(135deg, #e8f4fd 0%, #f0f8ff 100%);
  border-bottom: 1px solid #b3d8ff;
  display: none;
}

.selected-node-content {
  display: flex;
  flex-direction: column;
  gap: 6px;
}

.node-indicator {
  display: flex;
  align-items: center;
  gap: 6px;
}

.indicator-dot {
  width: 8px;
  height: 8px;
  background: #409eff;
  border-radius: 50%;
  animation: pulse-dot 2s infinite;
}

.indicator-text {
  font-size: 11px;
  color: #409eff;
  font-weight: 600;
  text-transform: uppercase;
  letter-spacing: 0.5px;
}

.node-text {
  font-size: 14px;
  font-weight: 600;
  color: #2c5aa0;
  margin: 2px 0;
}

.node-path {
  display: flex;
  align-items: center;
  gap: 6px;
  font-size: 11px;
}

.path-label {
  color: #666;
  font-weight: 500;
}

.path-text {
  color: #409eff;
  background: rgba(64, 158, 255, 0.1);
  padding: 2px 8px;
  border-radius: 10px;
  border: 1px solid rgba(64, 158, 255, 0.2);
  font-family: monospace;
}

@keyframes pulse-dot {
  0%, 100% {
    opacity: 1;
    transform: scale(1);
  }
  50% {
    opacity: 0.6;
    transform: scale(1.2);
  }
}

/* 通知动画 */
@keyframes slideInRight {
  from {
    transform: translateX(100%);
    opacity: 0;
  }
  to {
    transform: translateX(0);
    opacity: 1;
  }
}

@keyframes slideOutRight {
  from {
    transform: translateX(0);
    opacity: 1;
  }
  to {
    transform: translateX(100%);
    opacity: 0;
  }
}

@keyframes pulse {
  0%, 100% { opacity: 1; }
  50% { opacity: 0.5; }
}

/* 思考状态动画 - 跳动的点 */
@keyframes thinking-dots {
  0%, 20% {
    opacity: 0.3;
    transform: scale(1);
  }
  50% {
    opacity: 1;
    transform: scale(1.2);
  }
  100% {
    opacity: 0.3;
    transform: scale(1);
  }
}

.thinking-dots {
  display: inline-block;
}

.thinking-dots .dot {
  display: inline-block;
  width: 4px;
  height: 4px;
  border-radius: 50%;
  background-color: #666;
  margin: 0 1px;
  animation: thinking-dots 1.4s infinite ease-in-out;
}

.thinking-dots .dot:nth-child(1) { animation-delay: 0s; }
.thinking-dots .dot:nth-child(2) { animation-delay: 0.2s; }
.thinking-dots .dot:nth-child(3) { animation-delay: 0.4s; }

/* 打字机效果 */
.typewriter-text {
  overflow: hidden;
  border-right: 2px solid #409eff;
  white-space: nowrap;
  animation: typing 0.5s steps(1, end), blink-caret 1s step-end infinite;
}

@keyframes typing {
  from { width: 0; }
  to { width: 100%; }
}

@keyframes blink-caret {
  from, to { border-color: transparent; }
  50% { border-color: #409eff; }
}

/* 推理模型样式 */
.reasoning-content {
  background: #f8f9fa;
  border-left: 3px solid #888;
  padding: 12px;
  margin: 8px 0;
  border-radius: 0 8px 8px 0;
  font-style: italic;
  color: #666;
  font-size: 13px;
  line-height: 1.4;
}

.reasoning-content::before {
  content: "🤔 思考过程：";
  font-weight: 600;
  color: #888;
  display: block;
  margin-bottom: 6px;
  font-style: normal;
}

.final-answer {
  margin-top: 8px;
  padding-top: 8px;
  border-top: 1px solid #e8e8e8;
}

.final-answer::before {
  content: "✅ 最终回答：";
  font-weight: 600;
  color: #409eff;
  display: block;
  margin-bottom: 6px;
}
</style>

<script>
// AI聊天功能JavaScript代码
let selectedNodeText = '';
let selectedNodeHierarchy = [];
let messages = [];
let isLoading = false;
let isMinimized = false;
let mindMapInstance = null;
let aiConfig = {
  provider: 'openai',
  apiKey: '',
  model: 'gpt-3.5-turbo',
  baseURL: 'https://api.openai.com/v1'
};

// 初始化AI聊天功能
function initAIChat() {
  // 显示AI聊天浮窗
  document.getElementById('aiChatBot').style.display = 'flex';

  // 设置调试模式（可以通过URL参数或localStorage控制）
  const urlParams = new URLSearchParams(window.location.search);
  window.debugMode = urlParams.get('debug') === 'true' || localStorage.getItem('ai_debug_mode') === 'true';

  if (window.debugMode) {
    console.log('🐛 AI调试模式已启用');
    console.log('💡 提示：在浏览器地址栏添加 ?debug=false 可关闭调试模式');
    console.log('💡 或者在控制台输入 toggleDebugMode() 来切换调试模式');
  }

  // 提供全局函数来切换调试模式
  window.toggleDebugMode = function(enable) {
    if (typeof enable === 'boolean') {
      window.debugMode = enable;
    } else {
      window.debugMode = !window.debugMode;
    }

    localStorage.setItem('ai_debug_mode', window.debugMode.toString());

    if (window.debugMode) {
      console.log('🐛 AI调试模式已启用');
    } else {
      console.log('🔇 AI调试模式已关闭');
    }
  };

  // 加载AI配置
  loadAIConfig();

  // 监听思维导图事件
  if (window.$bus) {
    window.$bus.$on('app_inited', (mindMap) => {
      console.log('思维导图初始化完成:', mindMap);
      mindMapInstance = mindMap;
      window.mindMapInstance = mindMapInstance; // 确保设置到全局
      bindMindMapEvents(mindMap);
    });
  }

  // 增强的思维导图实例检测
  const checkMindMapInstance = () => {
    // 方法1: 检查全局变量
    if (window.mindMap && !mindMapInstance) {
      console.log('从全局获取思维导图实例:', window.mindMap);
      mindMapInstance = window.mindMap;
      window.mindMapInstance = mindMapInstance; // 确保设置到全局
      bindMindMapEvents(mindMapInstance);
      return true;
    }

    if (window.app && window.app.mindMap && !mindMapInstance) {
      console.log('从app获取思维导图实例:', window.app.mindMap);
      mindMapInstance = window.app.mindMap;
      window.mindMapInstance = mindMapInstance; // 确保设置到全局
      bindMindMapEvents(mindMapInstance);
      return true;
    }

    // 方法2: 从Vue实例获取
    const mindMapContainer = document.querySelector('#app');
    if (mindMapContainer && mindMapContainer.__vue__) {
      const vueInstance = mindMapContainer.__vue__;

      // 检查Vue实例的子组件
      if (vueInstance.$children && vueInstance.$children.length > 0) {
        for (let child of vueInstance.$children) {
          if (child.mindMap && !mindMapInstance) {
            console.log('从Vue子组件获取思维导图实例:', child.mindMap);
            mindMapInstance = child.mindMap;
            window.mindMapInstance = mindMapInstance; // 确保设置到全局
            bindMindMapEvents(mindMapInstance);
            return true;
          }

          // 深度检查子组件的子组件
          if (child.$children && child.$children.length > 0) {
            for (let grandChild of child.$children) {
              if (grandChild.mindMap && !mindMapInstance) {
                console.log('从Vue孙组件获取思维导图实例:', grandChild.mindMap);
                mindMapInstance = grandChild.mindMap;
                window.mindMapInstance = mindMapInstance; // 确保设置到全局
                bindMindMapEvents(mindMapInstance);
                return true;
              }
            }
          }
        }
      }
    }

    // 方法3: 通过DOM事件监听获取
    if (!mindMapInstance) {
      setupDOMEventListeners();
    }

    return false;
  };

  // 设置DOM事件监听器来捕获思维导图交互
  const setupDOMEventListeners = () => {
    const svgElements = document.querySelectorAll('svg');
    svgElements.forEach(svg => {
      // 监听SVG点击事件
      svg.addEventListener('click', (e) => {
        // 尝试从事件中获取思维导图实例
        setTimeout(() => {
          tryGetMindMapFromDOM();
        }, 100);
      });
    });
  };

  // 从DOM状态尝试获取思维导图实例
  const tryGetMindMapFromDOM = () => {
    if (mindMapInstance) return;

    const mindMapContainer = document.querySelector('#app');
    if (mindMapContainer && mindMapContainer.__vue__) {
      const vueInstance = mindMapContainer.__vue__;

      // 递归搜索所有Vue组件实例
      const findMindMapInVueTree = (component) => {
        if (component.mindMap) {
          return component.mindMap;
        }

        if (component.$children) {
          for (let child of component.$children) {
            const result = findMindMapInVueTree(child);
            if (result) return result;
          }
        }

        return null;
      };

      const foundMindMap = findMindMapInVueTree(vueInstance);
      if (foundMindMap) {
        console.log('通过递归搜索找到思维导图实例:', foundMindMap);
        mindMapInstance = foundMindMap;
        window.mindMapInstance = mindMapInstance; // 确保设置到全局
        bindMindMapEvents(mindMapInstance);

        // 立即尝试同步当前激活节点
        setTimeout(() => {
          syncCurrentActiveNode();
        }, 500);
      }
    }
  };

  // 定期检查思维导图实例
  const checkInterval = setInterval(() => {
    if (checkMindMapInstance()) {
      clearInterval(checkInterval);
    }
  }, 1000);

  // 10秒后停止检查
  setTimeout(() => {
    clearInterval(checkInterval);
    // 如果还没找到，尝试最后一次DOM搜索
    if (!mindMapInstance) {
      console.log('最后尝试从DOM获取思维导图实例...');
      tryGetMindMapFromDOM();
    }
  }, 10000);
}

// 绑定思维导图事件
function bindMindMapEvents(mindMap) {
  console.log('绑定思维导图事件', mindMap);

  // 监听节点点击事件
  mindMap.on('node_click', (node) => {
    console.log('节点被点击:', node);
    updateSelectedNode(node);
  });

  // 监听节点激活事件
  mindMap.on('node_active', (node, activeNodeList) => {
    console.log('节点激活:', node, activeNodeList);
    if (activeNodeList && activeNodeList.length > 0) {
      updateSelectedNode(activeNodeList[0]);
    } else {
      selectedNodeText = '';
      selectedNodeHierarchy = [];
      updateContextInfo();
    }
  });

  // 监听数据变化事件
  mindMap.on('data_change', (data) => {
    console.log('思维导图数据变化:', data);
  });

  // 添加定时检查激活节点的机制
  const checkActiveNodes = () => {
    try {
      if (mindMap.renderer && mindMap.renderer.activeNodeList) {
        const activeNodes = mindMap.renderer.activeNodeList;
        if (activeNodes.length > 0) {
          const currentActiveNode = activeNodes[0];
          let currentRawText = currentActiveNode.nodeData ?
            currentActiveNode.nodeData.data.text :
            (currentActiveNode.getData ? currentActiveNode.getData('text') : '');

          // 清理HTML标签，获取纯文本用于比较
          let currentCleanText = '';
          if (typeof currentRawText === 'string') {
            const tempDiv = document.createElement('div');
            tempDiv.innerHTML = currentRawText;
            currentCleanText = tempDiv.textContent || tempDiv.innerText || currentRawText;
          } else {
            currentCleanText = currentRawText || '';
          }

          // 如果当前激活节点与记录的不同，更新选中节点
          if (currentCleanText && currentCleanText !== selectedNodeText) {
            // 只在调试模式下输出详细信息
            if (window.debugMode) {
              console.log('检测到新的激活节点:', currentRawText, '-> 清理后:', currentCleanText);
            }
            updateSelectedNode(currentActiveNode);
          }
        }
      }
    } catch (error) {
      console.error('检查激活节点失败:', error);
    }
  };

  // 每秒检查一次激活节点
  setInterval(checkActiveNodes, 1000);
}

// 更新选中节点
function updateSelectedNode(node) {
  if (!node) {
    selectedNodeText = '';
    selectedNodeHierarchy = [];
    updateContextInfo();
    return;
  }

  try {
    // 正确获取节点文本 - 参考ai-mind-map的实现
    let rawText = node.nodeData ? node.nodeData.data.text : (node.getData ? node.getData('text') : '');

    // 清理HTML标签，只保留纯文本
    if (typeof rawText === 'string') {
      // 创建临时DOM元素来解析HTML
      const tempDiv = document.createElement('div');
      tempDiv.innerHTML = rawText;
      selectedNodeText = tempDiv.textContent || tempDiv.innerText || rawText;
    } else {
      selectedNodeText = rawText || '';
    }

    selectedNodeHierarchy = getNodeHierarchy(node);
    updateContextInfo();
    showQuickActions();

    // 只在调试模式下输出详细信息
    if (window.debugMode) {
      console.log('节点选择成功:', {
        text: selectedNodeText,
        hierarchy: selectedNodeHierarchy,
        node: node,
        nodeData: node.nodeData
      });
    }
  } catch (error) {
    console.error('获取节点信息失败:', error);
    selectedNodeText = '';
    selectedNodeHierarchy = [];
    updateContextInfo();
  }
}

// 获取节点层级路径
function getNodeHierarchy(node) {
  const hierarchy = [];
  let currentNode = node;

  while (currentNode) {
    try {
      // 正确获取节点文本 - 兼容不同的节点数据结构
      let rawText = '';
      if (currentNode.nodeData && currentNode.nodeData.data) {
        rawText = currentNode.nodeData.data.text || '';
      } else if (currentNode.getData) {
        rawText = currentNode.getData('text') || '';
      }

      // 清理HTML标签，只保留纯文本
      let text = '';
      if (typeof rawText === 'string') {
        const tempDiv = document.createElement('div');
        tempDiv.innerHTML = rawText;
        text = tempDiv.textContent || tempDiv.innerText || rawText;
      } else {
        text = rawText || '';
      }

      if (text) {
        hierarchy.unshift(text);
      }
      currentNode = currentNode.parent;
    } catch (error) {
      console.error('获取父节点失败:', error);
      break;
    }
  }

  return hierarchy;
}

// 获取节点链路的详细信息（包括备注）
function getNodeHierarchyWithNotes(node) {
  const hierarchyWithNotes = [];
  let currentNode = node;

  while (currentNode) {
    try {
      // 获取节点文本
      let rawText = '';
      if (currentNode.nodeData && currentNode.nodeData.data) {
        rawText = currentNode.nodeData.data.text || '';
      } else if (currentNode.getData) {
        rawText = currentNode.getData('text') || '';
      }

      // 清理HTML标签，只保留纯文本
      let text = '';
      if (typeof rawText === 'string') {
        const tempDiv = document.createElement('div');
        tempDiv.innerHTML = rawText;
        text = tempDiv.textContent || tempDiv.innerText || rawText;
      } else {
        text = rawText || '';
      }

      // 获取节点备注
      let note = '';
      if (currentNode.nodeData && currentNode.nodeData.data) {
        note = currentNode.nodeData.data.note || '';
      } else if (currentNode.getData) {
        note = currentNode.getData('note') || '';
      }

      if (text) {
        hierarchyWithNotes.unshift({
          text: text,
          note: note
        });
      }
      currentNode = currentNode.parent;
    } catch (error) {
      console.error('获取父节点详细信息失败:', error);
      break;
    }
  }

  return hierarchyWithNotes;
}

// 更新上下文信息
function updateContextInfo() {
  const contextInfo = document.getElementById('contextInfo');
  const messageInput = document.getElementById('messageInput');

  if (selectedNodeText) {
    const hierarchyText = selectedNodeHierarchy.length > 1
      ? selectedNodeHierarchy.join(' › ')
      : selectedNodeText;
    contextInfo.textContent = `- ${selectedNodeText}`;
    contextInfo.title = `路径: ${hierarchyText}`;
    messageInput.placeholder = `询问关于"${selectedNodeText}"的问题...`;

    // 更新聊天窗口中的选中节点显示
    updateSelectedNodeDisplay();
  } else {
    contextInfo.textContent = '';
    contextInfo.title = '';
    messageInput.placeholder = '请先选择思维导图节点';
    hideSelectedNodeDisplay();
  }
}

// 更新选中节点显示区域
function updateSelectedNodeDisplay() {
  let nodeDisplay = document.getElementById('selectedNodeDisplay');

  if (!nodeDisplay) {
    // 创建选中节点显示区域
    nodeDisplay = document.createElement('div');
    nodeDisplay.id = 'selectedNodeDisplay';
    nodeDisplay.className = 'selected-node-display';

    const chatMessages = document.getElementById('chatMessages');
    if (chatMessages && chatMessages.parentNode) {
      chatMessages.parentNode.insertBefore(nodeDisplay, chatMessages);
    } else {
      // 如果找不到chatMessages，尝试插入到聊天窗口中
      const chatWindow = document.getElementById('aiChatWindow');
      if (chatWindow) {
        const header = chatWindow.querySelector('.chat-header');
        if (header && header.nextSibling) {
          chatWindow.insertBefore(nodeDisplay, header.nextSibling);
        } else {
          chatWindow.appendChild(nodeDisplay);
        }
      }
    }
  }

  if (selectedNodeText && selectedNodeHierarchy.length > 0) {
    nodeDisplay.innerHTML = `
      <div class="selected-node-content">
        <div class="node-indicator">
          <div class="indicator-dot"></div>
          <span class="indicator-text">当前选中节点</span>
        </div>
        <div class="node-text">${selectedNodeText}</div>
        <div class="node-path">
          <span class="path-label">路径:</span>
          <span class="path-text">${selectedNodeHierarchy.join(' › ')}</span>
        </div>
      </div>
    `;

    nodeDisplay.style.display = 'block';
    // 只在调试模式下输出
    if (window.debugMode) {
      console.log('选中节点显示区域已更新:', selectedNodeText, selectedNodeHierarchy);
    }
  } else {
    nodeDisplay.style.display = 'none';
  }
}

// 隐藏选中节点显示
function hideSelectedNodeDisplay() {
  const nodeDisplay = document.getElementById('selectedNodeDisplay');
  if (nodeDisplay) {
    nodeDisplay.style.display = 'none';
  }
}

// 显示快速操作
function showQuickActions() {
  if (!selectedNodeText) return;

  const welcomeMessage = document.querySelector('.welcome-message');
  if (welcomeMessage && messages.length === 0) {
    welcomeMessage.innerHTML = `
      <div class="welcome-content">
        <span class="ai-icon">🤖</span>
        <h3>AI思维导图助手</h3>
        <p>当前选中：${selectedNodeText}</p>
        <div class="quick-actions">
          <button onclick="sendQuickMessage('扩展这个节点')">扩展节点</button>
          <button onclick="sendQuickMessage('解释这个概念')">解释概念</button>
          <button onclick="sendQuickMessage('相关应用场景')">应用场景</button>
        </div>
      </div>
    `;
  }
}

// 发送快速消息
function sendQuickMessage(message) {
  document.getElementById('messageInput').value = message;
  sendMessage();
}

// 发送消息
async function sendMessage() {
  const input = document.getElementById('messageInput');
  const message = input.value.trim();

  if (!message || isLoading) return;

  input.value = '';

  // 添加用户消息
  addMessage('user', message);

  // 设置加载状态
  setLoading(true);

  try {
    // 调用AI API或模拟回复
    const response = await callAI(message);

    // 如果是模拟回复或非流式响应，使用传统方式添加消息
    if (response && response.content) {
      addMessage('assistant', response.content, response.suggestions, response.structuredPoints);
    }
    // 流式响应的消息已经在callRealAI中处理了
  } catch (error) {
    console.error('AI回复失败:', error);
    addMessage('assistant', '抱歉，我现在无法回复。请检查AI配置或稍后再试。');
  } finally {
    setLoading(false);
  }
}

// 调用AI API
async function callAI(message) {
  // 如果配置了真实的API Key，调用真实API
  if (aiConfig.apiKey && aiConfig.apiKey.trim()) {
    return await callRealAI(message);
  } else {
    // 否则使用模拟回复
    return await simulateAIResponse(message);
  }
}

// 调用真实AI API
async function callRealAI(message) {
  const { provider, apiKey, model, baseURL } = aiConfig;

  // 构建系统提示词
  const systemPrompt = getSystemPrompt();

  const messages = [
    {
      role: 'system',
      content: systemPrompt
    },
    {
      role: 'user',
      content: message
    }
  ];

  // 打印请求的prompt到控制台
  console.log('=== LLM API 请求 ===');
  console.log('🔧 配置信息:', { provider, model, baseURL: baseURL.replace(/\/+$/, '') });
  console.log('📝 完整请求消息:', JSON.stringify(messages, null, 2));
  console.log('💬 用户消息:', message);
  console.log('🤖 系统提示词:', systemPrompt);

  // 打印节点链路的详细信息
  if (mindMapInstance && mindMapInstance.renderer && mindMapInstance.renderer.activeNodeList && mindMapInstance.renderer.activeNodeList.length > 0) {
    const currentActiveNode = mindMapInstance.renderer.activeNodeList[0];
    const hierarchyWithNotes = getNodeHierarchyWithNotes(currentActiveNode);

    if (hierarchyWithNotes.length > 0) {
      console.log('🔗 节点链路详细信息:');
      hierarchyWithNotes.forEach((nodeInfo, index) => {
        console.log(`  ${index + 1}. 节点: "${nodeInfo.text}"`);
        if (nodeInfo.note && nodeInfo.note.trim()) {
          console.log(`     备注: ${nodeInfo.note.trim()}`);
        }
      });
    }
  }

  console.log('==================');

  const requestBody = {
    model,
    messages,
    max_tokens: 2000,
    temperature: 0.7,
    stream: true
  };

  const response = await fetch(`${baseURL}/chat/completions`, {
    method: 'POST',
    headers: {
      'Content-Type': 'application/json',
      'Authorization': `Bearer ${apiKey}`
    },
    body: JSON.stringify(requestBody)
  });

  if (!response.ok) {
    console.error('❌ API请求失败:', response.status, response.statusText);
    throw new Error(`API请求失败: ${response.status} ${response.statusText}`);
  }

  // 处理流式响应
  const reader = response.body.getReader();
  const decoder = new TextDecoder();
  let rawContent = '';
  let reasoning = '';
  let finalAnswer = '';
  let isReasoningModel = false;
  let buffer = '';

  // 移除加载消息，准备显示流式内容
  const loadingMessage = document.getElementById('loadingMessage');
  if (loadingMessage) {
    loadingMessage.remove();
  }

  // 创建流式消息容器
  const messageId = 'msg_' + Date.now() + '_' + Math.random().toString(36).substr(2, 5);
  const streamingDiv = document.createElement('div');
  streamingDiv.className = 'message-item assistant';
  streamingDiv.id = messageId;
  streamingDiv.innerHTML = `
    <div class="message-avatar">🤖</div>
    <div class="message-content">
      <div id="${messageId}_reasoning" class="reasoning-content" style="display: none;"></div>
      <div id="${messageId}_content" class="message-text"></div>
    </div>
  `;

  const messagesContainer = document.getElementById('chatMessages');
  messagesContainer.appendChild(streamingDiv);
  messagesContainer.scrollTop = messagesContainer.scrollHeight;

  const reasoningElement = document.getElementById(`${messageId}_reasoning`);
  const contentElement = document.getElementById(`${messageId}_content`);

  try {
    while (true) {
      const { done, value } = await reader.read();
      if (done) break;

      buffer += decoder.decode(value, { stream: true });
      const lines = buffer.split('\n');
      buffer = lines.pop(); // 保留最后一行（可能不完整）

      for (const line of lines) {
        if (line.startsWith('data: ')) {
          const data = line.slice(6);
          if (data === '[DONE]') continue;

          try {
            const parsed = JSON.parse(data);
            const delta = parsed.choices?.[0]?.delta;

            if (!delta) continue;

            // 检测是否为推理模型
            if (delta.reasoning_content !== undefined) {
              isReasoningModel = true;
              if (delta.reasoning_content) {
                reasoning += delta.reasoning_content;
                reasoningElement.textContent = reasoning;
                reasoningElement.style.display = 'block';
              }
            }

            if (delta.content) {
              rawContent += delta.content;
              finalAnswer += delta.content;

              // 实现打字机效果
              await typewriterEffect(contentElement, delta.content);
            }

            // 自动滚动到底部
            messagesContainer.scrollTop = messagesContainer.scrollHeight;
          } catch (e) {
            console.warn('解析流式数据失败:', e, data);
          }
        }
      }
    }
  } catch (error) {
    console.error('流式处理失败:', error);
    contentElement.textContent = '抱歉，处理响应时出现错误。';
  }

  // 如果是推理模型但没有检测到reasoning_content，尝试从内容中提取
  if (!isReasoningModel && rawContent) {
    const reasoningResult = extractReasoningFromContent(rawContent);
    if (reasoningResult.isReasoningModel) {
      isReasoningModel = true;
      reasoning = reasoningResult.reasoning;
      finalAnswer = reasoningResult.finalAnswer;

      if (reasoning) {
        reasoningElement.textContent = reasoning;
        reasoningElement.style.display = 'block';
      }

      contentElement.innerHTML = `<div class="final-answer">${finalAnswer}</div>`;
    }
  }

  // 构造完整的数据对象用于后续处理
  const data = {
    choices: [{
      message: {
        content: rawContent,
        reasoning_content: reasoning
      }
    }],
    model: model
  };

  // 检测并处理推理过程
  const reasoningResult = extractReasoningProcess(data, rawContent);

  // 打印原始响应到控制台
  console.log('=== LLM API 响应 ===');
  console.log('📊 完整响应数据:', JSON.stringify(data, null, 2));
  console.log('💭 原始回答内容:', rawContent);

  // 如果是推理模型，单独显示推理过程
  if (reasoningResult.isReasoningModel) {
    console.log('🧠 推理模型检测: 是');
    if (reasoningResult.reasoning) {
      console.log('🤔 推理过程:');
      console.log('%c' + reasoningResult.reasoning, 'color: #888; font-style: italic;');
    }
    if (reasoningResult.finalAnswer) {
      console.log('✅ 最终回答:', reasoningResult.finalAnswer);
    }
  } else {
    console.log('🧠 推理模型检测: 否');
  }

  if (data.usage) {
    console.log('📈 Token使用情况:', data.usage);
  }
  console.log('==================');

  // 解析回复内容
  const content = cleanResponseContent(rawContent);
  const suggestions = extractSuggestions(rawContent);
  const structuredPoints = parseStructuredPoints(rawContent);

  // 打印解析后的结果
  console.log('=== 解析结果 ===');
  console.log('📄 清理后内容:', content);
  console.log('💡 提取的建议:', suggestions);
  console.log('📋 结构化分点:', structuredPoints);
  console.log('===============');

  // 为流式消息添加建议和结构化分点
  if (suggestions.length > 0 || structuredPoints.length > 0) {
    const streamingMessage = document.getElementById(messageId);
    if (streamingMessage) {
      const messageContent = streamingMessage.querySelector('.message-content');

      // 添加建议
      if (suggestions.length > 0) {
        const suggestionButtons = suggestions.map(s =>
          `<button class="suggestion-btn" onclick="addSuggestionToMindMap('${s.text}', '${s.type || 'child'}')">${s.text}</button>`
        ).join('');

        const suggestionsHtml = `
          <div class="suggestions">
            <div class="suggestions-title">💡 AI建议</div>
            <div class="suggestions-list">${suggestionButtons}</div>
          </div>
        `;
        messageContent.insertAdjacentHTML('beforeend', suggestionsHtml);
      }

      // 添加结构化分点
      if (structuredPoints.length > 0) {
        const pointsHtml = structuredPoints.map((point, index) => `
          <div class="structured-point" data-point-id="${point.id || index}">
            <div class="point-header">
              <input type="checkbox" class="point-checkbox" id="point_${messageId}_${index}">
              <label for="point_${messageId}_${index}" class="point-title">${point.title}</label>
            </div>
            <div class="point-content">${point.content}</div>
            ${point.keywords ? `<div class="point-keywords">${point.keywords.map(k => `<span class="keyword">${k}</span>`).join('')}</div>` : ''}
          </div>
        `).join('');

        const structuredPointsHtml = `
          <div class="structured-points">
            <div class="points-header">
              <div class="points-title">📋 结构化分点</div>
              <div class="points-actions">
                <button class="select-all-btn" onclick="selectAllPoints('${messageId}')">全选</button>
                <button class="add-selected-btn" onclick="addSelectedPoints('${messageId}')">添加选中</button>
              </div>
            </div>
            <div class="points-list">${pointsHtml}</div>
          </div>
        `;
        messageContent.insertAdjacentHTML('beforeend', structuredPointsHtml);
      }
    }
  }

  // 流式响应不需要返回内容，因为已经直接显示了
  return null;
}

// 获取系统提示词
function getSystemPrompt() {
  const jsonExample = '```json\n{\n  "structuredPoints": [\n    {\n      "id": "point_1",\n      "title": "概括性标题",\n      "content": "详细解释内容",\n      "keywords": ["关键词1", "关键词2"]\n    }\n  ]\n}\n```';

  let prompt = `你是一个专业的思维导图AI助手。你的任务是帮助用户扩展和完善思维导图。

核心能力：
1. 分析思维导图节点内容
2. 提供相关的子节点建议
3. 回答与节点内容相关的问题
4. 帮助用户理清思路和逻辑关系

回复要求：
- 首先提供一个简洁的总体回答（100-200字）
- 然后提供结构化的分点供用户选择添加到思维导图
- 保持逻辑性和条理性

重要：请按以下格式回复：
1. 先给出一个简洁的总体回答
2. 然后在回答的最后，用以下JSON格式提供结构化分点：
${jsonExample}

每个分点应该：
- 有一个简洁的标题
- 包含详细的解释内容
- 可以作为思维导图的节点添加
- 具有实际价值，帮助用户扩展思维导图`;

  // 获取当前选中节点的详细上下文信息
  if (selectedNodeText && selectedNodeHierarchy.length > 0) {
    prompt += `

当前上下文：
- 选中节点：${selectedNodeText}
- 节点路径：${selectedNodeHierarchy.join(' > ')}`;

    // 获取节点链路的详细信息（包括备注）
    if (mindMapInstance && mindMapInstance.renderer && mindMapInstance.renderer.activeNodeList && mindMapInstance.renderer.activeNodeList.length > 0) {
      const currentActiveNode = mindMapInstance.renderer.activeNodeList[0];
      const hierarchyWithNotes = getNodeHierarchyWithNotes(currentActiveNode);

      if (hierarchyWithNotes.length > 0) {
        prompt += `

节点链路详细信息：`;
        hierarchyWithNotes.forEach((nodeInfo, index) => {
          prompt += `
${index + 1}. 节点："${nodeInfo.text}"`;
          if (nodeInfo.note && nodeInfo.note.trim()) {
            prompt += `
   备注：${nodeInfo.note.trim()}`;
          }
        });
      }
    }

    prompt += `

- 请基于这个节点的上下文和链路信息来回答用户的问题`;
  }

  return prompt;
}

// 打字机效果函数
async function typewriterEffect(element, text) {
  return new Promise((resolve) => {
    let currentText = element.textContent || '';
    element.textContent = currentText + text;

    // 简单的延迟，可以根据需要调整
    setTimeout(resolve, 10);
  });
}

// 从内容中提取推理过程（用于非官方推理模型格式）
function extractReasoningFromContent(content) {
  const result = {
    isReasoningModel: false,
    reasoning: '',
    finalAnswer: content
  };

  // 检测推理模式的关键词
  const reasoningKeywords = ['让我思考', '思考过程', '推理过程', '<thinking>', '<reasoning>'];
  const hasReasoningPattern = reasoningKeywords.some(keyword => content.includes(keyword));

  if (hasReasoningPattern) {
    result.isReasoningModel = true;

    // 尝试提取推理过程
    const reasoningPatterns = [
      /<thinking>([\s\S]*?)<\/thinking>/i,
      /<reasoning>([\s\S]*?)<\/reasoning>/i,
      /(?:思考过程：|推理过程：|让我思考一下[：:]?)([\s\S]*?)(?:结论：|答案：|回答：|最终答案：)/i,
    ];

    for (const pattern of reasoningPatterns) {
      const match = content.match(pattern);
      if (match) {
        result.reasoning = match[1].trim();
        result.finalAnswer = content.replace(match[0], '').trim();
        break;
      }
    }
  }

  return result;
}

// 检测并提取推理过程
function extractReasoningProcess(data, rawContent) {
  const result = {
    isReasoningModel: false,
    reasoning: null,
    finalAnswer: null
  };

  // 检测方法1: 检查模型名称是否包含推理相关关键词
  const modelName = (data.model || '').toLowerCase();
  const reasoningKeywords = ['reasoner', 'reasoning', 'think', 'cot', 'chain-of-thought'];
  const isReasoningByModel = reasoningKeywords.some(keyword => modelName.includes(keyword));

  // 检测方法2: 检查响应结构是否包含推理字段（DeepSeek官方格式）
  const choice = data.choices && data.choices[0];
  const hasDeepSeekReasoningField = choice && choice.message && choice.message.reasoning_content;

  // 检测方法3: 检查响应结构是否包含其他推理字段（兼容其他格式）
  const hasOtherReasoningField = choice && (choice.reasoning || choice.message?.reasoning);

  // 检测方法4: 检查内容格式是否符合推理模式
  const hasReasoningPattern = rawContent && (
    rawContent.includes('<thinking>') ||
    rawContent.includes('<reasoning>') ||
    rawContent.includes('让我思考一下') ||
    rawContent.includes('思考过程：') ||
    rawContent.includes('推理过程：') ||
    /^[\s\S]*?(?:思考|推理|分析)[\s\S]*?(?:结论|答案|回答)[\s\S]*$/i.test(rawContent)
  );

  result.isReasoningModel = isReasoningByModel || hasDeepSeekReasoningField || hasOtherReasoningField || hasReasoningPattern;

  if (result.isReasoningModel) {
    // 提取推理过程
    if (choice && choice.message && choice.message.reasoning_content) {
      // 方法1: DeepSeek官方格式 - 从message.reasoning_content字段提取
      result.reasoning = choice.message.reasoning_content;
      result.finalAnswer = rawContent; // rawContent就是content字段的内容
    } else if (choice && choice.reasoning) {
      // 方法2: 从API响应的reasoning字段提取（其他格式）
      result.reasoning = choice.reasoning;
      result.finalAnswer = rawContent;
    } else if (choice && choice.message && choice.message.reasoning) {
      // 方法3: 从message.reasoning字段提取（其他格式）
      result.reasoning = choice.message.reasoning;
      result.finalAnswer = rawContent;
    } else if (rawContent) {
      // 方法3: 从内容中解析推理过程
      const reasoningPatterns = [
        // <thinking>标签格式
        /<thinking>([\s\S]*?)<\/thinking>/i,
        /<reasoning>([\s\S]*?)<\/reasoning>/i,
        // 中文格式
        /(?:思考过程：|推理过程：|让我思考一下[：:]?)([\s\S]*?)(?:结论：|答案：|回答：|最终答案：)/i,
        // 分段格式
        /^([\s\S]*?)(?:\n\n|^)(?:结论|答案|回答|最终答案)[：:]?([\s\S]*)$/i
      ];

      for (const pattern of reasoningPatterns) {
        const match = rawContent.match(pattern);
        if (match) {
          if (pattern.source.includes('thinking') || pattern.source.includes('reasoning')) {
            result.reasoning = match[1].trim();
            result.finalAnswer = rawContent.replace(match[0], '').trim();
          } else if (pattern.source.includes('思考过程') || pattern.source.includes('推理过程')) {
            result.reasoning = match[1].trim();
            const finalMatch = rawContent.match(/(?:结论：|答案：|回答：|最终答案：)([\s\S]*)$/i);
            result.finalAnswer = finalMatch ? finalMatch[1].trim() : rawContent;
          } else {
            result.reasoning = match[1].trim();
            result.finalAnswer = match[2] ? match[2].trim() : rawContent;
          }
          break;
        }
      }

      // 如果没有找到明确的分隔，但检测到是推理模型，尝试智能分割
      if (!result.reasoning && result.isReasoningModel) {
        const lines = rawContent.split('\n');
        const thinkingLines = [];
        const answerLines = [];
        let isInAnswer = false;

        for (const line of lines) {
          const trimmed = line.trim();
          if (trimmed.match(/^(?:结论|答案|回答|最终答案|总结)[：:]?/i)) {
            isInAnswer = true;
          }

          if (isInAnswer) {
            answerLines.push(line);
          } else {
            thinkingLines.push(line);
          }
        }

        if (thinkingLines.length > 0 && answerLines.length > 0) {
          result.reasoning = thinkingLines.join('\n').trim();
          result.finalAnswer = answerLines.join('\n').trim();
        }
      }
    }
  }

  return result;
}

// 清理AI回复内容
function cleanResponseContent(content) {
  // 移除JSON代码块，只保留文本内容
  return content.replace(/```json[\s\S]*?```/g, '').trim();
}

// 解析结构化分点
function parseStructuredPoints(content) {
  try {
    // 查找JSON代码块
    const jsonMatch = content.match(/```json\s*(\{[\s\S]*?\})\s*```/);
    if (!jsonMatch) {
      return [];
    }

    const jsonData = JSON.parse(jsonMatch[1]);
    if (jsonData.structuredPoints && Array.isArray(jsonData.structuredPoints)) {
      return jsonData.structuredPoints.map((point, index) => ({
        id: point.id || `point_${index + 1}`,
        title: point.title || `要点${index + 1}`,
        content: point.content || '',
        keywords: Array.isArray(point.keywords) ? point.keywords : []
      }));
    }
  } catch (error) {
    console.error('解析结构化分点失败:', error);
  }
  return [];
}

// 模拟AI回复
async function simulateAIResponse(message) {
  // 模拟网络延迟
  await new Promise(resolve => setTimeout(resolve, 1500));

  let content = '';
  let suggestions = [];
  let structuredPoints = [];

  if (message.includes('扩展')) {
    content = `关于"${selectedNodeText}"的扩展建议：\n\n我为您提供了详细的扩展方案，包括多个维度的分析。`;
    suggestions = [
      { text: '定义和概念', type: 'child' },
      { text: '应用场景', type: 'child' },
      { text: '相关技术', type: 'child' }
    ];

    // 生成结构化分点
    structuredPoints = [
      {
        id: 'point_1',
        title: '基础概念',
        content: `${selectedNodeText}的核心定义和基本原理`,
        keywords: ['定义', '原理', '基础']
      },
      {
        id: 'point_2',
        title: '技术特点',
        content: `${selectedNodeText}的主要技术特征和优势`,
        keywords: ['特点', '优势', '技术']
      },
      {
        id: 'point_3',
        title: '应用领域',
        content: `${selectedNodeText}在各个行业的具体应用`,
        keywords: ['应用', '行业', '实践']
      },
      {
        id: 'point_4',
        title: '发展趋势',
        content: `${selectedNodeText}的未来发展方向和趋势`,
        keywords: ['趋势', '发展', '未来']
      }
    ];
  } else if (message.includes('解释')) {
    content = `"${selectedNodeText}"的详细解释：\n\n我为您提供了全面的解释，包含多个层面的分析。`;
    suggestions = [
      { text: '核心特点', type: 'child' },
      { text: '工作原理', type: 'child' }
    ];

    structuredPoints = [
      {
        id: 'explain_1',
        title: '基本含义',
        content: `${selectedNodeText}的基本定义和含义`,
        keywords: ['定义', '含义', '基本']
      },
      {
        id: 'explain_2',
        title: '核心要素',
        content: `构成${selectedNodeText}的关键要素和组成部分`,
        keywords: ['要素', '组成', '核心']
      },
      {
        id: 'explain_3',
        title: '运作机制',
        content: `${selectedNodeText}的工作原理和运作方式`,
        keywords: ['原理', '机制', '运作']
      }
    ];
  } else if (message.includes('应用')) {
    content = `"${selectedNodeText}"的应用场景分析：\n\n我整理了多个实际应用场景供您参考。`;
    suggestions = [
      { text: '商业应用', type: 'child' },
      { text: '技术应用', type: 'child' }
    ];

    structuredPoints = [
      {
        id: 'app_1',
        title: '商业场景',
        content: `${selectedNodeText}在商业环境中的应用`,
        keywords: ['商业', '企业', '市场']
      },
      {
        id: 'app_2',
        title: '技术场景',
        content: `${selectedNodeText}在技术开发中的应用`,
        keywords: ['技术', '开发', '工程']
      },
      {
        id: 'app_3',
        title: '教育场景',
        content: `${selectedNodeText}在教育培训中的应用`,
        keywords: ['教育', '培训', '学习']
      }
    ];
  } else {
    content = `关于"${selectedNodeText}"，我理解您的问题。这是一个很有趣的话题，我为您提供了多角度的分析。`;
    suggestions = [
      { text: '深入了解', type: 'child' },
      { text: '实践应用', type: 'child' }
    ];

    structuredPoints = [
      {
        id: 'general_1',
        title: '概述',
        content: `${selectedNodeText}的总体概述和重要性`,
        keywords: ['概述', '重要性', '总体']
      },
      {
        id: 'general_2',
        title: '关键点',
        content: `关于${selectedNodeText}需要重点关注的方面`,
        keywords: ['关键', '重点', '核心']
      }
    ];
  }

  return { content, suggestions, structuredPoints };
}

// 从AI回复中提取建议
function extractSuggestions(content) {
  const suggestions = [];
  const lines = content.split('\n');

  lines.forEach(line => {
    const trimmed = line.trim();
    if (trimmed.startsWith('- ') || trimmed.startsWith('• ')) {
      const text = trimmed.substring(2).trim();
      if (text.length > 0 && text.length < 50) {
        suggestions.push({
          text,
          type: 'child'
        });
      }
    }
  });

  return suggestions.slice(0, 3);
}

// 添加消息
function addMessage(role, content, suggestions = [], structuredPoints = []) {
  const messagesContainer = document.getElementById('chatMessages');

  // 移除欢迎消息
  const welcomeMessage = messagesContainer.querySelector('.welcome-message');
  if (welcomeMessage && messages.length === 0) {
    welcomeMessage.remove();
  }

  const messageId = 'msg_' + Date.now() + '_' + Math.random().toString(36).substr(2, 5);
  const messageDiv = document.createElement('div');
  messageDiv.className = `message-item ${role}`;
  messageDiv.id = messageId;

  const avatar = role === 'user' ? '👤' : '🤖';

  // 普通建议HTML
  let suggestionsHtml = '';
  if (suggestions && suggestions.length > 0) {
    const suggestionButtons = suggestions.map(s =>
      `<button class="suggestion-btn" onclick="addSuggestionToMindMap('${s.text}', '${s.type || 'child'}')">${s.text}</button>`
    ).join('');

    suggestionsHtml = `
      <div class="suggestions">
        <div class="suggestions-title">💡 AI建议</div>
        <div class="suggestions-list">${suggestionButtons}</div>
      </div>
    `;
  }

  // 结构化分点HTML
  let structuredPointsHtml = '';
  if (structuredPoints && structuredPoints.length > 0) {
    const pointsHtml = structuredPoints.map((point, index) => `
      <div class="structured-point" data-point-id="${point.id || index}">
        <div class="point-header">
          <input type="checkbox" class="point-checkbox" id="point_${messageId}_${index}">
          <label for="point_${messageId}_${index}" class="point-title">${point.title}</label>
        </div>
        <div class="point-content">${point.content}</div>
        ${point.keywords ? `<div class="point-keywords">${point.keywords.map(k => `<span class="keyword">${k}</span>`).join('')}</div>` : ''}
      </div>
    `).join('');

    structuredPointsHtml = `
      <div class="structured-points">
        <div class="points-header">
          <div class="points-title">📋 结构化分点</div>
          <div class="points-actions">
            <button class="select-all-btn" onclick="selectAllPoints('${messageId}')">全选</button>
            <button class="add-selected-btn" onclick="addSelectedPoints('${messageId}')">添加选中</button>
          </div>
        </div>
        <div class="points-list">${pointsHtml}</div>
      </div>
    `;
  }

  messageDiv.innerHTML = `
    <div class="message-avatar">${avatar}</div>
    <div class="message-content">
      <div class="message-text">${content}</div>
      ${suggestionsHtml}
      ${structuredPointsHtml}
    </div>
  `;

  messagesContainer.appendChild(messageDiv);
  messagesContainer.scrollTop = messagesContainer.scrollHeight;

  messages.push({ role, content, suggestions, structuredPoints });
}

// 添加系统消息
function addSystemMessage(content) {
  const messagesContainer = document.getElementById('chatMessages');

  const messageDiv = document.createElement('div');
  messageDiv.className = 'message-item system';
  messageDiv.innerHTML = `
    <div class="message-content">
      ${content}
    </div>
  `;

  messagesContainer.appendChild(messageDiv);
  messagesContainer.scrollTop = messagesContainer.scrollHeight;
}

// 设置加载状态
function setLoading(loading) {
  isLoading = loading;
  const sendBtn = document.getElementById('sendBtn');
  const input = document.getElementById('messageInput');

  if (loading) {
    sendBtn.textContent = '发送中...';
    sendBtn.disabled = true;
    input.disabled = true;

    // 添加加载消息
    const messagesContainer = document.getElementById('chatMessages');
    const loadingDiv = document.createElement('div');
    loadingDiv.className = 'message-item assistant';
    loadingDiv.id = 'loadingMessage';
    loadingDiv.innerHTML = `
      <div class="message-avatar loading">🤖</div>
      <div class="message-content">
        <div class="message-text">AI正在思考中<span class="thinking-dots"><span class="dot"></span><span class="dot"></span><span class="dot"></span></span></div>
      </div>
    `;
    messagesContainer.appendChild(loadingDiv);
    messagesContainer.scrollTop = messagesContainer.scrollHeight;
  } else {
    sendBtn.textContent = '发送';
    sendBtn.disabled = false;
    input.disabled = false;

    // 移除加载消息
    const loadingMessage = document.getElementById('loadingMessage');
    if (loadingMessage) {
      loadingMessage.remove();
    }
  }
}

// 添加建议到思维导图
function addSuggestionToMindMap(text, type = 'child') {
  if (!mindMapInstance) {
    showNotification('❌ 思维导图未初始化，请等待加载完成', 'error');
    return;
  }

  try {
    // 获取当前激活的节点
    const activeNodes = mindMapInstance.renderer.activeNodeList;
    if (!activeNodes || activeNodes.length === 0) {
      showNotification('⚠️ 请先点击选择一个思维导图节点', 'warning');
      return;
    }

    const parentNode = activeNodes[0];
    console.log('添加节点到:', parentNode, '文本:', text, '类型:', type);

    // 根据类型添加节点 - 使用正确的参数格式
    if (type === 'child') {
      // 添加子节点
      mindMapInstance.execCommand('INSERT_CHILD_NODE', false, [], {
        text: text,
        uid: generateNodeId()
      });
    } else if (type === 'sibling') {
      // 添加兄弟节点
      mindMapInstance.execCommand('INSERT_NODE', false, [], {
        text: text,
        uid: generateNodeId()
      });
    }

    showNotification(`✅ 已添加"${text}"到思维导图`, 'success');

    // 触发数据保存
    try {
      if (typeof window.takeOverAppMethods?.saveMindMapData === 'function') {
        const data = mindMapInstance.getData();
        window.takeOverAppMethods.saveMindMapData(data);
      }
    } catch (saveError) {
      console.warn('保存数据失败:', saveError);
    }

  } catch (error) {
    console.error('添加节点失败:', error);
    showNotification('❌ 添加节点失败: ' + error.message, 'error');
  }
}

// 生成唯一节点ID
function generateNodeId() {
  return 'ai_node_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9);
}

// 手动同步当前激活节点
function syncCurrentActiveNode() {
  if (!mindMapInstance) {
    console.log('思维导图实例不存在，无法同步');
    showNotification('❌ 思维导图未初始化', 'error');
    return false;
  }

  try {
    const activeNodes = mindMapInstance.renderer.activeNodeList;
    if (activeNodes && activeNodes.length > 0) {
      const currentActiveNode = activeNodes[0];
      console.log('手动同步激活节点:', currentActiveNode);
      updateSelectedNode(currentActiveNode);

      // 获取节点文本用于通知
      let rawNodeText = currentActiveNode.nodeData ?
        currentActiveNode.nodeData.data.text :
        (currentActiveNode.getData ? currentActiveNode.getData('text') : '未知节点');

      // 清理HTML标签
      let nodeText = '';
      if (typeof rawNodeText === 'string') {
        const tempDiv = document.createElement('div');
        tempDiv.innerHTML = rawNodeText;
        nodeText = tempDiv.textContent || tempDiv.innerText || rawNodeText;
      } else {
        nodeText = rawNodeText || '未知节点';
      }

      showNotification(`✅ 已同步节点: ${nodeText}`, 'success');
      return true;
    } else {
      console.log('没有激活的节点');
      showNotification('⚠️ 没有选中的节点，请先点击思维导图中的节点', 'warning');
      return false;
    }
  } catch (error) {
    console.error('同步激活节点失败:', error);
    showNotification('❌ 同步失败: ' + error.message, 'error');
    return false;
  }
}

// 批量添加结构化分点
async function addStructuredPoints(points) {
  console.log('🚀 addStructuredPoints 被调用，接收到的数据:', points);
  console.log('🚀 数据类型:', typeof points, '数据长度:', points ? points.length : 'undefined');

  if (!points || points.length === 0) {
    console.error('❌ 无效的参数：没有分点数据');
    showNotification('❌ 无效的参数：没有分点数据', 'error');
    return;
  }

  if (!mindMapInstance) {
    console.error('❌ 思维导图未初始化');
    showNotification('❌ 思维导图未初始化，请等待加载完成', 'error');
    return;
  }

  // 尝试手动同步当前激活节点
  syncCurrentActiveNode();

  try {
    const activeNodes = mindMapInstance.renderer.activeNodeList;
    console.log('🔍 当前激活节点:', activeNodes);

    if (!activeNodes || activeNodes.length === 0) {
      console.error('❌ 没有激活的节点');
      showNotification('⚠️ 请先点击选择一个思维导图节点', 'warning');
      return;
    }

    const parentNode = activeNodes[0];
    console.log('🔍 父节点:', parentNode);
    console.log('🚀 开始批量添加分点到节点:', parentNode.getData().text);

    // 获取添加前的节点数据
    const beforeData = mindMapInstance.getData();
    const beforeNodeCount = countAllNodes(beforeData);
    console.log(`🔍 添加前节点总数: ${beforeNodeCount}`);

    // 准备批量添加的节点数据
    const nodesToAdd = [];
    points.forEach((point, index) => {
      const nodeText = point.title || point.text || `分点${index + 1}`;
      console.log(`🔍 准备第${index + 1}个分点: "${nodeText}"`);

      if (nodeText && nodeText.trim().length > 0) {
        nodesToAdd.push({
          data: {
            text: nodeText,
            uid: generateNodeId(),
            note: point.content || '' // 将详细内容作为备注
          },
          children: []
        });
      }
    });

    console.log(`🚀 准备批量添加 ${nodesToAdd.length} 个分点:`, nodesToAdd);

    let actualAddedCount = 0;
    const results = [];

    try {
      if (nodesToAdd.length > 0) {
        console.log(`🚀 执行 INSERT_MULTI_CHILD_NODE 命令，批量添加 ${nodesToAdd.length} 个节点`);

        // 使用正确的批量添加命令调用方式
        mindMapInstance.execCommand('INSERT_MULTI_CHILD_NODE', [], nodesToAdd);

        console.log(`✅ INSERT_MULTI_CHILD_NODE 命令执行完成`);

        // 验证是否添加成功
        const afterData = mindMapInstance.getData();
        const afterNodeCount = countAllNodes(afterData);
        console.log(`🔍 添加后节点总数: ${afterNodeCount}`);

        const addedCount = afterNodeCount - beforeNodeCount;
        if (addedCount > 0) {
          actualAddedCount = addedCount;
          console.log(`✅ 成功批量添加 ${actualAddedCount} 个分点`);

          // 为每个成功添加的节点记录结果
          nodesToAdd.forEach((nodeData, index) => {
            results.push({
              text: nodeData.data.text,
              success: true,
              error: ''
            });
          });

          // 等待一下让节点渲染完成，然后设置备注
          setTimeout(async () => {
            console.log(`🔍 开始为新添加的节点设置备注...`);

            try {
              // 获取当前激活节点的子节点
              const currentActiveNodes = mindMapInstance.renderer.activeNodeList;
              if (currentActiveNodes && currentActiveNodes.length > 0) {
                const parentNode = currentActiveNodes[0];

                // 遍历父节点的子节点，为新添加的节点设置备注
                if (parentNode.children && parentNode.children.length > 0) {
                  const newlyAddedNodes = parentNode.children.slice(-nodesToAdd.length);

                  newlyAddedNodes.forEach((childNode, index) => {
                    const correspondingPoint = points[index];
                    if (correspondingPoint && correspondingPoint.content) {
                      console.log(`🔍 为节点 "${childNode.getData().text}" 设置备注: "${correspondingPoint.content}"`);

                      try {
                        childNode.setNote(correspondingPoint.content);
                        console.log(`✅ 成功设置备注`);
                      } catch (noteError) {
                        console.error(`❌ 设置备注失败:`, noteError);
                      }
                    }
                  });
                }
              }
            } catch (noteError) {
              console.error(`❌ 设置备注过程失败:`, noteError);
            }
          }, 500);

        } else {
          console.log(`❌ 批量添加失败，节点数未增加`);
          console.log(`🔍 添加前: ${beforeNodeCount}, 添加后: ${afterNodeCount}`);

          // 为每个节点记录失败结果
          nodesToAdd.forEach((nodeData, index) => {
            results.push({
              text: nodeData.data.text,
              success: false,
              error: '节点数未增加'
            });
          });
        }
      }
    } catch (error) {
      console.error(`❌ 批量添加分点失败:`, error);

      // 为每个节点记录失败结果
      nodesToAdd.forEach((nodeData, index) => {
        results.push({
          text: nodeData.data.text,
          success: false,
          error: error.message
        });
      });
    }

    console.log('=== 添加结果统计 ===');
    console.log(`尝试添加: ${points.length} 个分点`);
    console.log(`实际添加: ${actualAddedCount} 个分点`);

    // 显示详细结果
    results.forEach((result, index) => {
      console.log(`分点${index + 1}: ${result.text} - ${result.success ? '成功' : '失败' + (result.error ? ` (${result.error})` : '')}`);
    });

    // 显示准确的通知
    if (actualAddedCount > 0) {
      showNotification(`✅ 已添加 ${actualAddedCount} 个分点到思维导图`, 'success');

      // 触发数据保存
      try {
        if (typeof window.takeOverAppMethods?.saveMindMapData === 'function') {
          const finalData = mindMapInstance.getData();
          window.takeOverAppMethods.saveMindMapData(finalData);
        }
      } catch (saveError) {
        console.warn('保存数据失败:', saveError);
      }
    } else {
      showNotification('❌ 没有成功添加任何分点', 'error');
    }

  } catch (error) {
    console.error('批量添加节点失败:', error);
    showNotification('❌ 批量添加失败: ' + error.message, 'error');
  }
}

// 辅助函数：递归计算思维导图中的所有节点数量
function countAllNodes(data) {
  if (!data) return 0;

  let count = 1; // 当前节点

  if (data.children && Array.isArray(data.children)) {
    data.children.forEach(child => {
      count += countAllNodes(child);
    });
  }

  return count;
}

// 切换最小化状态
function toggleMinimize() {
  isMinimized = !isMinimized;
  const chatBot = document.getElementById('aiChatBot');
  const minimizeBtn = document.getElementById('minimizeBtn');

  if (isMinimized) {
    chatBot.classList.add('minimized');
    minimizeBtn.textContent = '⬆️';
    minimizeBtn.title = '展开';
  } else {
    chatBot.classList.remove('minimized');
    minimizeBtn.textContent = '⬇️';
    minimizeBtn.title = '最小化';
  }
}

// 清除消息
function clearMessages() {
  const messagesContainer = document.getElementById('chatMessages');
  messagesContainer.innerHTML = `
    <div class="welcome-message">
      <div class="welcome-content">
        <span class="ai-icon">🤖</span>
        <h3>AI思维导图助手</h3>
        <p>点击思维导图节点开始对话</p>
      </div>
    </div>
  `;
  messages = [];
}

// 显示配置
function showConfig() {
  document.getElementById('aiConfigPanel').style.display = 'block';

  // 加载当前配置到表单
  document.getElementById('aiProvider').value = aiConfig.provider;
  document.getElementById('apiKey').value = aiConfig.apiKey;
  document.getElementById('aiModel').value = aiConfig.model;
  document.getElementById('baseURL').value = aiConfig.baseURL;
}

// 关闭配置
function closeConfig() {
  document.getElementById('aiConfigPanel').style.display = 'none';
}

// 保存配置
function saveConfig() {
  aiConfig.provider = document.getElementById('aiProvider').value;
  aiConfig.apiKey = document.getElementById('apiKey').value;
  aiConfig.model = document.getElementById('aiModel').value;
  aiConfig.baseURL = document.getElementById('baseURL').value;

  // 保存到本地存储
  localStorage.setItem('ai_config', JSON.stringify(aiConfig));

  alert('配置保存成功');
  closeConfig();
}

// 加载AI配置
function loadAIConfig() {
  try {
    const saved = localStorage.getItem('ai_config');
    if (saved) {
      aiConfig = { ...aiConfig, ...JSON.parse(saved) };
    }
  } catch (error) {
    console.error('加载AI配置失败:', error);
  }
}

// 测试连接
async function testConnection() {
  if (!aiConfig.apiKey) {
    alert('请先配置API Key');
    return;
  }

  try {
    const response = await callRealAI('测试连接');
    alert('连接测试成功');
  } catch (error) {
    alert('连接测试失败：' + error.message);
  }
}

// 处理键盘事件
function handleKeyDown(event) {
  if (event.key === 'Enter' && !event.shiftKey) {
    event.preventDefault();
    sendMessage();
  }
}

// 结构化分点相关函数
function selectAllPoints(messageId) {
  const checkboxes = document.querySelectorAll(`#${messageId} .point-checkbox`);
  const allChecked = Array.from(checkboxes).every(cb => cb.checked);

  checkboxes.forEach(checkbox => {
    checkbox.checked = !allChecked;
  });

  // 更新按钮文本
  const selectAllBtn = document.querySelector(`#${messageId} .select-all-btn`);
  if (selectAllBtn) {
    selectAllBtn.textContent = allChecked ? '全选' : '取消全选';
  }
}

function addSelectedPoints(messageId) {
  console.log('🔍 addSelectedPoints 被调用，messageId:', messageId);

  // 使用更灵活的选择器
  const checkboxes = document.querySelectorAll(`#${messageId} .point-checkbox:checked`);
  console.log('🔍 找到选中的复选框数量:', checkboxes.length);

  if (checkboxes.length === 0) {
    showNotification('请先选择要添加的分点', 'warning');
    return;
  }

  const selectedPoints = [];
  checkboxes.forEach((checkbox, index) => {
    console.log(`🔍 处理第${index + 1}个复选框:`, checkbox);
    console.log(`🔍 复选框HTML:`, checkbox.outerHTML);

    const pointDiv = checkbox.closest('.structured-point');
    if (!pointDiv) {
      console.error('❌ 未找到 .structured-point 容器');
      console.log('🔍 复选框父级元素:', checkbox.parentElement);
      return;
    }

    console.log(`🔍 找到的分点容器:`, pointDiv);
    console.log(`🔍 分点容器HTML:`, pointDiv.outerHTML);

    const titleElement = pointDiv.querySelector('.point-title');
    const contentElement = pointDiv.querySelector('.point-content');
    const keywordElements = pointDiv.querySelectorAll('.keyword');

    console.log(`🔍 标题元素:`, titleElement);
    console.log(`🔍 内容元素:`, contentElement);
    console.log(`🔍 关键词元素:`, keywordElements);

    if (!titleElement) {
      console.error('❌ 未找到 .point-title 元素');
      console.log('🔍 分点容器内的所有元素:', pointDiv.children);
      return;
    }

    const title = titleElement.textContent.trim();
    const content = contentElement ? contentElement.textContent.trim() : '';
    const keywords = Array.from(keywordElements).map(k => k.textContent.trim());

    console.log(`🔍 提取的分点数据:`, {
      title: `"${title}"`,
      content: `"${content}"`,
      keywords: keywords,
      titleLength: title.length,
      contentLength: content.length
    });

    // 验证数据有效性
    if (!title || title.length === 0) {
      console.error('❌ 分点标题为空，跳过此分点');
      return;
    }

    selectedPoints.push({
      title,
      content,
      keywords
    });
  });

  console.log('🔍 最终选中的分点:', selectedPoints);
  console.log('🔍 有效分点数量:', selectedPoints.length);

  if (selectedPoints.length > 0) {
    console.log('🚀 调用 addStructuredPoints，传入数据:', selectedPoints);
    addStructuredPoints(selectedPoints);
  } else {
    console.error('❌ 没有有效的分点数据');
    showNotification('❌ 没有有效的分点数据', 'error');
  }
}

// 通知系统
function showNotification(message, type = 'info') {
  // 创建通知元素
  const notification = document.createElement('div');
  notification.className = `notification notification-${type}`;
  notification.textContent = message;

  // 添加样式
  notification.style.cssText = `
    position: fixed;
    top: 20px;
    right: 20px;
    padding: 12px 20px;
    border-radius: 6px;
    color: white;
    font-size: 14px;
    z-index: 10002;
    max-width: 300px;
    word-wrap: break-word;
    animation: slideInRight 0.3s ease;
  `;

  // 根据类型设置颜色
  switch (type) {
    case 'success':
      notification.style.backgroundColor = '#67c23a';
      break;
    case 'error':
      notification.style.backgroundColor = '#f56c6c';
      break;
    case 'warning':
      notification.style.backgroundColor = '#e6a23c';
      break;
    default:
      notification.style.backgroundColor = '#409eff';
  }

  document.body.appendChild(notification);

  // 3秒后自动移除
  setTimeout(() => {
    if (notification.parentNode) {
      notification.style.animation = 'slideOutRight 0.3s ease';
      setTimeout(() => {
        if (notification.parentNode) {
          notification.parentNode.removeChild(notification);
        }
      }, 300);
    }
  }, 3000);
}

// 页面加载完成后初始化
document.addEventListener('DOMContentLoaded', function() {
  // 延迟初始化，确保Vue应用已加载
  setTimeout(initAIChat, 1000);
});
</script>

<script>const getDataFromBackend = () => {
        return new Promise((resolve, reject) => {
          setTimeout(() => {
            resolve({
              mindMapData: {
                root: {
                  data: {
                    text: '根节点'
                  },
                  children: []
                },
                theme: {
                  template: 'avocado',
                  config: {}
                },
                layout: 'logicalStructure',
                config: {},
                view: null
              },
              mindMapConfig: {},
              lang: 'zh',
              localConfig: null
            })
          }, 200)
        })
      }
      const setTakeOverAppMethods = data => {
        window.takeOverAppMethods = {}
        // 获取思维导图数据的函数
        window.takeOverAppMethods.getMindMapData = () => {
          return data.mindMapData
        }
        // 保存思维导图数据的函数
        window.takeOverAppMethods.saveMindMapData = data => {
          console.log(data)
        }
        // 获取思维导图配置，也就是实例化时会传入的选项
        window.takeOverAppMethods.getMindMapConfig = () => {
          return data.mindMapConfig
        }
        // 保存思维导图配置
        window.takeOverAppMethods.saveMindMapConfig = config => {
          console.log(config)
        }
        // 获取语言的函数
        window.takeOverAppMethods.getLanguage = () => {
          return data.lang
        }
        // 保存语言的函数
        window.takeOverAppMethods.saveLanguage = lang => {
          console.log(lang)
        }
        // 获取本地配置的函数
        window.takeOverAppMethods.getLocalConfig = () => {
          return data.localConfig
        }
        // 保存本地配置的函数
        window.takeOverAppMethods.saveLocalConfig = config => {
          console.log(config)
        }
      }
      window.onload = async () => {
        console.log('🔍 window.onload 被调用，takeOverApp:', window.takeOverApp);

        // 修复：确保思维导图能够初始化
        if (!window.takeOverApp) {
          console.log('⚠️ takeOverApp为false，但仍然尝试初始化思维导图');
          // 不要直接return，而是尝试初始化
        }

        // 请求数据
        const data = await getDataFromBackend()
        console.log('🔍 获取到后端数据:', data);

        // 设置全局的方法
        setTakeOverAppMethods(data)
        console.log('🔍 设置全局方法完成');

        // 思维导图实例创建完成事件
        if (window.$bus && window.$bus.$on) {
          window.$bus.$on('app_inited', mindMap => {
            console.log('🎉 思维导图实例创建完成:', mindMap);
            window.mindMapInstance = mindMap;
          });
        }

        // 可以通过window.$bus.$on()来监听应用的一些事件
        // 实例化页面
        if (window.initApp && typeof window.initApp === 'function') {
          console.log('🚀 调用 initApp');
          window.initApp();
        } else {
          console.log('⚠️ initApp 函数不存在');
        }
      }</script><script src="dist/js/chunk-vendors.js?685589f1058f5fbca0d2"></script><script src="dist/js/app.js?685589f1058f5fbca0d2"></script></body></html>