<!DOCTYPE html><html lang=""><head><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,user-scalable=no,initial-scale=1,maximum-scale=1,minimum-scale=1"><link rel="icon" href="dist/logo.ico"><title>æ€ç»ªæ€ç»´å¯¼å›¾</title><script>// è‡ªå®šä¹‰é™æ€èµ„æºçš„è·¯å¾„
      window.externalPublicPath = './dist/'
      // æ¥ç®¡åº”ç”¨
      window.takeOverApp = false</script><script charset="UTF-8" id="LA_COLLECT" src="//sdk.51.la/js-sdk-pro.min.js"></script><script>try {
        LA.init({
          id: 'KRO0WxK8GT66tYCQ',
          ck: 'KRO0WxK8GT66tYCQ',
          autoTrack: false
        })
      } catch (error) {
        console.log(error)
      }</script><link href="dist/css/chunk-vendors.css?685589f1058f5fbca0d2" rel="stylesheet"><link href="dist/css/app.css?685589f1058f5fbca0d2" rel="stylesheet"></head><body><noscript><strong>We're sorry but thoughts doesn't work properly without JavaScript enabled. Please enable it to continue.</strong></noscript><div id="app"></div>

<!-- AIèŠå¤©æµ®çª— -->
<div id="aiChatBot" class="ai-chat-bot" style="display: none;">
  <div class="chat-header" onclick="toggleMinimize()">
    <div class="header-left">
      <span class="ai-icon">ğŸ¤–</span>
      <span class="title">AIåŠ©æ‰‹</span>
      <span id="contextInfo" class="context-info"></span>
    </div>
    <div class="header-actions">
      <button onclick="syncCurrentActiveNode()" title="åŒæ­¥å½“å‰é€‰ä¸­èŠ‚ç‚¹" style="background: #4CAF50; color: white; border: none; border-radius: 4px; padding: 4px 6px; margin-right: 4px;">ğŸ”„</button>
      <button onclick="clearMessages()" title="æ¸…é™¤è®°å½•">ğŸ—‘ï¸</button>
      <button onclick="showConfig()" title="è®¾ç½®">âš™ï¸</button>
      <button onclick="toggleMinimize()" id="minimizeBtn" title="æœ€å°åŒ–">â¬‡ï¸</button>
    </div>
  </div>

  <div id="chatMessages" class="chat-messages">
    <div class="welcome-message">
      <div class="welcome-content">
        <span class="ai-icon">ğŸ¤–</span>
        <h3>AIæ€ç»´å¯¼å›¾åŠ©æ‰‹</h3>
        <p>ç‚¹å‡»æ€ç»´å¯¼å›¾èŠ‚ç‚¹å¼€å§‹å¯¹è¯</p>
      </div>
    </div>
  </div>

  <div id="chatInput" class="chat-input">
    <div class="input-container">
      <textarea
        id="messageInput"
        class="message-input"
        placeholder="è¯·å…ˆé€‰æ‹©æ€ç»´å¯¼å›¾èŠ‚ç‚¹"
        rows="2"
        onkeydown="handleKeyDown(event)"
      ></textarea>
      <div class="input-actions">
        <button id="sendBtn" class="send-btn" onclick="sendMessage()">å‘é€</button>
      </div>
    </div>
  </div>
</div>

<!-- AIé…ç½®é¢æ¿ -->
<div id="aiConfigPanel" class="ai-config-panel" style="display: none;">
  <div class="config-header">
    <h4>AIé…ç½®</h4>
    <button onclick="closeConfig()">âŒ</button>
  </div>
  <div class="config-content">
    <div class="config-item">
      <label>AIæä¾›å•†:</label>
      <select id="aiProvider">
        <option value="openai">OpenAI</option>
        <option value="deepseek">DeepSeek</option>
        <option value="ollama">Ollama</option>
      </select>
    </div>
    <div class="config-item">
      <label>API Key:</label>
      <input id="apiKey" type="password" placeholder="è¯·è¾“å…¥API Key">
    </div>
    <div class="config-item">
      <label>æ¨¡å‹:</label>
      <input id="aiModel" placeholder="gpt-3.5-turbo">
    </div>
    <div class="config-item">
      <label>åŸºç¡€URL:</label>
      <input id="baseURL" placeholder="https://api.openai.com/v1">
    </div>
    <div class="config-actions">
      <button onclick="saveConfig()">ä¿å­˜é…ç½®</button>
      <button onclick="testConnection()">æµ‹è¯•è¿æ¥</button>
    </div>
  </div>
</div>

<style>
/* AIèŠå¤©æµ®çª—æ ·å¼ */
.ai-chat-bot {
  position: fixed;
  bottom: 20px;
  right: 20px;
  width: 380px;
  max-height: 600px;
  background: #fff;
  border-radius: 12px;
  box-shadow: 0 8px 32px rgba(0, 0, 0, 0.12);
  border: 1px solid #e8e8e8;
  display: flex;
  flex-direction: column;
  z-index: 10000;
  font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
  transition: all 0.3s ease;
}

.ai-chat-bot.minimized {
  max-height: 50px;
}

.ai-chat-bot.minimized .chat-messages,
.ai-chat-bot.minimized .chat-input {
  display: none;
}

.chat-header {
  display: flex;
  align-items: center;
  justify-content: space-between;
  padding: 12px 16px;
  background: #f8f9fa;
  border-bottom: 1px solid #e8e8e8;
  border-radius: 12px 12px 0 0;
  cursor: pointer;
  user-select: none;
}

.header-left {
  display: flex;
  align-items: center;
  flex: 1;
  min-width: 0;
}

.ai-icon {
  font-size: 18px;
  margin-right: 8px;
}

.title {
  font-weight: 600;
  color: #333;
  margin-right: 8px;
}

.context-info {
  font-size: 12px;
  color: #666;
  overflow: hidden;
  text-overflow: ellipsis;
  white-space: nowrap;
}

.header-actions {
  display: flex;
  align-items: center;
  gap: 4px;
}

.header-actions button {
  background: none;
  border: none;
  cursor: pointer;
  padding: 4px;
  border-radius: 4px;
  font-size: 14px;
}

.header-actions button:hover {
  background: rgba(0, 0, 0, 0.1);
}

.chat-messages {
  flex: 1;
  padding: 16px;
  overflow-y: auto;
  max-height: 400px;
  background: #fff;
}

.welcome-message {
  text-align: center;
  padding: 20px;
  color: #666;
}

.welcome-content .ai-icon {
  font-size: 32px;
  margin-bottom: 12px;
  display: block;
}

.welcome-content h3 {
  margin: 0 0 8px 0;
  color: #333;
  font-size: 16px;
}

.welcome-content p {
  margin: 0 0 16px 0;
  font-size: 14px;
}

.quick-actions {
  display: flex;
  flex-wrap: wrap;
  gap: 8px;
  justify-content: center;
}

.quick-actions button {
  padding: 6px 12px;
  background: #409eff;
  color: white;
  border: none;
  border-radius: 16px;
  cursor: pointer;
  font-size: 12px;
}

.quick-actions button:hover {
  background: #337ecc;
}

.message-item {
  display: flex;
  margin-bottom: 16px;
  align-items: flex-start;
}

.message-item.user {
  flex-direction: row-reverse;
}

.message-item.user .message-content {
  background: #409eff;
  color: #fff;
  margin-right: 12px;
  margin-left: 0;
}

.message-item.assistant .message-content {
  background: #f5f5f5;
  color: #333;
  margin-left: 12px;
}

.message-item.system {
  justify-content: center;
}

.message-item.system .message-content {
  background: #e8f4fd;
  color: #409eff;
  font-size: 12px;
  padding: 8px 12px;
  border-radius: 16px;
  margin: 0;
}

.message-avatar {
  width: 32px;
  height: 32px;
  border-radius: 50%;
  background: #fff;
  border: 1px solid #e8e8e8;
  display: flex;
  align-items: center;
  justify-content: center;
  flex-shrink: 0;
  font-size: 16px;
}

.message-content {
  max-width: 280px;
  padding: 12px 16px;
  border-radius: 12px;
  position: relative;
}

.message-text {
  font-size: 14px;
  line-height: 1.5;
  word-wrap: break-word;
  white-space: pre-wrap;
}

.suggestions {
  margin-top: 12px;
  padding-top: 12px;
  border-top: 1px solid rgba(0, 0, 0, 0.1);
}

.suggestions-title {
  font-size: 12px;
  color: #666;
  margin-bottom: 8px;
}

.suggestions-list {
  display: flex;
  flex-wrap: wrap;
  gap: 6px;
}

.suggestion-btn {
  font-size: 12px;
  padding: 4px 8px;
  background: #409eff;
  color: white;
  border: none;
  border-radius: 12px;
  cursor: pointer;
}

.suggestion-btn:hover {
  background: #337ecc;
}

.chat-input {
  border-top: 1px solid #e8e8e8;
  padding: 12px 16px;
  background: #fff;
  border-radius: 0 0 12px 12px;
}

.input-container {
  display: flex;
  flex-direction: column;
  gap: 8px;
}

.message-input {
  width: 100%;
  border: 1px solid #e8e8e8;
  border-radius: 8px;
  padding: 8px 12px;
  font-size: 14px;
  resize: none;
  outline: none;
  font-family: inherit;
}

.message-input:focus {
  border-color: #409eff;
}

.message-input:disabled {
  background: #f5f5f5;
  color: #999;
}

.input-actions {
  display: flex;
  justify-content: flex-end;
}

.send-btn {
  padding: 8px 16px;
  background: #409eff;
  color: white;
  border: none;
  border-radius: 6px;
  cursor: pointer;
  font-size: 14px;
}

.send-btn:hover:not(:disabled) {
  background: #337ecc;
}

.send-btn:disabled {
  background: #ccc;
  cursor: not-allowed;
}

/* AIé…ç½®é¢æ¿æ ·å¼ */
.ai-config-panel {
  position: fixed;
  bottom: 20px;
  right: 420px;
  width: 350px;
  background: white;
  border-radius: 12px;
  box-shadow: 0 8px 32px rgba(0, 0, 0, 0.12);
  border: 1px solid #e8e8e8;
  z-index: 10001;
  font-family: inherit;
}

.config-header {
  display: flex;
  justify-content: space-between;
  align-items: center;
  padding: 16px;
  border-bottom: 1px solid #e8e8e8;
  background: #f8f9fa;
  border-radius: 12px 12px 0 0;
}

.config-header h4 {
  margin: 0;
  color: #333;
}

.config-header button {
  background: none;
  border: none;
  cursor: pointer;
  font-size: 16px;
}

.config-content {
  padding: 16px;
}

.config-item {
  margin-bottom: 16px;
}

.config-item label {
  display: block;
  margin-bottom: 4px;
  font-size: 14px;
  color: #333;
}

.config-item input,
.config-item select {
  width: 100%;
  padding: 8px 12px;
  border: 1px solid #e8e8e8;
  border-radius: 6px;
  font-size: 14px;
}

.config-actions {
  display: flex;
  gap: 8px;
  margin-top: 20px;
}

.config-actions button {
  flex: 1;
  padding: 10px;
  border: none;
  border-radius: 6px;
  cursor: pointer;
  font-size: 14px;
}

.config-actions button:first-child {
  background: #409eff;
  color: white;
}

.config-actions button:last-child {
  background: #f5f5f5;
  color: #333;
}

.loading {
  animation: pulse 1.5s ease-in-out infinite;
}

/* ç»“æ„åŒ–åˆ†ç‚¹æ ·å¼ */
.structured-points {
  margin-top: 12px;
  padding-top: 12px;
  border-top: 1px solid rgba(0, 0, 0, 0.1);
}

.points-header {
  display: flex;
  justify-content: space-between;
  align-items: center;
  margin-bottom: 12px;
}

.points-title {
  font-size: 12px;
  color: #666;
  font-weight: 600;
}

.points-actions {
  display: flex;
  gap: 6px;
}

.select-all-btn,
.add-selected-btn {
  font-size: 11px;
  padding: 3px 8px;
  border: 1px solid #409eff;
  background: white;
  color: #409eff;
  border-radius: 10px;
  cursor: pointer;
}

.select-all-btn:hover,
.add-selected-btn:hover {
  background: #409eff;
  color: white;
}

.add-selected-btn {
  background: #409eff;
  color: white;
}

.add-selected-btn:hover {
  background: #337ecc;
}

.points-list {
  display: flex;
  flex-direction: column;
  gap: 8px;
}

.structured-point {
  border: 1px solid #e8e8e8;
  border-radius: 6px;
  padding: 8px;
  background: #fafafa;
}

.point-header {
  display: flex;
  align-items: center;
  gap: 6px;
  margin-bottom: 4px;
}

.point-checkbox {
  margin: 0;
  cursor: pointer;
}

.point-title {
  font-size: 13px;
  font-weight: 600;
  color: #333;
  cursor: pointer;
  margin: 0;
}

.point-content {
  font-size: 12px;
  color: #666;
  line-height: 1.4;
  margin-bottom: 6px;
  padding-left: 20px;
}

.point-keywords {
  display: flex;
  flex-wrap: wrap;
  gap: 4px;
  padding-left: 20px;
}

.keyword {
  font-size: 10px;
  padding: 2px 6px;
  background: #e8f4fd;
  color: #409eff;
  border-radius: 8px;
  border: 1px solid #b3d8ff;
}

/* é€‰ä¸­èŠ‚ç‚¹æ˜¾ç¤ºæ ·å¼ */
.selected-node-display {
  padding: 12px 16px;
  background: linear-gradient(135deg, #e8f4fd 0%, #f0f8ff 100%);
  border-bottom: 1px solid #b3d8ff;
  display: none;
}

.selected-node-content {
  display: flex;
  flex-direction: column;
  gap: 6px;
}

.node-indicator {
  display: flex;
  align-items: center;
  gap: 6px;
}

.indicator-dot {
  width: 8px;
  height: 8px;
  background: #409eff;
  border-radius: 50%;
  animation: pulse-dot 2s infinite;
}

.indicator-text {
  font-size: 11px;
  color: #409eff;
  font-weight: 600;
  text-transform: uppercase;
  letter-spacing: 0.5px;
}

.node-text {
  font-size: 14px;
  font-weight: 600;
  color: #2c5aa0;
  margin: 2px 0;
}

.node-path {
  display: flex;
  align-items: center;
  gap: 6px;
  font-size: 11px;
}

.path-label {
  color: #666;
  font-weight: 500;
}

.path-text {
  color: #409eff;
  background: rgba(64, 158, 255, 0.1);
  padding: 2px 8px;
  border-radius: 10px;
  border: 1px solid rgba(64, 158, 255, 0.2);
  font-family: monospace;
}

@keyframes pulse-dot {
  0%, 100% {
    opacity: 1;
    transform: scale(1);
  }
  50% {
    opacity: 0.6;
    transform: scale(1.2);
  }
}

/* é€šçŸ¥åŠ¨ç”» */
@keyframes slideInRight {
  from {
    transform: translateX(100%);
    opacity: 0;
  }
  to {
    transform: translateX(0);
    opacity: 1;
  }
}

@keyframes slideOutRight {
  from {
    transform: translateX(0);
    opacity: 1;
  }
  to {
    transform: translateX(100%);
    opacity: 0;
  }
}

@keyframes pulse {
  0%, 100% { opacity: 1; }
  50% { opacity: 0.5; }
}

/* æ€è€ƒçŠ¶æ€åŠ¨ç”» - è·³åŠ¨çš„ç‚¹ */
@keyframes thinking-dots {
  0%, 20% {
    opacity: 0.3;
    transform: scale(1);
  }
  50% {
    opacity: 1;
    transform: scale(1.2);
  }
  100% {
    opacity: 0.3;
    transform: scale(1);
  }
}

.thinking-dots {
  display: inline-block;
}

.thinking-dots .dot {
  display: inline-block;
  width: 4px;
  height: 4px;
  border-radius: 50%;
  background-color: #666;
  margin: 0 1px;
  animation: thinking-dots 1.4s infinite ease-in-out;
}

.thinking-dots .dot:nth-child(1) { animation-delay: 0s; }
.thinking-dots .dot:nth-child(2) { animation-delay: 0.2s; }
.thinking-dots .dot:nth-child(3) { animation-delay: 0.4s; }

/* æ‰“å­—æœºæ•ˆæœ */
.typewriter-text {
  overflow: hidden;
  border-right: 2px solid #409eff;
  white-space: nowrap;
  animation: typing 0.5s steps(1, end), blink-caret 1s step-end infinite;
}

@keyframes typing {
  from { width: 0; }
  to { width: 100%; }
}

@keyframes blink-caret {
  from, to { border-color: transparent; }
  50% { border-color: #409eff; }
}

/* æ¨ç†æ¨¡å‹æ ·å¼ */
.reasoning-content {
  background: #f8f9fa;
  border-left: 3px solid #888;
  padding: 12px;
  margin: 8px 0;
  border-radius: 0 8px 8px 0;
  font-style: italic;
  color: #666;
  font-size: 13px;
  line-height: 1.4;
}

.reasoning-content::before {
  content: "ğŸ¤” æ€è€ƒè¿‡ç¨‹ï¼š";
  font-weight: 600;
  color: #888;
  display: block;
  margin-bottom: 6px;
  font-style: normal;
}

.final-answer {
  margin-top: 8px;
  padding-top: 8px;
  border-top: 1px solid #e8e8e8;
}

.final-answer::before {
  content: "âœ… æœ€ç»ˆå›ç­”ï¼š";
  font-weight: 600;
  color: #409eff;
  display: block;
  margin-bottom: 6px;
}
</style>

<script>
// AIèŠå¤©åŠŸèƒ½JavaScriptä»£ç 
let selectedNodeText = '';
let selectedNodeHierarchy = [];
let messages = [];
let isLoading = false;
let isMinimized = false;
let mindMapInstance = null;
let aiConfig = {
  provider: 'openai',
  apiKey: '',
  model: 'gpt-3.5-turbo',
  baseURL: 'https://api.openai.com/v1'
};

// åˆå§‹åŒ–AIèŠå¤©åŠŸèƒ½
function initAIChat() {
  // æ˜¾ç¤ºAIèŠå¤©æµ®çª—
  document.getElementById('aiChatBot').style.display = 'flex';

  // è®¾ç½®è°ƒè¯•æ¨¡å¼ï¼ˆå¯ä»¥é€šè¿‡URLå‚æ•°æˆ–localStorageæ§åˆ¶ï¼‰
  const urlParams = new URLSearchParams(window.location.search);
  window.debugMode = urlParams.get('debug') === 'true' || localStorage.getItem('ai_debug_mode') === 'true';

  if (window.debugMode) {
    console.log('ğŸ› AIè°ƒè¯•æ¨¡å¼å·²å¯ç”¨');
    console.log('ğŸ’¡ æç¤ºï¼šåœ¨æµè§ˆå™¨åœ°å€æ æ·»åŠ  ?debug=false å¯å…³é—­è°ƒè¯•æ¨¡å¼');
    console.log('ğŸ’¡ æˆ–è€…åœ¨æ§åˆ¶å°è¾“å…¥ toggleDebugMode() æ¥åˆ‡æ¢è°ƒè¯•æ¨¡å¼');
  }

  // æä¾›å…¨å±€å‡½æ•°æ¥åˆ‡æ¢è°ƒè¯•æ¨¡å¼
  window.toggleDebugMode = function(enable) {
    if (typeof enable === 'boolean') {
      window.debugMode = enable;
    } else {
      window.debugMode = !window.debugMode;
    }

    localStorage.setItem('ai_debug_mode', window.debugMode.toString());

    if (window.debugMode) {
      console.log('ğŸ› AIè°ƒè¯•æ¨¡å¼å·²å¯ç”¨');
    } else {
      console.log('ğŸ”‡ AIè°ƒè¯•æ¨¡å¼å·²å…³é—­');
    }
  };

  // åŠ è½½AIé…ç½®
  loadAIConfig();

  // ç›‘å¬æ€ç»´å¯¼å›¾äº‹ä»¶
  if (window.$bus) {
    window.$bus.$on('app_inited', (mindMap) => {
      console.log('æ€ç»´å¯¼å›¾åˆå§‹åŒ–å®Œæˆ:', mindMap);
      mindMapInstance = mindMap;
      window.mindMapInstance = mindMapInstance; // ç¡®ä¿è®¾ç½®åˆ°å…¨å±€
      bindMindMapEvents(mindMap);
    });
  }

  // å¢å¼ºçš„æ€ç»´å¯¼å›¾å®ä¾‹æ£€æµ‹
  const checkMindMapInstance = () => {
    // æ–¹æ³•1: æ£€æŸ¥å…¨å±€å˜é‡
    if (window.mindMap && !mindMapInstance) {
      console.log('ä»å…¨å±€è·å–æ€ç»´å¯¼å›¾å®ä¾‹:', window.mindMap);
      mindMapInstance = window.mindMap;
      window.mindMapInstance = mindMapInstance; // ç¡®ä¿è®¾ç½®åˆ°å…¨å±€
      bindMindMapEvents(mindMapInstance);
      return true;
    }

    if (window.app && window.app.mindMap && !mindMapInstance) {
      console.log('ä»appè·å–æ€ç»´å¯¼å›¾å®ä¾‹:', window.app.mindMap);
      mindMapInstance = window.app.mindMap;
      window.mindMapInstance = mindMapInstance; // ç¡®ä¿è®¾ç½®åˆ°å…¨å±€
      bindMindMapEvents(mindMapInstance);
      return true;
    }

    // æ–¹æ³•2: ä»Vueå®ä¾‹è·å–
    const mindMapContainer = document.querySelector('#app');
    if (mindMapContainer && mindMapContainer.__vue__) {
      const vueInstance = mindMapContainer.__vue__;

      // æ£€æŸ¥Vueå®ä¾‹çš„å­ç»„ä»¶
      if (vueInstance.$children && vueInstance.$children.length > 0) {
        for (let child of vueInstance.$children) {
          if (child.mindMap && !mindMapInstance) {
            console.log('ä»Vueå­ç»„ä»¶è·å–æ€ç»´å¯¼å›¾å®ä¾‹:', child.mindMap);
            mindMapInstance = child.mindMap;
            window.mindMapInstance = mindMapInstance; // ç¡®ä¿è®¾ç½®åˆ°å…¨å±€
            bindMindMapEvents(mindMapInstance);
            return true;
          }

          // æ·±åº¦æ£€æŸ¥å­ç»„ä»¶çš„å­ç»„ä»¶
          if (child.$children && child.$children.length > 0) {
            for (let grandChild of child.$children) {
              if (grandChild.mindMap && !mindMapInstance) {
                console.log('ä»Vueå­™ç»„ä»¶è·å–æ€ç»´å¯¼å›¾å®ä¾‹:', grandChild.mindMap);
                mindMapInstance = grandChild.mindMap;
                window.mindMapInstance = mindMapInstance; // ç¡®ä¿è®¾ç½®åˆ°å…¨å±€
                bindMindMapEvents(mindMapInstance);
                return true;
              }
            }
          }
        }
      }
    }

    // æ–¹æ³•3: é€šè¿‡DOMäº‹ä»¶ç›‘å¬è·å–
    if (!mindMapInstance) {
      setupDOMEventListeners();
    }

    return false;
  };

  // è®¾ç½®DOMäº‹ä»¶ç›‘å¬å™¨æ¥æ•è·æ€ç»´å¯¼å›¾äº¤äº’
  const setupDOMEventListeners = () => {
    const svgElements = document.querySelectorAll('svg');
    svgElements.forEach(svg => {
      // ç›‘å¬SVGç‚¹å‡»äº‹ä»¶
      svg.addEventListener('click', (e) => {
        // å°è¯•ä»äº‹ä»¶ä¸­è·å–æ€ç»´å¯¼å›¾å®ä¾‹
        setTimeout(() => {
          tryGetMindMapFromDOM();
        }, 100);
      });
    });
  };

  // ä»DOMçŠ¶æ€å°è¯•è·å–æ€ç»´å¯¼å›¾å®ä¾‹
  const tryGetMindMapFromDOM = () => {
    if (mindMapInstance) return;

    const mindMapContainer = document.querySelector('#app');
    if (mindMapContainer && mindMapContainer.__vue__) {
      const vueInstance = mindMapContainer.__vue__;

      // é€’å½’æœç´¢æ‰€æœ‰Vueç»„ä»¶å®ä¾‹
      const findMindMapInVueTree = (component) => {
        if (component.mindMap) {
          return component.mindMap;
        }

        if (component.$children) {
          for (let child of component.$children) {
            const result = findMindMapInVueTree(child);
            if (result) return result;
          }
        }

        return null;
      };

      const foundMindMap = findMindMapInVueTree(vueInstance);
      if (foundMindMap) {
        console.log('é€šè¿‡é€’å½’æœç´¢æ‰¾åˆ°æ€ç»´å¯¼å›¾å®ä¾‹:', foundMindMap);
        mindMapInstance = foundMindMap;
        window.mindMapInstance = mindMapInstance; // ç¡®ä¿è®¾ç½®åˆ°å…¨å±€
        bindMindMapEvents(mindMapInstance);

        // ç«‹å³å°è¯•åŒæ­¥å½“å‰æ¿€æ´»èŠ‚ç‚¹
        setTimeout(() => {
          syncCurrentActiveNode();
        }, 500);
      }
    }
  };

  // å®šæœŸæ£€æŸ¥æ€ç»´å¯¼å›¾å®ä¾‹
  const checkInterval = setInterval(() => {
    if (checkMindMapInstance()) {
      clearInterval(checkInterval);
    }
  }, 1000);

  // 10ç§’ååœæ­¢æ£€æŸ¥
  setTimeout(() => {
    clearInterval(checkInterval);
    // å¦‚æœè¿˜æ²¡æ‰¾åˆ°ï¼Œå°è¯•æœ€åä¸€æ¬¡DOMæœç´¢
    if (!mindMapInstance) {
      console.log('æœ€åå°è¯•ä»DOMè·å–æ€ç»´å¯¼å›¾å®ä¾‹...');
      tryGetMindMapFromDOM();
    }
  }, 10000);
}

// ç»‘å®šæ€ç»´å¯¼å›¾äº‹ä»¶
function bindMindMapEvents(mindMap) {
  console.log('ç»‘å®šæ€ç»´å¯¼å›¾äº‹ä»¶', mindMap);

  // ç›‘å¬èŠ‚ç‚¹ç‚¹å‡»äº‹ä»¶
  mindMap.on('node_click', (node) => {
    console.log('èŠ‚ç‚¹è¢«ç‚¹å‡»:', node);
    updateSelectedNode(node);
  });

  // ç›‘å¬èŠ‚ç‚¹æ¿€æ´»äº‹ä»¶
  mindMap.on('node_active', (node, activeNodeList) => {
    console.log('èŠ‚ç‚¹æ¿€æ´»:', node, activeNodeList);
    if (activeNodeList && activeNodeList.length > 0) {
      updateSelectedNode(activeNodeList[0]);
    } else {
      selectedNodeText = '';
      selectedNodeHierarchy = [];
      updateContextInfo();
    }
  });

  // ç›‘å¬æ•°æ®å˜åŒ–äº‹ä»¶
  mindMap.on('data_change', (data) => {
    console.log('æ€ç»´å¯¼å›¾æ•°æ®å˜åŒ–:', data);
  });

  // æ·»åŠ å®šæ—¶æ£€æŸ¥æ¿€æ´»èŠ‚ç‚¹çš„æœºåˆ¶
  const checkActiveNodes = () => {
    try {
      if (mindMap.renderer && mindMap.renderer.activeNodeList) {
        const activeNodes = mindMap.renderer.activeNodeList;
        if (activeNodes.length > 0) {
          const currentActiveNode = activeNodes[0];
          let currentRawText = currentActiveNode.nodeData ?
            currentActiveNode.nodeData.data.text :
            (currentActiveNode.getData ? currentActiveNode.getData('text') : '');

          // æ¸…ç†HTMLæ ‡ç­¾ï¼Œè·å–çº¯æ–‡æœ¬ç”¨äºæ¯”è¾ƒ
          let currentCleanText = '';
          if (typeof currentRawText === 'string') {
            const tempDiv = document.createElement('div');
            tempDiv.innerHTML = currentRawText;
            currentCleanText = tempDiv.textContent || tempDiv.innerText || currentRawText;
          } else {
            currentCleanText = currentRawText || '';
          }

          // å¦‚æœå½“å‰æ¿€æ´»èŠ‚ç‚¹ä¸è®°å½•çš„ä¸åŒï¼Œæ›´æ–°é€‰ä¸­èŠ‚ç‚¹
          if (currentCleanText && currentCleanText !== selectedNodeText) {
            // åªåœ¨è°ƒè¯•æ¨¡å¼ä¸‹è¾“å‡ºè¯¦ç»†ä¿¡æ¯
            if (window.debugMode) {
              console.log('æ£€æµ‹åˆ°æ–°çš„æ¿€æ´»èŠ‚ç‚¹:', currentRawText, '-> æ¸…ç†å:', currentCleanText);
            }
            updateSelectedNode(currentActiveNode);
          }
        }
      }
    } catch (error) {
      console.error('æ£€æŸ¥æ¿€æ´»èŠ‚ç‚¹å¤±è´¥:', error);
    }
  };

  // æ¯ç§’æ£€æŸ¥ä¸€æ¬¡æ¿€æ´»èŠ‚ç‚¹
  setInterval(checkActiveNodes, 1000);
}

// æ›´æ–°é€‰ä¸­èŠ‚ç‚¹
function updateSelectedNode(node) {
  if (!node) {
    selectedNodeText = '';
    selectedNodeHierarchy = [];
    updateContextInfo();
    return;
  }

  try {
    // æ­£ç¡®è·å–èŠ‚ç‚¹æ–‡æœ¬ - å‚è€ƒai-mind-mapçš„å®ç°
    let rawText = node.nodeData ? node.nodeData.data.text : (node.getData ? node.getData('text') : '');

    // æ¸…ç†HTMLæ ‡ç­¾ï¼Œåªä¿ç•™çº¯æ–‡æœ¬
    if (typeof rawText === 'string') {
      // åˆ›å»ºä¸´æ—¶DOMå…ƒç´ æ¥è§£æHTML
      const tempDiv = document.createElement('div');
      tempDiv.innerHTML = rawText;
      selectedNodeText = tempDiv.textContent || tempDiv.innerText || rawText;
    } else {
      selectedNodeText = rawText || '';
    }

    selectedNodeHierarchy = getNodeHierarchy(node);
    updateContextInfo();
    showQuickActions();

    // åªåœ¨è°ƒè¯•æ¨¡å¼ä¸‹è¾“å‡ºè¯¦ç»†ä¿¡æ¯
    if (window.debugMode) {
      console.log('èŠ‚ç‚¹é€‰æ‹©æˆåŠŸ:', {
        text: selectedNodeText,
        hierarchy: selectedNodeHierarchy,
        node: node,
        nodeData: node.nodeData
      });
    }
  } catch (error) {
    console.error('è·å–èŠ‚ç‚¹ä¿¡æ¯å¤±è´¥:', error);
    selectedNodeText = '';
    selectedNodeHierarchy = [];
    updateContextInfo();
  }
}

// è·å–èŠ‚ç‚¹å±‚çº§è·¯å¾„
function getNodeHierarchy(node) {
  const hierarchy = [];
  let currentNode = node;

  while (currentNode) {
    try {
      // æ­£ç¡®è·å–èŠ‚ç‚¹æ–‡æœ¬ - å…¼å®¹ä¸åŒçš„èŠ‚ç‚¹æ•°æ®ç»“æ„
      let rawText = '';
      if (currentNode.nodeData && currentNode.nodeData.data) {
        rawText = currentNode.nodeData.data.text || '';
      } else if (currentNode.getData) {
        rawText = currentNode.getData('text') || '';
      }

      // æ¸…ç†HTMLæ ‡ç­¾ï¼Œåªä¿ç•™çº¯æ–‡æœ¬
      let text = '';
      if (typeof rawText === 'string') {
        const tempDiv = document.createElement('div');
        tempDiv.innerHTML = rawText;
        text = tempDiv.textContent || tempDiv.innerText || rawText;
      } else {
        text = rawText || '';
      }

      if (text) {
        hierarchy.unshift(text);
      }
      currentNode = currentNode.parent;
    } catch (error) {
      console.error('è·å–çˆ¶èŠ‚ç‚¹å¤±è´¥:', error);
      break;
    }
  }

  return hierarchy;
}

// è·å–èŠ‚ç‚¹é“¾è·¯çš„è¯¦ç»†ä¿¡æ¯ï¼ˆåŒ…æ‹¬å¤‡æ³¨ï¼‰
function getNodeHierarchyWithNotes(node) {
  const hierarchyWithNotes = [];
  let currentNode = node;

  while (currentNode) {
    try {
      // è·å–èŠ‚ç‚¹æ–‡æœ¬
      let rawText = '';
      if (currentNode.nodeData && currentNode.nodeData.data) {
        rawText = currentNode.nodeData.data.text || '';
      } else if (currentNode.getData) {
        rawText = currentNode.getData('text') || '';
      }

      // æ¸…ç†HTMLæ ‡ç­¾ï¼Œåªä¿ç•™çº¯æ–‡æœ¬
      let text = '';
      if (typeof rawText === 'string') {
        const tempDiv = document.createElement('div');
        tempDiv.innerHTML = rawText;
        text = tempDiv.textContent || tempDiv.innerText || rawText;
      } else {
        text = rawText || '';
      }

      // è·å–èŠ‚ç‚¹å¤‡æ³¨
      let note = '';
      if (currentNode.nodeData && currentNode.nodeData.data) {
        note = currentNode.nodeData.data.note || '';
      } else if (currentNode.getData) {
        note = currentNode.getData('note') || '';
      }

      if (text) {
        hierarchyWithNotes.unshift({
          text: text,
          note: note
        });
      }
      currentNode = currentNode.parent;
    } catch (error) {
      console.error('è·å–çˆ¶èŠ‚ç‚¹è¯¦ç»†ä¿¡æ¯å¤±è´¥:', error);
      break;
    }
  }

  return hierarchyWithNotes;
}

// æ›´æ–°ä¸Šä¸‹æ–‡ä¿¡æ¯
function updateContextInfo() {
  const contextInfo = document.getElementById('contextInfo');
  const messageInput = document.getElementById('messageInput');

  if (selectedNodeText) {
    const hierarchyText = selectedNodeHierarchy.length > 1
      ? selectedNodeHierarchy.join(' â€º ')
      : selectedNodeText;
    contextInfo.textContent = `- ${selectedNodeText}`;
    contextInfo.title = `è·¯å¾„: ${hierarchyText}`;
    messageInput.placeholder = `è¯¢é—®å…³äº"${selectedNodeText}"çš„é—®é¢˜...`;

    // æ›´æ–°èŠå¤©çª—å£ä¸­çš„é€‰ä¸­èŠ‚ç‚¹æ˜¾ç¤º
    updateSelectedNodeDisplay();
  } else {
    contextInfo.textContent = '';
    contextInfo.title = '';
    messageInput.placeholder = 'è¯·å…ˆé€‰æ‹©æ€ç»´å¯¼å›¾èŠ‚ç‚¹';
    hideSelectedNodeDisplay();
  }
}

// æ›´æ–°é€‰ä¸­èŠ‚ç‚¹æ˜¾ç¤ºåŒºåŸŸ
function updateSelectedNodeDisplay() {
  let nodeDisplay = document.getElementById('selectedNodeDisplay');

  if (!nodeDisplay) {
    // åˆ›å»ºé€‰ä¸­èŠ‚ç‚¹æ˜¾ç¤ºåŒºåŸŸ
    nodeDisplay = document.createElement('div');
    nodeDisplay.id = 'selectedNodeDisplay';
    nodeDisplay.className = 'selected-node-display';

    const chatMessages = document.getElementById('chatMessages');
    if (chatMessages && chatMessages.parentNode) {
      chatMessages.parentNode.insertBefore(nodeDisplay, chatMessages);
    } else {
      // å¦‚æœæ‰¾ä¸åˆ°chatMessagesï¼Œå°è¯•æ’å…¥åˆ°èŠå¤©çª—å£ä¸­
      const chatWindow = document.getElementById('aiChatWindow');
      if (chatWindow) {
        const header = chatWindow.querySelector('.chat-header');
        if (header && header.nextSibling) {
          chatWindow.insertBefore(nodeDisplay, header.nextSibling);
        } else {
          chatWindow.appendChild(nodeDisplay);
        }
      }
    }
  }

  if (selectedNodeText && selectedNodeHierarchy.length > 0) {
    nodeDisplay.innerHTML = `
      <div class="selected-node-content">
        <div class="node-indicator">
          <div class="indicator-dot"></div>
          <span class="indicator-text">å½“å‰é€‰ä¸­èŠ‚ç‚¹</span>
        </div>
        <div class="node-text">${selectedNodeText}</div>
        <div class="node-path">
          <span class="path-label">è·¯å¾„:</span>
          <span class="path-text">${selectedNodeHierarchy.join(' â€º ')}</span>
        </div>
      </div>
    `;

    nodeDisplay.style.display = 'block';
    // åªåœ¨è°ƒè¯•æ¨¡å¼ä¸‹è¾“å‡º
    if (window.debugMode) {
      console.log('é€‰ä¸­èŠ‚ç‚¹æ˜¾ç¤ºåŒºåŸŸå·²æ›´æ–°:', selectedNodeText, selectedNodeHierarchy);
    }
  } else {
    nodeDisplay.style.display = 'none';
  }
}

// éšè—é€‰ä¸­èŠ‚ç‚¹æ˜¾ç¤º
function hideSelectedNodeDisplay() {
  const nodeDisplay = document.getElementById('selectedNodeDisplay');
  if (nodeDisplay) {
    nodeDisplay.style.display = 'none';
  }
}

// æ˜¾ç¤ºå¿«é€Ÿæ“ä½œ
function showQuickActions() {
  if (!selectedNodeText) return;

  const welcomeMessage = document.querySelector('.welcome-message');
  if (welcomeMessage && messages.length === 0) {
    welcomeMessage.innerHTML = `
      <div class="welcome-content">
        <span class="ai-icon">ğŸ¤–</span>
        <h3>AIæ€ç»´å¯¼å›¾åŠ©æ‰‹</h3>
        <p>å½“å‰é€‰ä¸­ï¼š${selectedNodeText}</p>
        <div class="quick-actions">
          <button onclick="sendQuickMessage('æ‰©å±•è¿™ä¸ªèŠ‚ç‚¹')">æ‰©å±•èŠ‚ç‚¹</button>
          <button onclick="sendQuickMessage('è§£é‡Šè¿™ä¸ªæ¦‚å¿µ')">è§£é‡Šæ¦‚å¿µ</button>
          <button onclick="sendQuickMessage('ç›¸å…³åº”ç”¨åœºæ™¯')">åº”ç”¨åœºæ™¯</button>
        </div>
      </div>
    `;
  }
}

// å‘é€å¿«é€Ÿæ¶ˆæ¯
function sendQuickMessage(message) {
  document.getElementById('messageInput').value = message;
  sendMessage();
}

// å‘é€æ¶ˆæ¯
async function sendMessage() {
  const input = document.getElementById('messageInput');
  const message = input.value.trim();

  if (!message || isLoading) return;

  input.value = '';

  // æ·»åŠ ç”¨æˆ·æ¶ˆæ¯
  addMessage('user', message);

  // è®¾ç½®åŠ è½½çŠ¶æ€
  setLoading(true);

  try {
    // è°ƒç”¨AI APIæˆ–æ¨¡æ‹Ÿå›å¤
    const response = await callAI(message);

    // å¦‚æœæ˜¯æ¨¡æ‹Ÿå›å¤æˆ–éæµå¼å“åº”ï¼Œä½¿ç”¨ä¼ ç»Ÿæ–¹å¼æ·»åŠ æ¶ˆæ¯
    if (response && response.content) {
      addMessage('assistant', response.content, response.suggestions, response.structuredPoints);
    }
    // æµå¼å“åº”çš„æ¶ˆæ¯å·²ç»åœ¨callRealAIä¸­å¤„ç†äº†
  } catch (error) {
    console.error('AIå›å¤å¤±è´¥:', error);
    addMessage('assistant', 'æŠ±æ­‰ï¼Œæˆ‘ç°åœ¨æ— æ³•å›å¤ã€‚è¯·æ£€æŸ¥AIé…ç½®æˆ–ç¨åå†è¯•ã€‚');
  } finally {
    setLoading(false);
  }
}

// è°ƒç”¨AI API
async function callAI(message) {
  // å¦‚æœé…ç½®äº†çœŸå®çš„API Keyï¼Œè°ƒç”¨çœŸå®API
  if (aiConfig.apiKey && aiConfig.apiKey.trim()) {
    return await callRealAI(message);
  } else {
    // å¦åˆ™ä½¿ç”¨æ¨¡æ‹Ÿå›å¤
    return await simulateAIResponse(message);
  }
}

// è°ƒç”¨çœŸå®AI API
async function callRealAI(message) {
  const { provider, apiKey, model, baseURL } = aiConfig;

  // æ„å»ºç³»ç»Ÿæç¤ºè¯
  const systemPrompt = getSystemPrompt();

  const messages = [
    {
      role: 'system',
      content: systemPrompt
    },
    {
      role: 'user',
      content: message
    }
  ];

  // æ‰“å°è¯·æ±‚çš„promptåˆ°æ§åˆ¶å°
  console.log('=== LLM API è¯·æ±‚ ===');
  console.log('ğŸ”§ é…ç½®ä¿¡æ¯:', { provider, model, baseURL: baseURL.replace(/\/+$/, '') });
  console.log('ğŸ“ å®Œæ•´è¯·æ±‚æ¶ˆæ¯:', JSON.stringify(messages, null, 2));
  console.log('ğŸ’¬ ç”¨æˆ·æ¶ˆæ¯:', message);
  console.log('ğŸ¤– ç³»ç»Ÿæç¤ºè¯:', systemPrompt);

  // æ‰“å°èŠ‚ç‚¹é“¾è·¯çš„è¯¦ç»†ä¿¡æ¯
  if (mindMapInstance && mindMapInstance.renderer && mindMapInstance.renderer.activeNodeList && mindMapInstance.renderer.activeNodeList.length > 0) {
    const currentActiveNode = mindMapInstance.renderer.activeNodeList[0];
    const hierarchyWithNotes = getNodeHierarchyWithNotes(currentActiveNode);

    if (hierarchyWithNotes.length > 0) {
      console.log('ğŸ”— èŠ‚ç‚¹é“¾è·¯è¯¦ç»†ä¿¡æ¯:');
      hierarchyWithNotes.forEach((nodeInfo, index) => {
        console.log(`  ${index + 1}. èŠ‚ç‚¹: "${nodeInfo.text}"`);
        if (nodeInfo.note && nodeInfo.note.trim()) {
          console.log(`     å¤‡æ³¨: ${nodeInfo.note.trim()}`);
        }
      });
    }
  }

  console.log('==================');

  const requestBody = {
    model,
    messages,
    max_tokens: 2000,
    temperature: 0.7,
    stream: true
  };

  const response = await fetch(`${baseURL}/chat/completions`, {
    method: 'POST',
    headers: {
      'Content-Type': 'application/json',
      'Authorization': `Bearer ${apiKey}`
    },
    body: JSON.stringify(requestBody)
  });

  if (!response.ok) {
    console.error('âŒ APIè¯·æ±‚å¤±è´¥:', response.status, response.statusText);
    throw new Error(`APIè¯·æ±‚å¤±è´¥: ${response.status} ${response.statusText}`);
  }

  // å¤„ç†æµå¼å“åº”
  const reader = response.body.getReader();
  const decoder = new TextDecoder();
  let rawContent = '';
  let reasoning = '';
  let finalAnswer = '';
  let isReasoningModel = false;
  let buffer = '';

  // ç§»é™¤åŠ è½½æ¶ˆæ¯ï¼Œå‡†å¤‡æ˜¾ç¤ºæµå¼å†…å®¹
  const loadingMessage = document.getElementById('loadingMessage');
  if (loadingMessage) {
    loadingMessage.remove();
  }

  // åˆ›å»ºæµå¼æ¶ˆæ¯å®¹å™¨
  const messageId = 'msg_' + Date.now() + '_' + Math.random().toString(36).substr(2, 5);
  const streamingDiv = document.createElement('div');
  streamingDiv.className = 'message-item assistant';
  streamingDiv.id = messageId;
  streamingDiv.innerHTML = `
    <div class="message-avatar">ğŸ¤–</div>
    <div class="message-content">
      <div id="${messageId}_reasoning" class="reasoning-content" style="display: none;"></div>
      <div id="${messageId}_content" class="message-text"></div>
    </div>
  `;

  const messagesContainer = document.getElementById('chatMessages');
  messagesContainer.appendChild(streamingDiv);
  messagesContainer.scrollTop = messagesContainer.scrollHeight;

  const reasoningElement = document.getElementById(`${messageId}_reasoning`);
  const contentElement = document.getElementById(`${messageId}_content`);

  try {
    while (true) {
      const { done, value } = await reader.read();
      if (done) break;

      buffer += decoder.decode(value, { stream: true });
      const lines = buffer.split('\n');
      buffer = lines.pop(); // ä¿ç•™æœ€åä¸€è¡Œï¼ˆå¯èƒ½ä¸å®Œæ•´ï¼‰

      for (const line of lines) {
        if (line.startsWith('data: ')) {
          const data = line.slice(6);
          if (data === '[DONE]') continue;

          try {
            const parsed = JSON.parse(data);
            const delta = parsed.choices?.[0]?.delta;

            if (!delta) continue;

            // æ£€æµ‹æ˜¯å¦ä¸ºæ¨ç†æ¨¡å‹
            if (delta.reasoning_content !== undefined) {
              isReasoningModel = true;
              if (delta.reasoning_content) {
                reasoning += delta.reasoning_content;
                reasoningElement.textContent = reasoning;
                reasoningElement.style.display = 'block';
              }
            }

            if (delta.content) {
              rawContent += delta.content;
              finalAnswer += delta.content;

              // å®ç°æ‰“å­—æœºæ•ˆæœ
              await typewriterEffect(contentElement, delta.content);
            }

            // è‡ªåŠ¨æ»šåŠ¨åˆ°åº•éƒ¨
            messagesContainer.scrollTop = messagesContainer.scrollHeight;
          } catch (e) {
            console.warn('è§£ææµå¼æ•°æ®å¤±è´¥:', e, data);
          }
        }
      }
    }
  } catch (error) {
    console.error('æµå¼å¤„ç†å¤±è´¥:', error);
    contentElement.textContent = 'æŠ±æ­‰ï¼Œå¤„ç†å“åº”æ—¶å‡ºç°é”™è¯¯ã€‚';
  }

  // å¦‚æœæ˜¯æ¨ç†æ¨¡å‹ä½†æ²¡æœ‰æ£€æµ‹åˆ°reasoning_contentï¼Œå°è¯•ä»å†…å®¹ä¸­æå–
  if (!isReasoningModel && rawContent) {
    const reasoningResult = extractReasoningFromContent(rawContent);
    if (reasoningResult.isReasoningModel) {
      isReasoningModel = true;
      reasoning = reasoningResult.reasoning;
      finalAnswer = reasoningResult.finalAnswer;

      if (reasoning) {
        reasoningElement.textContent = reasoning;
        reasoningElement.style.display = 'block';
      }

      contentElement.innerHTML = `<div class="final-answer">${finalAnswer}</div>`;
    }
  }

  // æ„é€ å®Œæ•´çš„æ•°æ®å¯¹è±¡ç”¨äºåç»­å¤„ç†
  const data = {
    choices: [{
      message: {
        content: rawContent,
        reasoning_content: reasoning
      }
    }],
    model: model
  };

  // æ£€æµ‹å¹¶å¤„ç†æ¨ç†è¿‡ç¨‹
  const reasoningResult = extractReasoningProcess(data, rawContent);

  // æ‰“å°åŸå§‹å“åº”åˆ°æ§åˆ¶å°
  console.log('=== LLM API å“åº” ===');
  console.log('ğŸ“Š å®Œæ•´å“åº”æ•°æ®:', JSON.stringify(data, null, 2));
  console.log('ğŸ’­ åŸå§‹å›ç­”å†…å®¹:', rawContent);

  // å¦‚æœæ˜¯æ¨ç†æ¨¡å‹ï¼Œå•ç‹¬æ˜¾ç¤ºæ¨ç†è¿‡ç¨‹
  if (reasoningResult.isReasoningModel) {
    console.log('ğŸ§  æ¨ç†æ¨¡å‹æ£€æµ‹: æ˜¯');
    if (reasoningResult.reasoning) {
      console.log('ğŸ¤” æ¨ç†è¿‡ç¨‹:');
      console.log('%c' + reasoningResult.reasoning, 'color: #888; font-style: italic;');
    }
    if (reasoningResult.finalAnswer) {
      console.log('âœ… æœ€ç»ˆå›ç­”:', reasoningResult.finalAnswer);
    }
  } else {
    console.log('ğŸ§  æ¨ç†æ¨¡å‹æ£€æµ‹: å¦');
  }

  if (data.usage) {
    console.log('ğŸ“ˆ Tokenä½¿ç”¨æƒ…å†µ:', data.usage);
  }
  console.log('==================');

  // è§£æå›å¤å†…å®¹
  const content = cleanResponseContent(rawContent);
  const suggestions = extractSuggestions(rawContent);
  const structuredPoints = parseStructuredPoints(rawContent);

  // æ‰“å°è§£æåçš„ç»“æœ
  console.log('=== è§£æç»“æœ ===');
  console.log('ğŸ“„ æ¸…ç†åå†…å®¹:', content);
  console.log('ğŸ’¡ æå–çš„å»ºè®®:', suggestions);
  console.log('ğŸ“‹ ç»“æ„åŒ–åˆ†ç‚¹:', structuredPoints);
  console.log('===============');

  // ä¸ºæµå¼æ¶ˆæ¯æ·»åŠ å»ºè®®å’Œç»“æ„åŒ–åˆ†ç‚¹
  if (suggestions.length > 0 || structuredPoints.length > 0) {
    const streamingMessage = document.getElementById(messageId);
    if (streamingMessage) {
      const messageContent = streamingMessage.querySelector('.message-content');

      // æ·»åŠ å»ºè®®
      if (suggestions.length > 0) {
        const suggestionButtons = suggestions.map(s =>
          `<button class="suggestion-btn" onclick="addSuggestionToMindMap('${s.text}', '${s.type || 'child'}')">${s.text}</button>`
        ).join('');

        const suggestionsHtml = `
          <div class="suggestions">
            <div class="suggestions-title">ğŸ’¡ AIå»ºè®®</div>
            <div class="suggestions-list">${suggestionButtons}</div>
          </div>
        `;
        messageContent.insertAdjacentHTML('beforeend', suggestionsHtml);
      }

      // æ·»åŠ ç»“æ„åŒ–åˆ†ç‚¹
      if (structuredPoints.length > 0) {
        const pointsHtml = structuredPoints.map((point, index) => `
          <div class="structured-point" data-point-id="${point.id || index}">
            <div class="point-header">
              <input type="checkbox" class="point-checkbox" id="point_${messageId}_${index}">
              <label for="point_${messageId}_${index}" class="point-title">${point.title}</label>
            </div>
            <div class="point-content">${point.content}</div>
            ${point.keywords ? `<div class="point-keywords">${point.keywords.map(k => `<span class="keyword">${k}</span>`).join('')}</div>` : ''}
          </div>
        `).join('');

        const structuredPointsHtml = `
          <div class="structured-points">
            <div class="points-header">
              <div class="points-title">ğŸ“‹ ç»“æ„åŒ–åˆ†ç‚¹</div>
              <div class="points-actions">
                <button class="select-all-btn" onclick="selectAllPoints('${messageId}')">å…¨é€‰</button>
                <button class="add-selected-btn" onclick="addSelectedPoints('${messageId}')">æ·»åŠ é€‰ä¸­</button>
              </div>
            </div>
            <div class="points-list">${pointsHtml}</div>
          </div>
        `;
        messageContent.insertAdjacentHTML('beforeend', structuredPointsHtml);
      }
    }
  }

  // æµå¼å“åº”ä¸éœ€è¦è¿”å›å†…å®¹ï¼Œå› ä¸ºå·²ç»ç›´æ¥æ˜¾ç¤ºäº†
  return null;
}

// è·å–ç³»ç»Ÿæç¤ºè¯
function getSystemPrompt() {
  const jsonExample = '```json\n{\n  "structuredPoints": [\n    {\n      "id": "point_1",\n      "title": "æ¦‚æ‹¬æ€§æ ‡é¢˜",\n      "content": "è¯¦ç»†è§£é‡Šå†…å®¹",\n      "keywords": ["å…³é”®è¯1", "å…³é”®è¯2"]\n    }\n  ]\n}\n```';

  let prompt = `ä½ æ˜¯ä¸€ä¸ªä¸“ä¸šçš„æ€ç»´å¯¼å›¾AIåŠ©æ‰‹ã€‚ä½ çš„ä»»åŠ¡æ˜¯å¸®åŠ©ç”¨æˆ·æ‰©å±•å’Œå®Œå–„æ€ç»´å¯¼å›¾ã€‚

æ ¸å¿ƒèƒ½åŠ›ï¼š
1. åˆ†ææ€ç»´å¯¼å›¾èŠ‚ç‚¹å†…å®¹
2. æä¾›ç›¸å…³çš„å­èŠ‚ç‚¹å»ºè®®
3. å›ç­”ä¸èŠ‚ç‚¹å†…å®¹ç›¸å…³çš„é—®é¢˜
4. å¸®åŠ©ç”¨æˆ·ç†æ¸…æ€è·¯å’Œé€»è¾‘å…³ç³»

å›å¤è¦æ±‚ï¼š
- é¦–å…ˆæä¾›ä¸€ä¸ªç®€æ´çš„æ€»ä½“å›ç­”ï¼ˆ100-200å­—ï¼‰
- ç„¶åæä¾›ç»“æ„åŒ–çš„åˆ†ç‚¹ä¾›ç”¨æˆ·é€‰æ‹©æ·»åŠ åˆ°æ€ç»´å¯¼å›¾
- ä¿æŒé€»è¾‘æ€§å’Œæ¡ç†æ€§

é‡è¦ï¼šè¯·æŒ‰ä»¥ä¸‹æ ¼å¼å›å¤ï¼š
1. å…ˆç»™å‡ºä¸€ä¸ªç®€æ´çš„æ€»ä½“å›ç­”
2. ç„¶ååœ¨å›ç­”çš„æœ€åï¼Œç”¨ä»¥ä¸‹JSONæ ¼å¼æä¾›ç»“æ„åŒ–åˆ†ç‚¹ï¼š
${jsonExample}

æ¯ä¸ªåˆ†ç‚¹åº”è¯¥ï¼š
- æœ‰ä¸€ä¸ªç®€æ´çš„æ ‡é¢˜
- åŒ…å«è¯¦ç»†çš„è§£é‡Šå†…å®¹
- å¯ä»¥ä½œä¸ºæ€ç»´å¯¼å›¾çš„èŠ‚ç‚¹æ·»åŠ 
- å…·æœ‰å®é™…ä»·å€¼ï¼Œå¸®åŠ©ç”¨æˆ·æ‰©å±•æ€ç»´å¯¼å›¾`;

  // è·å–å½“å‰é€‰ä¸­èŠ‚ç‚¹çš„è¯¦ç»†ä¸Šä¸‹æ–‡ä¿¡æ¯
  if (selectedNodeText && selectedNodeHierarchy.length > 0) {
    prompt += `

å½“å‰ä¸Šä¸‹æ–‡ï¼š
- é€‰ä¸­èŠ‚ç‚¹ï¼š${selectedNodeText}
- èŠ‚ç‚¹è·¯å¾„ï¼š${selectedNodeHierarchy.join(' > ')}`;

    // è·å–èŠ‚ç‚¹é“¾è·¯çš„è¯¦ç»†ä¿¡æ¯ï¼ˆåŒ…æ‹¬å¤‡æ³¨ï¼‰
    if (mindMapInstance && mindMapInstance.renderer && mindMapInstance.renderer.activeNodeList && mindMapInstance.renderer.activeNodeList.length > 0) {
      const currentActiveNode = mindMapInstance.renderer.activeNodeList[0];
      const hierarchyWithNotes = getNodeHierarchyWithNotes(currentActiveNode);

      if (hierarchyWithNotes.length > 0) {
        prompt += `

èŠ‚ç‚¹é“¾è·¯è¯¦ç»†ä¿¡æ¯ï¼š`;
        hierarchyWithNotes.forEach((nodeInfo, index) => {
          prompt += `
${index + 1}. èŠ‚ç‚¹ï¼š"${nodeInfo.text}"`;
          if (nodeInfo.note && nodeInfo.note.trim()) {
            prompt += `
   å¤‡æ³¨ï¼š${nodeInfo.note.trim()}`;
          }
        });
      }
    }

    prompt += `

- è¯·åŸºäºè¿™ä¸ªèŠ‚ç‚¹çš„ä¸Šä¸‹æ–‡å’Œé“¾è·¯ä¿¡æ¯æ¥å›ç­”ç”¨æˆ·çš„é—®é¢˜`;
  }

  return prompt;
}

// æ‰“å­—æœºæ•ˆæœå‡½æ•°
async function typewriterEffect(element, text) {
  return new Promise((resolve) => {
    let currentText = element.textContent || '';
    element.textContent = currentText + text;

    // ç®€å•çš„å»¶è¿Ÿï¼Œå¯ä»¥æ ¹æ®éœ€è¦è°ƒæ•´
    setTimeout(resolve, 10);
  });
}

// ä»å†…å®¹ä¸­æå–æ¨ç†è¿‡ç¨‹ï¼ˆç”¨äºéå®˜æ–¹æ¨ç†æ¨¡å‹æ ¼å¼ï¼‰
function extractReasoningFromContent(content) {
  const result = {
    isReasoningModel: false,
    reasoning: '',
    finalAnswer: content
  };

  // æ£€æµ‹æ¨ç†æ¨¡å¼çš„å…³é”®è¯
  const reasoningKeywords = ['è®©æˆ‘æ€è€ƒ', 'æ€è€ƒè¿‡ç¨‹', 'æ¨ç†è¿‡ç¨‹', '<thinking>', '<reasoning>'];
  const hasReasoningPattern = reasoningKeywords.some(keyword => content.includes(keyword));

  if (hasReasoningPattern) {
    result.isReasoningModel = true;

    // å°è¯•æå–æ¨ç†è¿‡ç¨‹
    const reasoningPatterns = [
      /<thinking>([\s\S]*?)<\/thinking>/i,
      /<reasoning>([\s\S]*?)<\/reasoning>/i,
      /(?:æ€è€ƒè¿‡ç¨‹ï¼š|æ¨ç†è¿‡ç¨‹ï¼š|è®©æˆ‘æ€è€ƒä¸€ä¸‹[ï¼š:]?)([\s\S]*?)(?:ç»“è®ºï¼š|ç­”æ¡ˆï¼š|å›ç­”ï¼š|æœ€ç»ˆç­”æ¡ˆï¼š)/i,
    ];

    for (const pattern of reasoningPatterns) {
      const match = content.match(pattern);
      if (match) {
        result.reasoning = match[1].trim();
        result.finalAnswer = content.replace(match[0], '').trim();
        break;
      }
    }
  }

  return result;
}

// æ£€æµ‹å¹¶æå–æ¨ç†è¿‡ç¨‹
function extractReasoningProcess(data, rawContent) {
  const result = {
    isReasoningModel: false,
    reasoning: null,
    finalAnswer: null
  };

  // æ£€æµ‹æ–¹æ³•1: æ£€æŸ¥æ¨¡å‹åç§°æ˜¯å¦åŒ…å«æ¨ç†ç›¸å…³å…³é”®è¯
  const modelName = (data.model || '').toLowerCase();
  const reasoningKeywords = ['reasoner', 'reasoning', 'think', 'cot', 'chain-of-thought'];
  const isReasoningByModel = reasoningKeywords.some(keyword => modelName.includes(keyword));

  // æ£€æµ‹æ–¹æ³•2: æ£€æŸ¥å“åº”ç»“æ„æ˜¯å¦åŒ…å«æ¨ç†å­—æ®µï¼ˆDeepSeekå®˜æ–¹æ ¼å¼ï¼‰
  const choice = data.choices && data.choices[0];
  const hasDeepSeekReasoningField = choice && choice.message && choice.message.reasoning_content;

  // æ£€æµ‹æ–¹æ³•3: æ£€æŸ¥å“åº”ç»“æ„æ˜¯å¦åŒ…å«å…¶ä»–æ¨ç†å­—æ®µï¼ˆå…¼å®¹å…¶ä»–æ ¼å¼ï¼‰
  const hasOtherReasoningField = choice && (choice.reasoning || choice.message?.reasoning);

  // æ£€æµ‹æ–¹æ³•4: æ£€æŸ¥å†…å®¹æ ¼å¼æ˜¯å¦ç¬¦åˆæ¨ç†æ¨¡å¼
  const hasReasoningPattern = rawContent && (
    rawContent.includes('<thinking>') ||
    rawContent.includes('<reasoning>') ||
    rawContent.includes('è®©æˆ‘æ€è€ƒä¸€ä¸‹') ||
    rawContent.includes('æ€è€ƒè¿‡ç¨‹ï¼š') ||
    rawContent.includes('æ¨ç†è¿‡ç¨‹ï¼š') ||
    /^[\s\S]*?(?:æ€è€ƒ|æ¨ç†|åˆ†æ)[\s\S]*?(?:ç»“è®º|ç­”æ¡ˆ|å›ç­”)[\s\S]*$/i.test(rawContent)
  );

  result.isReasoningModel = isReasoningByModel || hasDeepSeekReasoningField || hasOtherReasoningField || hasReasoningPattern;

  if (result.isReasoningModel) {
    // æå–æ¨ç†è¿‡ç¨‹
    if (choice && choice.message && choice.message.reasoning_content) {
      // æ–¹æ³•1: DeepSeekå®˜æ–¹æ ¼å¼ - ä»message.reasoning_contentå­—æ®µæå–
      result.reasoning = choice.message.reasoning_content;
      result.finalAnswer = rawContent; // rawContentå°±æ˜¯contentå­—æ®µçš„å†…å®¹
    } else if (choice && choice.reasoning) {
      // æ–¹æ³•2: ä»APIå“åº”çš„reasoningå­—æ®µæå–ï¼ˆå…¶ä»–æ ¼å¼ï¼‰
      result.reasoning = choice.reasoning;
      result.finalAnswer = rawContent;
    } else if (choice && choice.message && choice.message.reasoning) {
      // æ–¹æ³•3: ä»message.reasoningå­—æ®µæå–ï¼ˆå…¶ä»–æ ¼å¼ï¼‰
      result.reasoning = choice.message.reasoning;
      result.finalAnswer = rawContent;
    } else if (rawContent) {
      // æ–¹æ³•3: ä»å†…å®¹ä¸­è§£ææ¨ç†è¿‡ç¨‹
      const reasoningPatterns = [
        // <thinking>æ ‡ç­¾æ ¼å¼
        /<thinking>([\s\S]*?)<\/thinking>/i,
        /<reasoning>([\s\S]*?)<\/reasoning>/i,
        // ä¸­æ–‡æ ¼å¼
        /(?:æ€è€ƒè¿‡ç¨‹ï¼š|æ¨ç†è¿‡ç¨‹ï¼š|è®©æˆ‘æ€è€ƒä¸€ä¸‹[ï¼š:]?)([\s\S]*?)(?:ç»“è®ºï¼š|ç­”æ¡ˆï¼š|å›ç­”ï¼š|æœ€ç»ˆç­”æ¡ˆï¼š)/i,
        // åˆ†æ®µæ ¼å¼
        /^([\s\S]*?)(?:\n\n|^)(?:ç»“è®º|ç­”æ¡ˆ|å›ç­”|æœ€ç»ˆç­”æ¡ˆ)[ï¼š:]?([\s\S]*)$/i
      ];

      for (const pattern of reasoningPatterns) {
        const match = rawContent.match(pattern);
        if (match) {
          if (pattern.source.includes('thinking') || pattern.source.includes('reasoning')) {
            result.reasoning = match[1].trim();
            result.finalAnswer = rawContent.replace(match[0], '').trim();
          } else if (pattern.source.includes('æ€è€ƒè¿‡ç¨‹') || pattern.source.includes('æ¨ç†è¿‡ç¨‹')) {
            result.reasoning = match[1].trim();
            const finalMatch = rawContent.match(/(?:ç»“è®ºï¼š|ç­”æ¡ˆï¼š|å›ç­”ï¼š|æœ€ç»ˆç­”æ¡ˆï¼š)([\s\S]*)$/i);
            result.finalAnswer = finalMatch ? finalMatch[1].trim() : rawContent;
          } else {
            result.reasoning = match[1].trim();
            result.finalAnswer = match[2] ? match[2].trim() : rawContent;
          }
          break;
        }
      }

      // å¦‚æœæ²¡æœ‰æ‰¾åˆ°æ˜ç¡®çš„åˆ†éš”ï¼Œä½†æ£€æµ‹åˆ°æ˜¯æ¨ç†æ¨¡å‹ï¼Œå°è¯•æ™ºèƒ½åˆ†å‰²
      if (!result.reasoning && result.isReasoningModel) {
        const lines = rawContent.split('\n');
        const thinkingLines = [];
        const answerLines = [];
        let isInAnswer = false;

        for (const line of lines) {
          const trimmed = line.trim();
          if (trimmed.match(/^(?:ç»“è®º|ç­”æ¡ˆ|å›ç­”|æœ€ç»ˆç­”æ¡ˆ|æ€»ç»“)[ï¼š:]?/i)) {
            isInAnswer = true;
          }

          if (isInAnswer) {
            answerLines.push(line);
          } else {
            thinkingLines.push(line);
          }
        }

        if (thinkingLines.length > 0 && answerLines.length > 0) {
          result.reasoning = thinkingLines.join('\n').trim();
          result.finalAnswer = answerLines.join('\n').trim();
        }
      }
    }
  }

  return result;
}

// æ¸…ç†AIå›å¤å†…å®¹
function cleanResponseContent(content) {
  // ç§»é™¤JSONä»£ç å—ï¼Œåªä¿ç•™æ–‡æœ¬å†…å®¹
  return content.replace(/```json[\s\S]*?```/g, '').trim();
}

// è§£æç»“æ„åŒ–åˆ†ç‚¹
function parseStructuredPoints(content) {
  try {
    // æŸ¥æ‰¾JSONä»£ç å—
    const jsonMatch = content.match(/```json\s*(\{[\s\S]*?\})\s*```/);
    if (!jsonMatch) {
      return [];
    }

    const jsonData = JSON.parse(jsonMatch[1]);
    if (jsonData.structuredPoints && Array.isArray(jsonData.structuredPoints)) {
      return jsonData.structuredPoints.map((point, index) => ({
        id: point.id || `point_${index + 1}`,
        title: point.title || `è¦ç‚¹${index + 1}`,
        content: point.content || '',
        keywords: Array.isArray(point.keywords) ? point.keywords : []
      }));
    }
  } catch (error) {
    console.error('è§£æç»“æ„åŒ–åˆ†ç‚¹å¤±è´¥:', error);
  }
  return [];
}

// æ¨¡æ‹ŸAIå›å¤
async function simulateAIResponse(message) {
  // æ¨¡æ‹Ÿç½‘ç»œå»¶è¿Ÿ
  await new Promise(resolve => setTimeout(resolve, 1500));

  let content = '';
  let suggestions = [];
  let structuredPoints = [];

  if (message.includes('æ‰©å±•')) {
    content = `å…³äº"${selectedNodeText}"çš„æ‰©å±•å»ºè®®ï¼š\n\næˆ‘ä¸ºæ‚¨æä¾›äº†è¯¦ç»†çš„æ‰©å±•æ–¹æ¡ˆï¼ŒåŒ…æ‹¬å¤šä¸ªç»´åº¦çš„åˆ†æã€‚`;
    suggestions = [
      { text: 'å®šä¹‰å’Œæ¦‚å¿µ', type: 'child' },
      { text: 'åº”ç”¨åœºæ™¯', type: 'child' },
      { text: 'ç›¸å…³æŠ€æœ¯', type: 'child' }
    ];

    // ç”Ÿæˆç»“æ„åŒ–åˆ†ç‚¹
    structuredPoints = [
      {
        id: 'point_1',
        title: 'åŸºç¡€æ¦‚å¿µ',
        content: `${selectedNodeText}çš„æ ¸å¿ƒå®šä¹‰å’ŒåŸºæœ¬åŸç†`,
        keywords: ['å®šä¹‰', 'åŸç†', 'åŸºç¡€']
      },
      {
        id: 'point_2',
        title: 'æŠ€æœ¯ç‰¹ç‚¹',
        content: `${selectedNodeText}çš„ä¸»è¦æŠ€æœ¯ç‰¹å¾å’Œä¼˜åŠ¿`,
        keywords: ['ç‰¹ç‚¹', 'ä¼˜åŠ¿', 'æŠ€æœ¯']
      },
      {
        id: 'point_3',
        title: 'åº”ç”¨é¢†åŸŸ',
        content: `${selectedNodeText}åœ¨å„ä¸ªè¡Œä¸šçš„å…·ä½“åº”ç”¨`,
        keywords: ['åº”ç”¨', 'è¡Œä¸š', 'å®è·µ']
      },
      {
        id: 'point_4',
        title: 'å‘å±•è¶‹åŠ¿',
        content: `${selectedNodeText}çš„æœªæ¥å‘å±•æ–¹å‘å’Œè¶‹åŠ¿`,
        keywords: ['è¶‹åŠ¿', 'å‘å±•', 'æœªæ¥']
      }
    ];
  } else if (message.includes('è§£é‡Š')) {
    content = `"${selectedNodeText}"çš„è¯¦ç»†è§£é‡Šï¼š\n\næˆ‘ä¸ºæ‚¨æä¾›äº†å…¨é¢çš„è§£é‡Šï¼ŒåŒ…å«å¤šä¸ªå±‚é¢çš„åˆ†æã€‚`;
    suggestions = [
      { text: 'æ ¸å¿ƒç‰¹ç‚¹', type: 'child' },
      { text: 'å·¥ä½œåŸç†', type: 'child' }
    ];

    structuredPoints = [
      {
        id: 'explain_1',
        title: 'åŸºæœ¬å«ä¹‰',
        content: `${selectedNodeText}çš„åŸºæœ¬å®šä¹‰å’Œå«ä¹‰`,
        keywords: ['å®šä¹‰', 'å«ä¹‰', 'åŸºæœ¬']
      },
      {
        id: 'explain_2',
        title: 'æ ¸å¿ƒè¦ç´ ',
        content: `æ„æˆ${selectedNodeText}çš„å…³é”®è¦ç´ å’Œç»„æˆéƒ¨åˆ†`,
        keywords: ['è¦ç´ ', 'ç»„æˆ', 'æ ¸å¿ƒ']
      },
      {
        id: 'explain_3',
        title: 'è¿ä½œæœºåˆ¶',
        content: `${selectedNodeText}çš„å·¥ä½œåŸç†å’Œè¿ä½œæ–¹å¼`,
        keywords: ['åŸç†', 'æœºåˆ¶', 'è¿ä½œ']
      }
    ];
  } else if (message.includes('åº”ç”¨')) {
    content = `"${selectedNodeText}"çš„åº”ç”¨åœºæ™¯åˆ†æï¼š\n\næˆ‘æ•´ç†äº†å¤šä¸ªå®é™…åº”ç”¨åœºæ™¯ä¾›æ‚¨å‚è€ƒã€‚`;
    suggestions = [
      { text: 'å•†ä¸šåº”ç”¨', type: 'child' },
      { text: 'æŠ€æœ¯åº”ç”¨', type: 'child' }
    ];

    structuredPoints = [
      {
        id: 'app_1',
        title: 'å•†ä¸šåœºæ™¯',
        content: `${selectedNodeText}åœ¨å•†ä¸šç¯å¢ƒä¸­çš„åº”ç”¨`,
        keywords: ['å•†ä¸š', 'ä¼ä¸š', 'å¸‚åœº']
      },
      {
        id: 'app_2',
        title: 'æŠ€æœ¯åœºæ™¯',
        content: `${selectedNodeText}åœ¨æŠ€æœ¯å¼€å‘ä¸­çš„åº”ç”¨`,
        keywords: ['æŠ€æœ¯', 'å¼€å‘', 'å·¥ç¨‹']
      },
      {
        id: 'app_3',
        title: 'æ•™è‚²åœºæ™¯',
        content: `${selectedNodeText}åœ¨æ•™è‚²åŸ¹è®­ä¸­çš„åº”ç”¨`,
        keywords: ['æ•™è‚²', 'åŸ¹è®­', 'å­¦ä¹ ']
      }
    ];
  } else {
    content = `å…³äº"${selectedNodeText}"ï¼Œæˆ‘ç†è§£æ‚¨çš„é—®é¢˜ã€‚è¿™æ˜¯ä¸€ä¸ªå¾ˆæœ‰è¶£çš„è¯é¢˜ï¼Œæˆ‘ä¸ºæ‚¨æä¾›äº†å¤šè§’åº¦çš„åˆ†æã€‚`;
    suggestions = [
      { text: 'æ·±å…¥äº†è§£', type: 'child' },
      { text: 'å®è·µåº”ç”¨', type: 'child' }
    ];

    structuredPoints = [
      {
        id: 'general_1',
        title: 'æ¦‚è¿°',
        content: `${selectedNodeText}çš„æ€»ä½“æ¦‚è¿°å’Œé‡è¦æ€§`,
        keywords: ['æ¦‚è¿°', 'é‡è¦æ€§', 'æ€»ä½“']
      },
      {
        id: 'general_2',
        title: 'å…³é”®ç‚¹',
        content: `å…³äº${selectedNodeText}éœ€è¦é‡ç‚¹å…³æ³¨çš„æ–¹é¢`,
        keywords: ['å…³é”®', 'é‡ç‚¹', 'æ ¸å¿ƒ']
      }
    ];
  }

  return { content, suggestions, structuredPoints };
}

// ä»AIå›å¤ä¸­æå–å»ºè®®
function extractSuggestions(content) {
  const suggestions = [];
  const lines = content.split('\n');

  lines.forEach(line => {
    const trimmed = line.trim();
    if (trimmed.startsWith('- ') || trimmed.startsWith('â€¢ ')) {
      const text = trimmed.substring(2).trim();
      if (text.length > 0 && text.length < 50) {
        suggestions.push({
          text,
          type: 'child'
        });
      }
    }
  });

  return suggestions.slice(0, 3);
}

// æ·»åŠ æ¶ˆæ¯
function addMessage(role, content, suggestions = [], structuredPoints = []) {
  const messagesContainer = document.getElementById('chatMessages');

  // ç§»é™¤æ¬¢è¿æ¶ˆæ¯
  const welcomeMessage = messagesContainer.querySelector('.welcome-message');
  if (welcomeMessage && messages.length === 0) {
    welcomeMessage.remove();
  }

  const messageId = 'msg_' + Date.now() + '_' + Math.random().toString(36).substr(2, 5);
  const messageDiv = document.createElement('div');
  messageDiv.className = `message-item ${role}`;
  messageDiv.id = messageId;

  const avatar = role === 'user' ? 'ğŸ‘¤' : 'ğŸ¤–';

  // æ™®é€šå»ºè®®HTML
  let suggestionsHtml = '';
  if (suggestions && suggestions.length > 0) {
    const suggestionButtons = suggestions.map(s =>
      `<button class="suggestion-btn" onclick="addSuggestionToMindMap('${s.text}', '${s.type || 'child'}')">${s.text}</button>`
    ).join('');

    suggestionsHtml = `
      <div class="suggestions">
        <div class="suggestions-title">ğŸ’¡ AIå»ºè®®</div>
        <div class="suggestions-list">${suggestionButtons}</div>
      </div>
    `;
  }

  // ç»“æ„åŒ–åˆ†ç‚¹HTML
  let structuredPointsHtml = '';
  if (structuredPoints && structuredPoints.length > 0) {
    const pointsHtml = structuredPoints.map((point, index) => `
      <div class="structured-point" data-point-id="${point.id || index}">
        <div class="point-header">
          <input type="checkbox" class="point-checkbox" id="point_${messageId}_${index}">
          <label for="point_${messageId}_${index}" class="point-title">${point.title}</label>
        </div>
        <div class="point-content">${point.content}</div>
        ${point.keywords ? `<div class="point-keywords">${point.keywords.map(k => `<span class="keyword">${k}</span>`).join('')}</div>` : ''}
      </div>
    `).join('');

    structuredPointsHtml = `
      <div class="structured-points">
        <div class="points-header">
          <div class="points-title">ğŸ“‹ ç»“æ„åŒ–åˆ†ç‚¹</div>
          <div class="points-actions">
            <button class="select-all-btn" onclick="selectAllPoints('${messageId}')">å…¨é€‰</button>
            <button class="add-selected-btn" onclick="addSelectedPoints('${messageId}')">æ·»åŠ é€‰ä¸­</button>
          </div>
        </div>
        <div class="points-list">${pointsHtml}</div>
      </div>
    `;
  }

  messageDiv.innerHTML = `
    <div class="message-avatar">${avatar}</div>
    <div class="message-content">
      <div class="message-text">${content}</div>
      ${suggestionsHtml}
      ${structuredPointsHtml}
    </div>
  `;

  messagesContainer.appendChild(messageDiv);
  messagesContainer.scrollTop = messagesContainer.scrollHeight;

  messages.push({ role, content, suggestions, structuredPoints });
}

// æ·»åŠ ç³»ç»Ÿæ¶ˆæ¯
function addSystemMessage(content) {
  const messagesContainer = document.getElementById('chatMessages');

  const messageDiv = document.createElement('div');
  messageDiv.className = 'message-item system';
  messageDiv.innerHTML = `
    <div class="message-content">
      ${content}
    </div>
  `;

  messagesContainer.appendChild(messageDiv);
  messagesContainer.scrollTop = messagesContainer.scrollHeight;
}

// è®¾ç½®åŠ è½½çŠ¶æ€
function setLoading(loading) {
  isLoading = loading;
  const sendBtn = document.getElementById('sendBtn');
  const input = document.getElementById('messageInput');

  if (loading) {
    sendBtn.textContent = 'å‘é€ä¸­...';
    sendBtn.disabled = true;
    input.disabled = true;

    // æ·»åŠ åŠ è½½æ¶ˆæ¯
    const messagesContainer = document.getElementById('chatMessages');
    const loadingDiv = document.createElement('div');
    loadingDiv.className = 'message-item assistant';
    loadingDiv.id = 'loadingMessage';
    loadingDiv.innerHTML = `
      <div class="message-avatar loading">ğŸ¤–</div>
      <div class="message-content">
        <div class="message-text">AIæ­£åœ¨æ€è€ƒä¸­<span class="thinking-dots"><span class="dot"></span><span class="dot"></span><span class="dot"></span></span></div>
      </div>
    `;
    messagesContainer.appendChild(loadingDiv);
    messagesContainer.scrollTop = messagesContainer.scrollHeight;
  } else {
    sendBtn.textContent = 'å‘é€';
    sendBtn.disabled = false;
    input.disabled = false;

    // ç§»é™¤åŠ è½½æ¶ˆæ¯
    const loadingMessage = document.getElementById('loadingMessage');
    if (loadingMessage) {
      loadingMessage.remove();
    }
  }
}

// æ·»åŠ å»ºè®®åˆ°æ€ç»´å¯¼å›¾
function addSuggestionToMindMap(text, type = 'child') {
  if (!mindMapInstance) {
    showNotification('âŒ æ€ç»´å¯¼å›¾æœªåˆå§‹åŒ–ï¼Œè¯·ç­‰å¾…åŠ è½½å®Œæˆ', 'error');
    return;
  }

  try {
    // è·å–å½“å‰æ¿€æ´»çš„èŠ‚ç‚¹
    const activeNodes = mindMapInstance.renderer.activeNodeList;
    if (!activeNodes || activeNodes.length === 0) {
      showNotification('âš ï¸ è¯·å…ˆç‚¹å‡»é€‰æ‹©ä¸€ä¸ªæ€ç»´å¯¼å›¾èŠ‚ç‚¹', 'warning');
      return;
    }

    const parentNode = activeNodes[0];
    console.log('æ·»åŠ èŠ‚ç‚¹åˆ°:', parentNode, 'æ–‡æœ¬:', text, 'ç±»å‹:', type);

    // æ ¹æ®ç±»å‹æ·»åŠ èŠ‚ç‚¹ - ä½¿ç”¨æ­£ç¡®çš„å‚æ•°æ ¼å¼
    if (type === 'child') {
      // æ·»åŠ å­èŠ‚ç‚¹
      mindMapInstance.execCommand('INSERT_CHILD_NODE', false, [], {
        text: text,
        uid: generateNodeId()
      });
    } else if (type === 'sibling') {
      // æ·»åŠ å…„å¼ŸèŠ‚ç‚¹
      mindMapInstance.execCommand('INSERT_NODE', false, [], {
        text: text,
        uid: generateNodeId()
      });
    }

    showNotification(`âœ… å·²æ·»åŠ "${text}"åˆ°æ€ç»´å¯¼å›¾`, 'success');

    // è§¦å‘æ•°æ®ä¿å­˜
    try {
      if (typeof window.takeOverAppMethods?.saveMindMapData === 'function') {
        const data = mindMapInstance.getData();
        window.takeOverAppMethods.saveMindMapData(data);
      }
    } catch (saveError) {
      console.warn('ä¿å­˜æ•°æ®å¤±è´¥:', saveError);
    }

  } catch (error) {
    console.error('æ·»åŠ èŠ‚ç‚¹å¤±è´¥:', error);
    showNotification('âŒ æ·»åŠ èŠ‚ç‚¹å¤±è´¥: ' + error.message, 'error');
  }
}

// ç”Ÿæˆå”¯ä¸€èŠ‚ç‚¹ID
function generateNodeId() {
  return 'ai_node_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9);
}

// æ‰‹åŠ¨åŒæ­¥å½“å‰æ¿€æ´»èŠ‚ç‚¹
function syncCurrentActiveNode() {
  if (!mindMapInstance) {
    console.log('æ€ç»´å¯¼å›¾å®ä¾‹ä¸å­˜åœ¨ï¼Œæ— æ³•åŒæ­¥');
    showNotification('âŒ æ€ç»´å¯¼å›¾æœªåˆå§‹åŒ–', 'error');
    return false;
  }

  try {
    const activeNodes = mindMapInstance.renderer.activeNodeList;
    if (activeNodes && activeNodes.length > 0) {
      const currentActiveNode = activeNodes[0];
      console.log('æ‰‹åŠ¨åŒæ­¥æ¿€æ´»èŠ‚ç‚¹:', currentActiveNode);
      updateSelectedNode(currentActiveNode);

      // è·å–èŠ‚ç‚¹æ–‡æœ¬ç”¨äºé€šçŸ¥
      let rawNodeText = currentActiveNode.nodeData ?
        currentActiveNode.nodeData.data.text :
        (currentActiveNode.getData ? currentActiveNode.getData('text') : 'æœªçŸ¥èŠ‚ç‚¹');

      // æ¸…ç†HTMLæ ‡ç­¾
      let nodeText = '';
      if (typeof rawNodeText === 'string') {
        const tempDiv = document.createElement('div');
        tempDiv.innerHTML = rawNodeText;
        nodeText = tempDiv.textContent || tempDiv.innerText || rawNodeText;
      } else {
        nodeText = rawNodeText || 'æœªçŸ¥èŠ‚ç‚¹';
      }

      showNotification(`âœ… å·²åŒæ­¥èŠ‚ç‚¹: ${nodeText}`, 'success');
      return true;
    } else {
      console.log('æ²¡æœ‰æ¿€æ´»çš„èŠ‚ç‚¹');
      showNotification('âš ï¸ æ²¡æœ‰é€‰ä¸­çš„èŠ‚ç‚¹ï¼Œè¯·å…ˆç‚¹å‡»æ€ç»´å¯¼å›¾ä¸­çš„èŠ‚ç‚¹', 'warning');
      return false;
    }
  } catch (error) {
    console.error('åŒæ­¥æ¿€æ´»èŠ‚ç‚¹å¤±è´¥:', error);
    showNotification('âŒ åŒæ­¥å¤±è´¥: ' + error.message, 'error');
    return false;
  }
}

// æ‰¹é‡æ·»åŠ ç»“æ„åŒ–åˆ†ç‚¹
async function addStructuredPoints(points) {
  console.log('ğŸš€ addStructuredPoints è¢«è°ƒç”¨ï¼Œæ¥æ”¶åˆ°çš„æ•°æ®:', points);
  console.log('ğŸš€ æ•°æ®ç±»å‹:', typeof points, 'æ•°æ®é•¿åº¦:', points ? points.length : 'undefined');

  if (!points || points.length === 0) {
    console.error('âŒ æ— æ•ˆçš„å‚æ•°ï¼šæ²¡æœ‰åˆ†ç‚¹æ•°æ®');
    showNotification('âŒ æ— æ•ˆçš„å‚æ•°ï¼šæ²¡æœ‰åˆ†ç‚¹æ•°æ®', 'error');
    return;
  }

  if (!mindMapInstance) {
    console.error('âŒ æ€ç»´å¯¼å›¾æœªåˆå§‹åŒ–');
    showNotification('âŒ æ€ç»´å¯¼å›¾æœªåˆå§‹åŒ–ï¼Œè¯·ç­‰å¾…åŠ è½½å®Œæˆ', 'error');
    return;
  }

  // å°è¯•æ‰‹åŠ¨åŒæ­¥å½“å‰æ¿€æ´»èŠ‚ç‚¹
  syncCurrentActiveNode();

  try {
    const activeNodes = mindMapInstance.renderer.activeNodeList;
    console.log('ğŸ” å½“å‰æ¿€æ´»èŠ‚ç‚¹:', activeNodes);

    if (!activeNodes || activeNodes.length === 0) {
      console.error('âŒ æ²¡æœ‰æ¿€æ´»çš„èŠ‚ç‚¹');
      showNotification('âš ï¸ è¯·å…ˆç‚¹å‡»é€‰æ‹©ä¸€ä¸ªæ€ç»´å¯¼å›¾èŠ‚ç‚¹', 'warning');
      return;
    }

    const parentNode = activeNodes[0];
    console.log('ğŸ” çˆ¶èŠ‚ç‚¹:', parentNode);
    console.log('ğŸš€ å¼€å§‹æ‰¹é‡æ·»åŠ åˆ†ç‚¹åˆ°èŠ‚ç‚¹:', parentNode.getData().text);

    // è·å–æ·»åŠ å‰çš„èŠ‚ç‚¹æ•°æ®
    const beforeData = mindMapInstance.getData();
    const beforeNodeCount = countAllNodes(beforeData);
    console.log(`ğŸ” æ·»åŠ å‰èŠ‚ç‚¹æ€»æ•°: ${beforeNodeCount}`);

    // å‡†å¤‡æ‰¹é‡æ·»åŠ çš„èŠ‚ç‚¹æ•°æ®
    const nodesToAdd = [];
    points.forEach((point, index) => {
      const nodeText = point.title || point.text || `åˆ†ç‚¹${index + 1}`;
      console.log(`ğŸ” å‡†å¤‡ç¬¬${index + 1}ä¸ªåˆ†ç‚¹: "${nodeText}"`);

      if (nodeText && nodeText.trim().length > 0) {
        nodesToAdd.push({
          data: {
            text: nodeText,
            uid: generateNodeId(),
            note: point.content || '' // å°†è¯¦ç»†å†…å®¹ä½œä¸ºå¤‡æ³¨
          },
          children: []
        });
      }
    });

    console.log(`ğŸš€ å‡†å¤‡æ‰¹é‡æ·»åŠ  ${nodesToAdd.length} ä¸ªåˆ†ç‚¹:`, nodesToAdd);

    let actualAddedCount = 0;
    const results = [];

    try {
      if (nodesToAdd.length > 0) {
        console.log(`ğŸš€ æ‰§è¡Œ INSERT_MULTI_CHILD_NODE å‘½ä»¤ï¼Œæ‰¹é‡æ·»åŠ  ${nodesToAdd.length} ä¸ªèŠ‚ç‚¹`);

        // ä½¿ç”¨æ­£ç¡®çš„æ‰¹é‡æ·»åŠ å‘½ä»¤è°ƒç”¨æ–¹å¼
        mindMapInstance.execCommand('INSERT_MULTI_CHILD_NODE', [], nodesToAdd);

        console.log(`âœ… INSERT_MULTI_CHILD_NODE å‘½ä»¤æ‰§è¡Œå®Œæˆ`);

        // éªŒè¯æ˜¯å¦æ·»åŠ æˆåŠŸ
        const afterData = mindMapInstance.getData();
        const afterNodeCount = countAllNodes(afterData);
        console.log(`ğŸ” æ·»åŠ åèŠ‚ç‚¹æ€»æ•°: ${afterNodeCount}`);

        const addedCount = afterNodeCount - beforeNodeCount;
        if (addedCount > 0) {
          actualAddedCount = addedCount;
          console.log(`âœ… æˆåŠŸæ‰¹é‡æ·»åŠ  ${actualAddedCount} ä¸ªåˆ†ç‚¹`);

          // ä¸ºæ¯ä¸ªæˆåŠŸæ·»åŠ çš„èŠ‚ç‚¹è®°å½•ç»“æœ
          nodesToAdd.forEach((nodeData, index) => {
            results.push({
              text: nodeData.data.text,
              success: true,
              error: ''
            });
          });

          // ç­‰å¾…ä¸€ä¸‹è®©èŠ‚ç‚¹æ¸²æŸ“å®Œæˆï¼Œç„¶åè®¾ç½®å¤‡æ³¨
          setTimeout(async () => {
            console.log(`ğŸ” å¼€å§‹ä¸ºæ–°æ·»åŠ çš„èŠ‚ç‚¹è®¾ç½®å¤‡æ³¨...`);

            try {
              // è·å–å½“å‰æ¿€æ´»èŠ‚ç‚¹çš„å­èŠ‚ç‚¹
              const currentActiveNodes = mindMapInstance.renderer.activeNodeList;
              if (currentActiveNodes && currentActiveNodes.length > 0) {
                const parentNode = currentActiveNodes[0];

                // éå†çˆ¶èŠ‚ç‚¹çš„å­èŠ‚ç‚¹ï¼Œä¸ºæ–°æ·»åŠ çš„èŠ‚ç‚¹è®¾ç½®å¤‡æ³¨
                if (parentNode.children && parentNode.children.length > 0) {
                  const newlyAddedNodes = parentNode.children.slice(-nodesToAdd.length);

                  newlyAddedNodes.forEach((childNode, index) => {
                    const correspondingPoint = points[index];
                    if (correspondingPoint && correspondingPoint.content) {
                      console.log(`ğŸ” ä¸ºèŠ‚ç‚¹ "${childNode.getData().text}" è®¾ç½®å¤‡æ³¨: "${correspondingPoint.content}"`);

                      try {
                        childNode.setNote(correspondingPoint.content);
                        console.log(`âœ… æˆåŠŸè®¾ç½®å¤‡æ³¨`);
                      } catch (noteError) {
                        console.error(`âŒ è®¾ç½®å¤‡æ³¨å¤±è´¥:`, noteError);
                      }
                    }
                  });
                }
              }
            } catch (noteError) {
              console.error(`âŒ è®¾ç½®å¤‡æ³¨è¿‡ç¨‹å¤±è´¥:`, noteError);
            }
          }, 500);

        } else {
          console.log(`âŒ æ‰¹é‡æ·»åŠ å¤±è´¥ï¼ŒèŠ‚ç‚¹æ•°æœªå¢åŠ `);
          console.log(`ğŸ” æ·»åŠ å‰: ${beforeNodeCount}, æ·»åŠ å: ${afterNodeCount}`);

          // ä¸ºæ¯ä¸ªèŠ‚ç‚¹è®°å½•å¤±è´¥ç»“æœ
          nodesToAdd.forEach((nodeData, index) => {
            results.push({
              text: nodeData.data.text,
              success: false,
              error: 'èŠ‚ç‚¹æ•°æœªå¢åŠ '
            });
          });
        }
      }
    } catch (error) {
      console.error(`âŒ æ‰¹é‡æ·»åŠ åˆ†ç‚¹å¤±è´¥:`, error);

      // ä¸ºæ¯ä¸ªèŠ‚ç‚¹è®°å½•å¤±è´¥ç»“æœ
      nodesToAdd.forEach((nodeData, index) => {
        results.push({
          text: nodeData.data.text,
          success: false,
          error: error.message
        });
      });
    }

    console.log('=== æ·»åŠ ç»“æœç»Ÿè®¡ ===');
    console.log(`å°è¯•æ·»åŠ : ${points.length} ä¸ªåˆ†ç‚¹`);
    console.log(`å®é™…æ·»åŠ : ${actualAddedCount} ä¸ªåˆ†ç‚¹`);

    // æ˜¾ç¤ºè¯¦ç»†ç»“æœ
    results.forEach((result, index) => {
      console.log(`åˆ†ç‚¹${index + 1}: ${result.text} - ${result.success ? 'æˆåŠŸ' : 'å¤±è´¥' + (result.error ? ` (${result.error})` : '')}`);
    });

    // æ˜¾ç¤ºå‡†ç¡®çš„é€šçŸ¥
    if (actualAddedCount > 0) {
      showNotification(`âœ… å·²æ·»åŠ  ${actualAddedCount} ä¸ªåˆ†ç‚¹åˆ°æ€ç»´å¯¼å›¾`, 'success');

      // è§¦å‘æ•°æ®ä¿å­˜
      try {
        if (typeof window.takeOverAppMethods?.saveMindMapData === 'function') {
          const finalData = mindMapInstance.getData();
          window.takeOverAppMethods.saveMindMapData(finalData);
        }
      } catch (saveError) {
        console.warn('ä¿å­˜æ•°æ®å¤±è´¥:', saveError);
      }
    } else {
      showNotification('âŒ æ²¡æœ‰æˆåŠŸæ·»åŠ ä»»ä½•åˆ†ç‚¹', 'error');
    }

  } catch (error) {
    console.error('æ‰¹é‡æ·»åŠ èŠ‚ç‚¹å¤±è´¥:', error);
    showNotification('âŒ æ‰¹é‡æ·»åŠ å¤±è´¥: ' + error.message, 'error');
  }
}

// è¾…åŠ©å‡½æ•°ï¼šé€’å½’è®¡ç®—æ€ç»´å¯¼å›¾ä¸­çš„æ‰€æœ‰èŠ‚ç‚¹æ•°é‡
function countAllNodes(data) {
  if (!data) return 0;

  let count = 1; // å½“å‰èŠ‚ç‚¹

  if (data.children && Array.isArray(data.children)) {
    data.children.forEach(child => {
      count += countAllNodes(child);
    });
  }

  return count;
}

// åˆ‡æ¢æœ€å°åŒ–çŠ¶æ€
function toggleMinimize() {
  isMinimized = !isMinimized;
  const chatBot = document.getElementById('aiChatBot');
  const minimizeBtn = document.getElementById('minimizeBtn');

  if (isMinimized) {
    chatBot.classList.add('minimized');
    minimizeBtn.textContent = 'â¬†ï¸';
    minimizeBtn.title = 'å±•å¼€';
  } else {
    chatBot.classList.remove('minimized');
    minimizeBtn.textContent = 'â¬‡ï¸';
    minimizeBtn.title = 'æœ€å°åŒ–';
  }
}

// æ¸…é™¤æ¶ˆæ¯
function clearMessages() {
  const messagesContainer = document.getElementById('chatMessages');
  messagesContainer.innerHTML = `
    <div class="welcome-message">
      <div class="welcome-content">
        <span class="ai-icon">ğŸ¤–</span>
        <h3>AIæ€ç»´å¯¼å›¾åŠ©æ‰‹</h3>
        <p>ç‚¹å‡»æ€ç»´å¯¼å›¾èŠ‚ç‚¹å¼€å§‹å¯¹è¯</p>
      </div>
    </div>
  `;
  messages = [];
}

// æ˜¾ç¤ºé…ç½®
function showConfig() {
  document.getElementById('aiConfigPanel').style.display = 'block';

  // åŠ è½½å½“å‰é…ç½®åˆ°è¡¨å•
  document.getElementById('aiProvider').value = aiConfig.provider;
  document.getElementById('apiKey').value = aiConfig.apiKey;
  document.getElementById('aiModel').value = aiConfig.model;
  document.getElementById('baseURL').value = aiConfig.baseURL;
}

// å…³é—­é…ç½®
function closeConfig() {
  document.getElementById('aiConfigPanel').style.display = 'none';
}

// ä¿å­˜é…ç½®
function saveConfig() {
  aiConfig.provider = document.getElementById('aiProvider').value;
  aiConfig.apiKey = document.getElementById('apiKey').value;
  aiConfig.model = document.getElementById('aiModel').value;
  aiConfig.baseURL = document.getElementById('baseURL').value;

  // ä¿å­˜åˆ°æœ¬åœ°å­˜å‚¨
  localStorage.setItem('ai_config', JSON.stringify(aiConfig));

  alert('é…ç½®ä¿å­˜æˆåŠŸ');
  closeConfig();
}

// åŠ è½½AIé…ç½®
function loadAIConfig() {
  try {
    const saved = localStorage.getItem('ai_config');
    if (saved) {
      aiConfig = { ...aiConfig, ...JSON.parse(saved) };
    }
  } catch (error) {
    console.error('åŠ è½½AIé…ç½®å¤±è´¥:', error);
  }
}

// æµ‹è¯•è¿æ¥
async function testConnection() {
  if (!aiConfig.apiKey) {
    alert('è¯·å…ˆé…ç½®API Key');
    return;
  }

  try {
    const response = await callRealAI('æµ‹è¯•è¿æ¥');
    alert('è¿æ¥æµ‹è¯•æˆåŠŸ');
  } catch (error) {
    alert('è¿æ¥æµ‹è¯•å¤±è´¥ï¼š' + error.message);
  }
}

// å¤„ç†é”®ç›˜äº‹ä»¶
function handleKeyDown(event) {
  if (event.key === 'Enter' && !event.shiftKey) {
    event.preventDefault();
    sendMessage();
  }
}

// ç»“æ„åŒ–åˆ†ç‚¹ç›¸å…³å‡½æ•°
function selectAllPoints(messageId) {
  const checkboxes = document.querySelectorAll(`#${messageId} .point-checkbox`);
  const allChecked = Array.from(checkboxes).every(cb => cb.checked);

  checkboxes.forEach(checkbox => {
    checkbox.checked = !allChecked;
  });

  // æ›´æ–°æŒ‰é’®æ–‡æœ¬
  const selectAllBtn = document.querySelector(`#${messageId} .select-all-btn`);
  if (selectAllBtn) {
    selectAllBtn.textContent = allChecked ? 'å…¨é€‰' : 'å–æ¶ˆå…¨é€‰';
  }
}

function addSelectedPoints(messageId) {
  console.log('ğŸ” addSelectedPoints è¢«è°ƒç”¨ï¼ŒmessageId:', messageId);

  // ä½¿ç”¨æ›´çµæ´»çš„é€‰æ‹©å™¨
  const checkboxes = document.querySelectorAll(`#${messageId} .point-checkbox:checked`);
  console.log('ğŸ” æ‰¾åˆ°é€‰ä¸­çš„å¤é€‰æ¡†æ•°é‡:', checkboxes.length);

  if (checkboxes.length === 0) {
    showNotification('è¯·å…ˆé€‰æ‹©è¦æ·»åŠ çš„åˆ†ç‚¹', 'warning');
    return;
  }

  const selectedPoints = [];
  checkboxes.forEach((checkbox, index) => {
    console.log(`ğŸ” å¤„ç†ç¬¬${index + 1}ä¸ªå¤é€‰æ¡†:`, checkbox);
    console.log(`ğŸ” å¤é€‰æ¡†HTML:`, checkbox.outerHTML);

    const pointDiv = checkbox.closest('.structured-point');
    if (!pointDiv) {
      console.error('âŒ æœªæ‰¾åˆ° .structured-point å®¹å™¨');
      console.log('ğŸ” å¤é€‰æ¡†çˆ¶çº§å…ƒç´ :', checkbox.parentElement);
      return;
    }

    console.log(`ğŸ” æ‰¾åˆ°çš„åˆ†ç‚¹å®¹å™¨:`, pointDiv);
    console.log(`ğŸ” åˆ†ç‚¹å®¹å™¨HTML:`, pointDiv.outerHTML);

    const titleElement = pointDiv.querySelector('.point-title');
    const contentElement = pointDiv.querySelector('.point-content');
    const keywordElements = pointDiv.querySelectorAll('.keyword');

    console.log(`ğŸ” æ ‡é¢˜å…ƒç´ :`, titleElement);
    console.log(`ğŸ” å†…å®¹å…ƒç´ :`, contentElement);
    console.log(`ğŸ” å…³é”®è¯å…ƒç´ :`, keywordElements);

    if (!titleElement) {
      console.error('âŒ æœªæ‰¾åˆ° .point-title å…ƒç´ ');
      console.log('ğŸ” åˆ†ç‚¹å®¹å™¨å†…çš„æ‰€æœ‰å…ƒç´ :', pointDiv.children);
      return;
    }

    const title = titleElement.textContent.trim();
    const content = contentElement ? contentElement.textContent.trim() : '';
    const keywords = Array.from(keywordElements).map(k => k.textContent.trim());

    console.log(`ğŸ” æå–çš„åˆ†ç‚¹æ•°æ®:`, {
      title: `"${title}"`,
      content: `"${content}"`,
      keywords: keywords,
      titleLength: title.length,
      contentLength: content.length
    });

    // éªŒè¯æ•°æ®æœ‰æ•ˆæ€§
    if (!title || title.length === 0) {
      console.error('âŒ åˆ†ç‚¹æ ‡é¢˜ä¸ºç©ºï¼Œè·³è¿‡æ­¤åˆ†ç‚¹');
      return;
    }

    selectedPoints.push({
      title,
      content,
      keywords
    });
  });

  console.log('ğŸ” æœ€ç»ˆé€‰ä¸­çš„åˆ†ç‚¹:', selectedPoints);
  console.log('ğŸ” æœ‰æ•ˆåˆ†ç‚¹æ•°é‡:', selectedPoints.length);

  if (selectedPoints.length > 0) {
    console.log('ğŸš€ è°ƒç”¨ addStructuredPointsï¼Œä¼ å…¥æ•°æ®:', selectedPoints);
    addStructuredPoints(selectedPoints);
  } else {
    console.error('âŒ æ²¡æœ‰æœ‰æ•ˆçš„åˆ†ç‚¹æ•°æ®');
    showNotification('âŒ æ²¡æœ‰æœ‰æ•ˆçš„åˆ†ç‚¹æ•°æ®', 'error');
  }
}

// é€šçŸ¥ç³»ç»Ÿ
function showNotification(message, type = 'info') {
  // åˆ›å»ºé€šçŸ¥å…ƒç´ 
  const notification = document.createElement('div');
  notification.className = `notification notification-${type}`;
  notification.textContent = message;

  // æ·»åŠ æ ·å¼
  notification.style.cssText = `
    position: fixed;
    top: 20px;
    right: 20px;
    padding: 12px 20px;
    border-radius: 6px;
    color: white;
    font-size: 14px;
    z-index: 10002;
    max-width: 300px;
    word-wrap: break-word;
    animation: slideInRight 0.3s ease;
  `;

  // æ ¹æ®ç±»å‹è®¾ç½®é¢œè‰²
  switch (type) {
    case 'success':
      notification.style.backgroundColor = '#67c23a';
      break;
    case 'error':
      notification.style.backgroundColor = '#f56c6c';
      break;
    case 'warning':
      notification.style.backgroundColor = '#e6a23c';
      break;
    default:
      notification.style.backgroundColor = '#409eff';
  }

  document.body.appendChild(notification);

  // 3ç§’åè‡ªåŠ¨ç§»é™¤
  setTimeout(() => {
    if (notification.parentNode) {
      notification.style.animation = 'slideOutRight 0.3s ease';
      setTimeout(() => {
        if (notification.parentNode) {
          notification.parentNode.removeChild(notification);
        }
      }, 300);
    }
  }, 3000);
}

// é¡µé¢åŠ è½½å®Œæˆååˆå§‹åŒ–
document.addEventListener('DOMContentLoaded', function() {
  // å»¶è¿Ÿåˆå§‹åŒ–ï¼Œç¡®ä¿Vueåº”ç”¨å·²åŠ è½½
  setTimeout(initAIChat, 1000);
});
</script>

<script>const getDataFromBackend = () => {
        return new Promise((resolve, reject) => {
          setTimeout(() => {
            resolve({
              mindMapData: {
                root: {
                  data: {
                    text: 'æ ¹èŠ‚ç‚¹'
                  },
                  children: []
                },
                theme: {
                  template: 'avocado',
                  config: {}
                },
                layout: 'logicalStructure',
                config: {},
                view: null
              },
              mindMapConfig: {},
              lang: 'zh',
              localConfig: null
            })
          }, 200)
        })
      }
      const setTakeOverAppMethods = data => {
        window.takeOverAppMethods = {}
        // è·å–æ€ç»´å¯¼å›¾æ•°æ®çš„å‡½æ•°
        window.takeOverAppMethods.getMindMapData = () => {
          return data.mindMapData
        }
        // ä¿å­˜æ€ç»´å¯¼å›¾æ•°æ®çš„å‡½æ•°
        window.takeOverAppMethods.saveMindMapData = data => {
          console.log(data)
        }
        // è·å–æ€ç»´å¯¼å›¾é…ç½®ï¼Œä¹Ÿå°±æ˜¯å®ä¾‹åŒ–æ—¶ä¼šä¼ å…¥çš„é€‰é¡¹
        window.takeOverAppMethods.getMindMapConfig = () => {
          return data.mindMapConfig
        }
        // ä¿å­˜æ€ç»´å¯¼å›¾é…ç½®
        window.takeOverAppMethods.saveMindMapConfig = config => {
          console.log(config)
        }
        // è·å–è¯­è¨€çš„å‡½æ•°
        window.takeOverAppMethods.getLanguage = () => {
          return data.lang
        }
        // ä¿å­˜è¯­è¨€çš„å‡½æ•°
        window.takeOverAppMethods.saveLanguage = lang => {
          console.log(lang)
        }
        // è·å–æœ¬åœ°é…ç½®çš„å‡½æ•°
        window.takeOverAppMethods.getLocalConfig = () => {
          return data.localConfig
        }
        // ä¿å­˜æœ¬åœ°é…ç½®çš„å‡½æ•°
        window.takeOverAppMethods.saveLocalConfig = config => {
          console.log(config)
        }
      }
      window.onload = async () => {
        console.log('ğŸ” window.onload è¢«è°ƒç”¨ï¼ŒtakeOverApp:', window.takeOverApp);

        // ä¿®å¤ï¼šç¡®ä¿æ€ç»´å¯¼å›¾èƒ½å¤Ÿåˆå§‹åŒ–
        if (!window.takeOverApp) {
          console.log('âš ï¸ takeOverAppä¸ºfalseï¼Œä½†ä»ç„¶å°è¯•åˆå§‹åŒ–æ€ç»´å¯¼å›¾');
          // ä¸è¦ç›´æ¥returnï¼Œè€Œæ˜¯å°è¯•åˆå§‹åŒ–
        }

        // è¯·æ±‚æ•°æ®
        const data = await getDataFromBackend()
        console.log('ğŸ” è·å–åˆ°åç«¯æ•°æ®:', data);

        // è®¾ç½®å…¨å±€çš„æ–¹æ³•
        setTakeOverAppMethods(data)
        console.log('ğŸ” è®¾ç½®å…¨å±€æ–¹æ³•å®Œæˆ');

        // æ€ç»´å¯¼å›¾å®ä¾‹åˆ›å»ºå®Œæˆäº‹ä»¶
        if (window.$bus && window.$bus.$on) {
          window.$bus.$on('app_inited', mindMap => {
            console.log('ğŸ‰ æ€ç»´å¯¼å›¾å®ä¾‹åˆ›å»ºå®Œæˆ:', mindMap);
            window.mindMapInstance = mindMap;
          });
        }

        // å¯ä»¥é€šè¿‡window.$bus.$on()æ¥ç›‘å¬åº”ç”¨çš„ä¸€äº›äº‹ä»¶
        // å®ä¾‹åŒ–é¡µé¢
        if (window.initApp && typeof window.initApp === 'function') {
          console.log('ğŸš€ è°ƒç”¨ initApp');
          window.initApp();
        } else {
          console.log('âš ï¸ initApp å‡½æ•°ä¸å­˜åœ¨');
        }
      }</script><script src="dist/js/chunk-vendors.js?685589f1058f5fbca0d2"></script><script src="dist/js/app.js?685589f1058f5fbca0d2"></script></body></html>