<!DOCTYPE html><html lang=""><head><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,user-scalable=no,initial-scale=1,maximum-scale=1,minimum-scale=1"><link rel="icon" href="dist/logo.ico"><title>æ€ç»ªæ€ç»´å¯¼å›¾</title><script>// è‡ªå®šä¹‰é™æ€èµ„æºçš„è·¯å¾„
      window.externalPublicPath = './dist/'
      // æ¥ç®¡åº”ç”¨
      window.takeOverApp = false</script><script charset="UTF-8" id="LA_COLLECT" src="//sdk.51.la/js-sdk-pro.min.js"></script><script>try {
        LA.init({
          id: 'KRO0WxK8GT66tYCQ',
          ck: 'KRO0WxK8GT66tYCQ',
          autoTrack: false
        })
      } catch (error) {
        console.log(error)
      }</script><link href="dist/css/chunk-vendors.css?685589f1058f5fbca0d2" rel="stylesheet"><link href="dist/css/app.css?685589f1058f5fbca0d2" rel="stylesheet"></head><body><noscript><strong>We're sorry but thoughts doesn't work properly without JavaScript enabled. Please enable it to continue.</strong></noscript><div id="app"></div>

<!-- å¼•å…¥marked.js Markdownè§£æåº“ -->
<script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>

<!-- AIèŠå¤©æµ®çª— -->
<div id="aiChatBot" class="ai-chat-bot" style="display: none;">
  <div class="chat-header" onclick="toggleMinimize()">
    <div class="header-left">
      <span class="ai-icon">ğŸ¤–</span>
      <span class="title">AIåŠ©æ‰‹</span>
      <span id="contextInfo" class="context-info"></span>
    </div>
    <div class="header-actions">
      <button onclick="syncCurrentActiveNode()" title="åŒæ­¥å½“å‰é€‰ä¸­èŠ‚ç‚¹" style="background: #4CAF50; color: white; border: none; border-radius: 4px; padding: 4px 6px; margin-right: 4px;">ğŸ”„</button>
      <button onclick="clearMessages()" title="æ¸…é™¤è®°å½•">ğŸ—‘ï¸</button>
      <button onclick="showConfig()" title="è®¾ç½®">âš™ï¸</button>
      <button onclick="toggleMinimize()" id="minimizeBtn" title="æœ€å°åŒ–">â¬‡ï¸</button>
    </div>
  </div>

  <div id="chatMessages" class="chat-messages">
    <div class="welcome-message">
      <div class="welcome-content">
        <span class="ai-icon">ğŸ¤–</span>
        <h3>AIæ€ç»´å¯¼å›¾åŠ©æ‰‹</h3>
        <p>ç‚¹å‡»æ€ç»´å¯¼å›¾èŠ‚ç‚¹å¼€å§‹å¯¹è¯</p>
      </div>
    </div>
  </div>

  <div id="chatInput" class="chat-input">
    <div class="input-container">
      <textarea
        id="messageInput"
        class="message-input"
        placeholder="è¯·å…ˆé€‰æ‹©æ€ç»´å¯¼å›¾èŠ‚ç‚¹"
        rows="2"
        onkeydown="handleKeyDown(event)"
      ></textarea>
      <div class="input-actions">
        <button id="sendBtn" class="send-btn" onclick="sendMessage()">å‘é€</button>
      </div>
    </div>
  </div>
</div>

<!-- AIé…ç½®é¢æ¿ -->
<div id="aiConfigPanel" class="ai-config-panel" style="display: none;">
  <div class="config-header">
    <h4>AIé…ç½®</h4>
    <button onclick="closeConfig()">âŒ</button>
  </div>
  <div class="config-content">
    <div class="config-item">
      <label>AIæä¾›å•†:</label>
      <select id="aiProvider">
        <option value="openai">OpenAI</option>
        <option value="deepseek">DeepSeek</option>
        <option value="ollama">Ollama</option>
      </select>
    </div>
    <div class="config-item">
      <label>API Key:</label>
      <input id="apiKey" type="password" placeholder="è¯·è¾“å…¥API Key">
    </div>
    <div class="config-item">
      <label>æ¨¡å‹:</label>
      <input id="aiModel" placeholder="gpt-3.5-turbo">
    </div>
    <div class="config-item">
      <label>åŸºç¡€URL:</label>
      <input id="baseURL" placeholder="https://api.openai.com/v1">
    </div>
    <div class="config-item">
      <label>è‡ªå®šä¹‰æç¤ºè¯ (å¯é€‰):</label>
      <textarea id="customPrompt" rows="4" placeholder="è¾“å…¥è‡ªå®šä¹‰ç³»ç»Ÿæç¤ºè¯ï¼Œç•™ç©ºåˆ™ä½¿ç”¨é»˜è®¤æç¤ºè¯"></textarea>
      <div class="config-tip">
        ç³»ç»Ÿä¼šè‡ªåŠ¨åœ¨æ‚¨çš„æç¤ºè¯æœ«å°¾æ·»åŠ JSONæ ¼å¼è¦æ±‚ï¼Œç¡®ä¿AIå›å¤åŒ…å«ç»“æ„åŒ–åˆ†ç‚¹ã€‚
      </div>
    </div>
    <div class="config-actions">
      <button onclick="saveConfig()">ä¿å­˜é…ç½®</button>
      <button onclick="testConnection()">æµ‹è¯•è¿æ¥</button>
      <button onclick="previewFullPrompt()">é¢„è§ˆå®Œæ•´æç¤ºè¯</button>
    </div>
  </div>
</div>

<style>
/* AIèŠå¤©æµ®çª—æ ·å¼ */
.ai-chat-bot {
  position: fixed;
  bottom: 20px;
  right: 20px;
  width: 50vw;
  max-width: 800px;
  min-width: 400px;
  max-height: 95vh;
  min-height: 400px;
  background: #fff;
  border-radius: 12px;
  box-shadow: 0 8px 32px rgba(0, 0, 0, 0.12);
  border: 1px solid #e8e8e8;
  display: flex;
  flex-direction: column;
  z-index: 10000;
  font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
  transition: all 0.3s ease;
  resize: both;
  overflow: hidden;
}

/* å“åº”å¼è®¾è®¡ */
@media (max-width: 768px) {
  .ai-chat-bot {
    width: calc(100vw - 20px);
    height: 95vh;
    max-height: 95vh;
    bottom: 10px;
    right: 10px;
    left: 10px;
    resize: none;
    border-radius: 8px;
  }

  .ai-chat-bot.minimized {
    height: 50px;
    max-height: 50px;
    min-height: 50px;
  }
}

@media (max-width: 480px) {
  .ai-chat-bot {
    width: 100vw;
    height: 100vh;
    max-height: 100vh;
    bottom: 0;
    right: 0;
    left: 0;
    top: 0;
    border-radius: 0;
    resize: none;
  }

  .ai-chat-bot.minimized {
    height: 60px;
    max-height: 60px;
    min-height: 60px;
    top: auto;
    bottom: 0;
  }
}

.ai-chat-bot.minimized {
  max-height: 50px;
  min-height: 50px;
  height: 50px;
  resize: none;
}

.ai-chat-bot.minimized .chat-messages,
.ai-chat-bot.minimized .chat-input {
  display: none;
}

.chat-header {
  display: flex;
  align-items: center;
  justify-content: space-between;
  padding: 12px 16px;
  background: #f8f9fa;
  border-bottom: 1px solid #e8e8e8;
  border-radius: 12px 12px 0 0;
  cursor: pointer;
  user-select: none;
}

.header-left {
  display: flex;
  align-items: center;
  flex: 1;
  min-width: 0;
}

.ai-icon {
  font-size: 18px;
  margin-right: 8px;
}

.title {
  font-weight: 600;
  color: #333;
  margin-right: 8px;
}

.context-info {
  font-size: 12px;
  color: #666;
  overflow: hidden;
  text-overflow: ellipsis;
  white-space: nowrap;
}

.header-actions {
  display: flex;
  align-items: center;
  gap: 4px;
}

.header-actions button {
  background: none;
  border: none;
  cursor: pointer;
  padding: 4px;
  border-radius: 4px;
  font-size: 14px;
}

.header-actions button:hover {
  background: rgba(0, 0, 0, 0.1);
}

.chat-messages {
  flex: 1;
  padding: 16px;
  overflow-y: auto;
  min-height: 300px;
  max-height: calc(95vh - 200px);
  background: #fff;
}

.welcome-message {
  text-align: center;
  padding: 20px;
  color: #666;
}

.welcome-content .ai-icon {
  font-size: 32px;
  margin-bottom: 12px;
  display: block;
}

.welcome-content h3 {
  margin: 0 0 8px 0;
  color: #333;
  font-size: 16px;
}

.welcome-content p {
  margin: 0 0 16px 0;
  font-size: 14px;
}

.quick-actions {
  display: flex;
  flex-wrap: wrap;
  gap: 8px;
  justify-content: center;
}

.quick-actions button {
  padding: 6px 12px;
  background: #409eff;
  color: white;
  border: none;
  border-radius: 16px;
  cursor: pointer;
  font-size: 12px;
}

.quick-actions button:hover {
  background: #337ecc;
}

.message-item {
  display: flex;
  margin-bottom: 16px;
  align-items: flex-start;
}

.message-item.user {
  flex-direction: row-reverse;
}

.message-item.user .message-content {
  background: #409eff;
  color: #fff;
  margin-right: 12px;
  margin-left: 0;
}

.message-item.assistant .message-content {
  background: #f5f5f5;
  color: #333;
  margin-left: 12px;
}

.message-item.system {
  justify-content: center;
}

.message-item.system .message-content {
  background: #e8f4fd;
  color: #409eff;
  font-size: 12px;
  padding: 8px 12px;
  border-radius: 16px;
  margin: 0;
}

.message-avatar {
  width: 32px;
  height: 32px;
  border-radius: 50%;
  background: #fff;
  border: 1px solid #e8e8e8;
  display: flex;
  align-items: center;
  justify-content: center;
  flex-shrink: 0;
  font-size: 16px;
}

.message-content {
  max-width: 280px;
  padding: 12px 16px;
  border-radius: 12px;
  position: relative;
}

/* AIå›å¤ä½¿ç”¨æ›´å¤§çš„å®½åº¦ */
.message-item.assistant .message-content {
  max-width: calc(100% - 60px);
}

.message-text {
  font-size: 14px;
  line-height: 1.5;
  word-wrap: break-word;
  white-space: pre-wrap;
}

/* Markdownæ ·å¼ */
.message-text h1, .message-text h2, .message-text h3,
.message-text h4, .message-text h5, .message-text h6 {
  margin: 8px 0 4px 0;
  font-weight: 600;
  color: #333;
  line-height: 1.3;
}

.message-text h1 { font-size: 18px; }
.message-text h2 { font-size: 16px; }
.message-text h3 { font-size: 15px; }
.message-text h4, .message-text h5, .message-text h6 { font-size: 14px; }

.message-text p {
  margin: 2px 0;
  line-height: 1.3;
}

.message-text ul, .message-text ol {
  margin: 2px 0;
  padding-left: 16px;
}

.message-text li {
  margin: 1px 0;
  line-height: 1.3;
}

.message-text code {
  background: #f5f5f5;
  padding: 2px 4px;
  border-radius: 3px;
  font-family: 'Monaco', 'Menlo', 'Ubuntu Mono', monospace;
  font-size: 13px;
  color: #e83e8c;
}

.message-text pre {
  background: #f8f9fa;
  border: 1px solid #e8e8e8;
  border-radius: 6px;
  padding: 12px;
  margin: 8px 0;
  overflow-x: auto;
  font-family: 'Monaco', 'Menlo', 'Ubuntu Mono', monospace;
  font-size: 13px;
  line-height: 1.4;
}

.message-text pre code {
  background: none;
  padding: 0;
  color: inherit;
}

.message-text blockquote {
  border-left: 4px solid #409eff;
  margin: 8px 0;
  padding: 8px 12px;
  background: #f8f9fa;
  color: #666;
  font-style: italic;
}

.message-text strong {
  font-weight: 600;
  color: #333;
}

.message-text em {
  font-style: italic;
  color: #666;
}

.message-text table {
  border-collapse: collapse;
  width: 100%;
  margin: 8px 0;
  font-size: 13px;
}

.message-text th, .message-text td {
  border: 1px solid #e8e8e8;
  padding: 6px 8px;
  text-align: left;
}

.message-text th {
  background: #f8f9fa;
  font-weight: 600;
}

.suggestions {
  margin-top: 12px;
  padding-top: 12px;
  border-top: 1px solid rgba(0, 0, 0, 0.1);
}

.suggestions-title {
  font-size: 12px;
  color: #666;
  margin-bottom: 8px;
}

.suggestions-list {
  display: flex;
  flex-wrap: wrap;
  gap: 6px;
}

.suggestion-btn {
  font-size: 12px;
  padding: 4px 8px;
  background: #409eff;
  color: white;
  border: none;
  border-radius: 12px;
  cursor: pointer;
}

.suggestion-btn:hover {
  background: #337ecc;
}

.chat-input {
  border-top: 1px solid #e8e8e8;
  padding: 16px;
  background: #fff;
  border-radius: 0 0 12px 12px;
}

.input-container {
  display: flex;
  flex-direction: row;
  gap: 12px;
  align-items: flex-end;
}

.message-input {
  flex: 1;
  border: 1px solid #e8e8e8;
  border-radius: 8px;
  padding: 12px 16px;
  font-size: 14px;
  resize: vertical;
  outline: none;
  font-family: inherit;
  min-height: 60px;
  max-height: 120px;
  line-height: 1.5;
  transition: border-color 0.3s ease;
}

.message-input:focus {
  border-color: #409eff;
  box-shadow: 0 0 0 2px rgba(64, 158, 255, 0.1);
}

.message-input:disabled {
  background: #f5f5f5;
  color: #999;
  cursor: not-allowed;
}

.message-input::placeholder {
  color: #999;
  font-size: 13px;
}

.input-actions {
  display: flex;
  flex-direction: column;
  gap: 8px;
}

.send-btn {
  padding: 12px 20px;
  background: #409eff;
  color: white;
  border: none;
  border-radius: 8px;
  cursor: pointer;
  font-size: 14px;
  font-weight: 500;
  min-height: 60px;
  white-space: nowrap;
  transition: background-color 0.3s ease;
}

.send-btn:hover:not(:disabled) {
  background: #337ecc;
}

.send-btn:disabled {
  background: #ccc;
  cursor: not-allowed;
}

/* æ‰‹æœºç‰ˆä¼˜åŒ–å‘é€æŒ‰é’® */
@media (max-width: 480px) {
  .send-btn {
    min-height: 50px;
    padding: 10px 16px;
    font-size: 16px;
  }
}

/* AIé…ç½®é¢æ¿æ ·å¼ */
.ai-config-panel {
  position: fixed;
  bottom: 20px;
  right: calc(50vw + 40px);
  width: 350px;
  max-width: calc(50vw - 60px);
  background: white;
  border-radius: 12px;
  box-shadow: 0 8px 32px rgba(0, 0, 0, 0.12);
  border: 1px solid #e8e8e8;
  z-index: 10001;
  font-family: inherit;
}

/* å“åº”å¼è®¾è®¡ - é…ç½®é¢æ¿ */
@media (max-width: 1200px) {
  .ai-config-panel {
    right: 20px;
    bottom: calc(80vh + 40px);
  }
}

@media (max-width: 768px) {
  .ai-config-panel {
    right: 20px;
    left: 20px;
    width: auto;
    bottom: calc(100vh - 40px);
  }
}

@media (max-width: 480px) {
  .ai-config-panel {
    right: 0;
    left: 0;
    width: 100vw;
    bottom: 100vh;
    border-radius: 0;
  }
}

.config-header {
  display: flex;
  justify-content: space-between;
  align-items: center;
  padding: 16px;
  border-bottom: 1px solid #e8e8e8;
  background: #f8f9fa;
  border-radius: 12px 12px 0 0;
}

.config-header h4 {
  margin: 0;
  color: #333;
}

.config-header button {
  background: none;
  border: none;
  cursor: pointer;
  font-size: 16px;
}

.config-content {
  padding: 16px;
}

.config-item {
  margin-bottom: 16px;
}

.config-item label {
  display: block;
  margin-bottom: 4px;
  font-size: 14px;
  color: #333;
}

.config-item input,
.config-item select,
.config-item textarea {
  width: 100%;
  padding: 8px 12px;
  border: 1px solid #e8e8e8;
  border-radius: 6px;
  font-size: 14px;
  font-family: inherit;
  resize: vertical;
}

.config-item textarea {
  min-height: 80px;
  line-height: 1.5;
}

.config-tip {
  font-size: 12px;
  color: #666;
  margin-top: 4px;
  line-height: 1.4;
}

.config-actions {
  display: flex;
  gap: 8px;
  margin-top: 20px;
}

.config-actions button {
  flex: 1;
  padding: 10px;
  border: none;
  border-radius: 6px;
  cursor: pointer;
  font-size: 14px;
}

.config-actions button:first-child {
  background: #409eff;
  color: white;
}

.config-actions button:last-child {
  background: #f5f5f5;
  color: #333;
}

.loading {
  animation: pulse 1.5s ease-in-out infinite;
}

/* ç»“æ„åŒ–åˆ†ç‚¹æ ·å¼ */
.structured-points {
  margin-top: 12px;
  padding-top: 12px;
  border-top: 1px solid rgba(0, 0, 0, 0.1);
}

.points-header {
  display: flex;
  justify-content: space-between;
  align-items: center;
  margin-bottom: 12px;
}

.points-title {
  font-size: 12px;
  color: #666;
  font-weight: 600;
}

.points-actions {
  display: flex;
  gap: 6px;
}

.select-all-btn,
.add-selected-btn {
  font-size: 11px;
  padding: 3px 8px;
  border: 1px solid #409eff;
  background: white;
  color: #409eff;
  border-radius: 10px;
  cursor: pointer;
}

.select-all-btn:hover,
.add-selected-btn:hover {
  background: #409eff;
  color: white;
}

.add-selected-btn {
  background: #409eff;
  color: white;
}

.add-selected-btn:hover {
  background: #337ecc;
}

.points-list {
  display: flex;
  flex-direction: column;
  gap: 8px;
}

.structured-point {
  border: 1px solid #e8e8e8;
  border-radius: 6px;
  padding: 8px;
  background: #fafafa;
}

.point-header {
  display: flex;
  align-items: center;
  gap: 6px;
  margin-bottom: 4px;
}

.point-checkbox {
  margin: 0;
  cursor: pointer;
}

.point-title {
  font-size: 13px;
  font-weight: 600;
  color: #333;
  cursor: pointer;
  margin: 0;
}

.point-content {
  font-size: 12px;
  color: #666;
  line-height: 1.4;
  margin-bottom: 6px;
  padding-left: 20px;
}

.point-keywords {
  display: flex;
  flex-wrap: wrap;
  gap: 4px;
  padding-left: 20px;
}

.keyword {
  font-size: 10px;
  padding: 2px 6px;
  background: #e8f4fd;
  color: #409eff;
  border-radius: 8px;
  border: 1px solid #b3d8ff;
}

/* é€‰ä¸­èŠ‚ç‚¹æ˜¾ç¤ºæ ·å¼ */
.selected-node-display {
  padding: 12px 16px;
  background: linear-gradient(135deg, #e8f4fd 0%, #f0f8ff 100%);
  border-bottom: 1px solid #b3d8ff;
  display: none;
}

.selected-node-content {
  display: flex;
  flex-direction: column;
  gap: 6px;
}

.node-indicator {
  display: flex;
  align-items: center;
  gap: 6px;
}

.indicator-dot {
  width: 8px;
  height: 8px;
  background: #409eff;
  border-radius: 50%;
  animation: pulse-dot 2s infinite;
}

.indicator-text {
  font-size: 11px;
  color: #409eff;
  font-weight: 600;
  text-transform: uppercase;
  letter-spacing: 0.5px;
}

.node-text {
  font-size: 14px;
  font-weight: 600;
  color: #2c5aa0;
  margin: 2px 0;
}

.node-path {
  display: flex;
  align-items: center;
  gap: 6px;
  font-size: 11px;
}

.path-label {
  color: #666;
  font-weight: 500;
}

.path-text {
  color: #409eff;
  background: rgba(64, 158, 255, 0.1);
  padding: 2px 8px;
  border-radius: 10px;
  border: 1px solid rgba(64, 158, 255, 0.2);
  font-family: monospace;
}

@keyframes pulse-dot {
  0%, 100% {
    opacity: 1;
    transform: scale(1);
  }
  50% {
    opacity: 0.6;
    transform: scale(1.2);
  }
}

/* é€šçŸ¥åŠ¨ç”» */
@keyframes slideInRight {
  from {
    transform: translateX(100%);
    opacity: 0;
  }
  to {
    transform: translateX(0);
    opacity: 1;
  }
}

@keyframes slideOutRight {
  from {
    transform: translateX(0);
    opacity: 1;
  }
  to {
    transform: translateX(100%);
    opacity: 0;
  }
}

@keyframes pulse {
  0%, 100% { opacity: 1; }
  50% { opacity: 0.5; }
}

/* æ€è€ƒçŠ¶æ€åŠ¨ç”» - è·³åŠ¨çš„ç‚¹ */
@keyframes thinking-dots {
  0%, 20% {
    opacity: 0.3;
    transform: scale(1);
  }
  50% {
    opacity: 1;
    transform: scale(1.2);
  }
  100% {
    opacity: 0.3;
    transform: scale(1);
  }
}

.thinking-dots {
  display: inline-block;
}

.thinking-dots .dot {
  display: inline-block;
  width: 4px;
  height: 4px;
  border-radius: 50%;
  background-color: #666;
  margin: 0 1px;
  animation: thinking-dots 1.4s infinite ease-in-out;
}

.thinking-dots .dot:nth-child(1) { animation-delay: 0s; }
.thinking-dots .dot:nth-child(2) { animation-delay: 0.2s; }
.thinking-dots .dot:nth-child(3) { animation-delay: 0.4s; }

/* æ‰“å­—æœºæ•ˆæœ */
.typewriter-text {
  overflow: hidden;
  border-right: 2px solid #409eff;
  white-space: nowrap;
  animation: typing 0.5s steps(1, end), blink-caret 1s step-end infinite;
}

@keyframes typing {
  from { width: 0; }
  to { width: 100%; }
}

@keyframes blink-caret {
  from, to { border-color: transparent; }
  50% { border-color: #409eff; }
}

/* æ¨ç†æ¨¡å‹æ ·å¼ */
.reasoning-content {
  background: #f8f9fa;
  border-left: 3px solid #888;
  padding: 12px;
  margin: 8px 0;
  border-radius: 0 8px 8px 0;
  font-style: italic;
  color: #666;
  font-size: 13px;
  line-height: 1.4;
}

.reasoning-content::before {
  content: "ğŸ¤” æ€è€ƒè¿‡ç¨‹ï¼š";
  font-weight: 600;
  color: #888;
  display: block;
  margin-bottom: 6px;
  font-style: normal;
}

.final-answer {
  margin-top: 8px;
  padding-top: 8px;
  border-top: 1px solid #e8e8e8;
}

.final-answer::before {
  content: "âœ… æœ€ç»ˆå›ç­”ï¼š";
  font-weight: 600;
  color: #409eff;
  display: block;
  margin-bottom: 6px;
}
</style>

<script>
// AIèŠå¤©åŠŸèƒ½JavaScriptä»£ç 
let selectedNodeText = '';
let selectedNodeHierarchy = [];
let messages = [];
let isLoading = false;
let isMinimized = false;
let mindMapInstance = null;
let aiConfig = {
  provider: 'openai',
  apiKey: '',
  model: 'gpt-3.5-turbo',
  baseURL: 'https://api.openai.com/v1',
  customPrompt: ''
};

// åˆå§‹åŒ–AIèŠå¤©åŠŸèƒ½
function initAIChat() {
  // æ˜¾ç¤ºAIèŠå¤©æµ®çª—
  document.getElementById('aiChatBot').style.display = 'flex';

  // è®¾ç½®è°ƒè¯•æ¨¡å¼ï¼ˆå¯ä»¥é€šè¿‡URLå‚æ•°æˆ–localStorageæ§åˆ¶ï¼‰
  const urlParams = new URLSearchParams(window.location.search);
  window.debugMode = urlParams.get('debug') === 'true' || localStorage.getItem('ai_debug_mode') === 'true';

  if (window.debugMode) {
    console.log('ğŸ› AIè°ƒè¯•æ¨¡å¼å·²å¯ç”¨');
    console.log('ğŸ’¡ æç¤ºï¼šåœ¨æµè§ˆå™¨åœ°å€æ æ·»åŠ  ?debug=false å¯å…³é—­è°ƒè¯•æ¨¡å¼');
    console.log('ğŸ’¡ æˆ–è€…åœ¨æ§åˆ¶å°è¾“å…¥ toggleDebugMode() æ¥åˆ‡æ¢è°ƒè¯•æ¨¡å¼');
  }

  // æä¾›å…¨å±€å‡½æ•°æ¥åˆ‡æ¢è°ƒè¯•æ¨¡å¼
  window.toggleDebugMode = function(enable) {
    if (typeof enable === 'boolean') {
      window.debugMode = enable;
    } else {
      window.debugMode = !window.debugMode;
    }

    localStorage.setItem('ai_debug_mode', window.debugMode.toString());

    if (window.debugMode) {
      console.log('ğŸ› AIè°ƒè¯•æ¨¡å¼å·²å¯ç”¨');
    } else {
      console.log('ğŸ”‡ AIè°ƒè¯•æ¨¡å¼å·²å…³é—­');
    }
  };

  // åŠ è½½AIé…ç½®
  loadAIConfig();

  // ç›‘å¬æ€ç»´å¯¼å›¾äº‹ä»¶
  if (window.$bus) {
    window.$bus.$on('app_inited', (mindMap) => {
      console.log('æ€ç»´å¯¼å›¾åˆå§‹åŒ–å®Œæˆ:', mindMap);
      mindMapInstance = mindMap;
      window.mindMapInstance = mindMapInstance; // ç¡®ä¿è®¾ç½®åˆ°å…¨å±€
      bindMindMapEvents(mindMap);
    });
  }

  // å¢å¼ºçš„æ€ç»´å¯¼å›¾å®ä¾‹æ£€æµ‹
  const checkMindMapInstance = () => {
    // æ–¹æ³•1: æ£€æŸ¥å…¨å±€å˜é‡
    if (window.mindMap && !mindMapInstance) {
      console.log('ä»å…¨å±€è·å–æ€ç»´å¯¼å›¾å®ä¾‹:', window.mindMap);
      mindMapInstance = window.mindMap;
      window.mindMapInstance = mindMapInstance; // ç¡®ä¿è®¾ç½®åˆ°å…¨å±€
      bindMindMapEvents(mindMapInstance);
      return true;
    }

    if (window.app && window.app.mindMap && !mindMapInstance) {
      console.log('ä»appè·å–æ€ç»´å¯¼å›¾å®ä¾‹:', window.app.mindMap);
      mindMapInstance = window.app.mindMap;
      window.mindMapInstance = mindMapInstance; // ç¡®ä¿è®¾ç½®åˆ°å…¨å±€
      bindMindMapEvents(mindMapInstance);
      return true;
    }

    // æ–¹æ³•2: ä»Vueå®ä¾‹è·å–
    const mindMapContainer = document.querySelector('#app');
    if (mindMapContainer && mindMapContainer.__vue__) {
      const vueInstance = mindMapContainer.__vue__;

      // æ£€æŸ¥Vueå®ä¾‹çš„å­ç»„ä»¶
      if (vueInstance.$children && vueInstance.$children.length > 0) {
        for (let child of vueInstance.$children) {
          if (child.mindMap && !mindMapInstance) {
            console.log('ä»Vueå­ç»„ä»¶è·å–æ€ç»´å¯¼å›¾å®ä¾‹:', child.mindMap);
            mindMapInstance = child.mindMap;
            window.mindMapInstance = mindMapInstance; // ç¡®ä¿è®¾ç½®åˆ°å…¨å±€
            bindMindMapEvents(mindMapInstance);
            return true;
          }

          // æ·±åº¦æ£€æŸ¥å­ç»„ä»¶çš„å­ç»„ä»¶
          if (child.$children && child.$children.length > 0) {
            for (let grandChild of child.$children) {
              if (grandChild.mindMap && !mindMapInstance) {
                console.log('ä»Vueå­™ç»„ä»¶è·å–æ€ç»´å¯¼å›¾å®ä¾‹:', grandChild.mindMap);
                mindMapInstance = grandChild.mindMap;
                window.mindMapInstance = mindMapInstance; // ç¡®ä¿è®¾ç½®åˆ°å…¨å±€
                bindMindMapEvents(mindMapInstance);
                return true;
              }
            }
          }
        }
      }
    }

    // æ–¹æ³•3: é€šè¿‡DOMäº‹ä»¶ç›‘å¬è·å–
    if (!mindMapInstance) {
      setupDOMEventListeners();
    }

    return false;
  };

  // è®¾ç½®DOMäº‹ä»¶ç›‘å¬å™¨æ¥æ•è·æ€ç»´å¯¼å›¾äº¤äº’
  const setupDOMEventListeners = () => {
    const svgElements = document.querySelectorAll('svg');
    svgElements.forEach(svg => {
      // ç›‘å¬SVGç‚¹å‡»äº‹ä»¶
      svg.addEventListener('click', (e) => {
        // å°è¯•ä»äº‹ä»¶ä¸­è·å–æ€ç»´å¯¼å›¾å®ä¾‹
        setTimeout(() => {
          tryGetMindMapFromDOM();
        }, 100);
      });
    });
  };

  // ä»DOMçŠ¶æ€å°è¯•è·å–æ€ç»´å¯¼å›¾å®ä¾‹
  const tryGetMindMapFromDOM = () => {
    if (mindMapInstance) return;

    const mindMapContainer = document.querySelector('#app');
    if (mindMapContainer && mindMapContainer.__vue__) {
      const vueInstance = mindMapContainer.__vue__;

      // é€’å½’æœç´¢æ‰€æœ‰Vueç»„ä»¶å®ä¾‹
      const findMindMapInVueTree = (component) => {
        if (component.mindMap) {
          return component.mindMap;
        }

        if (component.$children) {
          for (let child of component.$children) {
            const result = findMindMapInVueTree(child);
            if (result) return result;
          }
        }

        return null;
      };

      const foundMindMap = findMindMapInVueTree(vueInstance);
      if (foundMindMap) {
        console.log('é€šè¿‡é€’å½’æœç´¢æ‰¾åˆ°æ€ç»´å¯¼å›¾å®ä¾‹:', foundMindMap);
        mindMapInstance = foundMindMap;
        window.mindMapInstance = mindMapInstance; // ç¡®ä¿è®¾ç½®åˆ°å…¨å±€
        bindMindMapEvents(mindMapInstance);

        // ç«‹å³å°è¯•åŒæ­¥å½“å‰æ¿€æ´»èŠ‚ç‚¹
        setTimeout(() => {
          syncCurrentActiveNode();
        }, 500);
      }
    }
  };

  // å®šæœŸæ£€æŸ¥æ€ç»´å¯¼å›¾å®ä¾‹
  const checkInterval = setInterval(() => {
    if (checkMindMapInstance()) {
      clearInterval(checkInterval);
    }
  }, 1000);

  // 10ç§’ååœæ­¢æ£€æŸ¥
  setTimeout(() => {
    clearInterval(checkInterval);
    // å¦‚æœè¿˜æ²¡æ‰¾åˆ°ï¼Œå°è¯•æœ€åä¸€æ¬¡DOMæœç´¢
    if (!mindMapInstance) {
      console.log('æœ€åå°è¯•ä»DOMè·å–æ€ç»´å¯¼å›¾å®ä¾‹...');
      tryGetMindMapFromDOM();
    }
  }, 10000);
}

// ç»‘å®šæ€ç»´å¯¼å›¾äº‹ä»¶
function bindMindMapEvents(mindMap) {
  console.log('ç»‘å®šæ€ç»´å¯¼å›¾äº‹ä»¶', mindMap);

  // ç›‘å¬èŠ‚ç‚¹ç‚¹å‡»äº‹ä»¶
  mindMap.on('node_click', (node) => {
    console.log('èŠ‚ç‚¹è¢«ç‚¹å‡»:', node);
    updateSelectedNode(node);
  });

  // ç›‘å¬èŠ‚ç‚¹æ¿€æ´»äº‹ä»¶
  mindMap.on('node_active', (node, activeNodeList) => {
    console.log('èŠ‚ç‚¹æ¿€æ´»:', node, activeNodeList);
    if (activeNodeList && activeNodeList.length > 0) {
      updateSelectedNode(activeNodeList[0]);
    } else {
      selectedNodeText = '';
      selectedNodeHierarchy = [];
      updateContextInfo();
    }
  });

  // ç›‘å¬æ•°æ®å˜åŒ–äº‹ä»¶
  mindMap.on('data_change', (data) => {
    console.log('æ€ç»´å¯¼å›¾æ•°æ®å˜åŒ–:', data);
  });

  // æ·»åŠ å®šæ—¶æ£€æŸ¥æ¿€æ´»èŠ‚ç‚¹çš„æœºåˆ¶
  const checkActiveNodes = () => {
    try {
      if (mindMap.renderer && mindMap.renderer.activeNodeList) {
        const activeNodes = mindMap.renderer.activeNodeList;
        if (activeNodes.length > 0) {
          const currentActiveNode = activeNodes[0];
          let currentRawText = currentActiveNode.nodeData ?
            currentActiveNode.nodeData.data.text :
            (currentActiveNode.getData ? currentActiveNode.getData('text') : '');

          // æ¸…ç†HTMLæ ‡ç­¾ï¼Œè·å–çº¯æ–‡æœ¬ç”¨äºæ¯”è¾ƒ
          let currentCleanText = '';
          if (typeof currentRawText === 'string') {
            const tempDiv = document.createElement('div');
            tempDiv.innerHTML = currentRawText;
            currentCleanText = tempDiv.textContent || tempDiv.innerText || currentRawText;
          } else {
            // ç¡®ä¿currentCleanTextå§‹ç»ˆæ˜¯å­—ç¬¦ä¸²
            currentCleanText = String(currentRawText || '');
          }

          // å¦‚æœå½“å‰æ¿€æ´»èŠ‚ç‚¹ä¸è®°å½•çš„ä¸åŒï¼Œæ›´æ–°é€‰ä¸­èŠ‚ç‚¹
          if (currentCleanText && currentCleanText !== selectedNodeText) {
            // åªåœ¨è°ƒè¯•æ¨¡å¼ä¸‹è¾“å‡ºè¯¦ç»†ä¿¡æ¯
            if (window.debugMode) {
              console.log('æ£€æµ‹åˆ°æ–°çš„æ¿€æ´»èŠ‚ç‚¹:', currentRawText, '-> æ¸…ç†å:', currentCleanText);
            }
            updateSelectedNode(currentActiveNode);
          }
        }
      }
    } catch (error) {
      console.error('æ£€æŸ¥æ¿€æ´»èŠ‚ç‚¹å¤±è´¥:', error);
    }
  };

  // æ¯ç§’æ£€æŸ¥ä¸€æ¬¡æ¿€æ´»èŠ‚ç‚¹
  setInterval(checkActiveNodes, 1000);
}

// æ›´æ–°é€‰ä¸­èŠ‚ç‚¹
function updateSelectedNode(node) {
  if (!node) {
    selectedNodeText = '';
    selectedNodeHierarchy = [];
    updateContextInfo();
    return;
  }

  try {
    // æ­£ç¡®è·å–èŠ‚ç‚¹æ–‡æœ¬ - å‚è€ƒai-mind-mapçš„å®ç°
    let rawText = node.nodeData ? node.nodeData.data.text : (node.getData ? node.getData('text') : '');

    // æ¸…ç†HTMLæ ‡ç­¾ï¼Œåªä¿ç•™çº¯æ–‡æœ¬
    if (typeof rawText === 'string') {
      // åˆ›å»ºä¸´æ—¶DOMå…ƒç´ æ¥è§£æHTML
      const tempDiv = document.createElement('div');
      tempDiv.innerHTML = rawText;
      selectedNodeText = tempDiv.textContent || tempDiv.innerText || rawText;
    } else {
      // ç¡®ä¿selectedNodeTextå§‹ç»ˆæ˜¯å­—ç¬¦ä¸²
      selectedNodeText = String(rawText || '');
    }

    selectedNodeHierarchy = getNodeHierarchy(node);
    updateContextInfo();
    showQuickActions();

    // åªåœ¨è°ƒè¯•æ¨¡å¼ä¸‹è¾“å‡ºè¯¦ç»†ä¿¡æ¯
    if (window.debugMode) {
      console.log('èŠ‚ç‚¹é€‰æ‹©æˆåŠŸ:', {
        text: selectedNodeText,
        hierarchy: selectedNodeHierarchy,
        node: node,
        nodeData: node.nodeData
      });
    }
  } catch (error) {
    console.error('è·å–èŠ‚ç‚¹ä¿¡æ¯å¤±è´¥:', error);
    selectedNodeText = '';
    selectedNodeHierarchy = [];
    updateContextInfo();
  }
}

// è·å–èŠ‚ç‚¹å±‚çº§è·¯å¾„
function getNodeHierarchy(node) {
  const hierarchy = [];
  let currentNode = node;

  while (currentNode) {
    try {
      // æ­£ç¡®è·å–èŠ‚ç‚¹æ–‡æœ¬ - å…¼å®¹ä¸åŒçš„èŠ‚ç‚¹æ•°æ®ç»“æ„
      let rawText = '';
      if (currentNode.nodeData && currentNode.nodeData.data) {
        rawText = currentNode.nodeData.data.text || '';
      } else if (currentNode.getData) {
        rawText = currentNode.getData('text') || '';
      }

      // æ¸…ç†HTMLæ ‡ç­¾ï¼Œåªä¿ç•™çº¯æ–‡æœ¬
      let text = '';
      if (typeof rawText === 'string') {
        const tempDiv = document.createElement('div');
        tempDiv.innerHTML = rawText;
        text = tempDiv.textContent || tempDiv.innerText || rawText;
      } else {
        // ç¡®ä¿textå§‹ç»ˆæ˜¯å­—ç¬¦ä¸²
        text = String(rawText || '');
      }

      if (text) {
        hierarchy.unshift(text);
      }
      currentNode = currentNode.parent;
    } catch (error) {
      console.error('è·å–çˆ¶èŠ‚ç‚¹å¤±è´¥:', error);
      break;
    }
  }

  return hierarchy;
}

// è·å–èŠ‚ç‚¹é“¾è·¯çš„è¯¦ç»†ä¿¡æ¯ï¼ˆåŒ…æ‹¬å¤‡æ³¨ï¼‰
function getNodeHierarchyWithNotes(node) {
  const hierarchyWithNotes = [];
  let currentNode = node;

  while (currentNode) {
    try {
      // è·å–èŠ‚ç‚¹æ–‡æœ¬
      let rawText = '';
      if (currentNode.nodeData && currentNode.nodeData.data) {
        rawText = currentNode.nodeData.data.text || '';
      } else if (currentNode.getData) {
        rawText = currentNode.getData('text') || '';
      }

      // æ¸…ç†HTMLæ ‡ç­¾ï¼Œåªä¿ç•™çº¯æ–‡æœ¬
      let text = '';
      if (typeof rawText === 'string') {
        const tempDiv = document.createElement('div');
        tempDiv.innerHTML = rawText;
        text = tempDiv.textContent || tempDiv.innerText || rawText;
      } else {
        // ç¡®ä¿textå§‹ç»ˆæ˜¯å­—ç¬¦ä¸²
        text = String(rawText || '');
      }

      // è·å–èŠ‚ç‚¹å¤‡æ³¨
      let note = '';
      if (currentNode.nodeData && currentNode.nodeData.data) {
        note = currentNode.nodeData.data.note || '';
      } else if (currentNode.getData) {
        note = currentNode.getData('note') || '';
      }

      if (text) {
        hierarchyWithNotes.unshift({
          text: text,
          note: note
        });
      }
      currentNode = currentNode.parent;
    } catch (error) {
      console.error('è·å–çˆ¶èŠ‚ç‚¹è¯¦ç»†ä¿¡æ¯å¤±è´¥:', error);
      break;
    }
  }

  return hierarchyWithNotes;
}

// æ›´æ–°ä¸Šä¸‹æ–‡ä¿¡æ¯
function updateContextInfo() {
  const contextInfo = document.getElementById('contextInfo');
  const messageInput = document.getElementById('messageInput');

  if (selectedNodeText) {
    const hierarchyText = selectedNodeHierarchy.length > 1
      ? selectedNodeHierarchy.join(' â€º ')
      : selectedNodeText;
    contextInfo.textContent = `- ${selectedNodeText}`;
    contextInfo.title = `è·¯å¾„: ${hierarchyText}`;
    messageInput.placeholder = `è¯¢é—®å…³äº"${selectedNodeText}"çš„é—®é¢˜...`;

    // æ›´æ–°èŠå¤©çª—å£ä¸­çš„é€‰ä¸­èŠ‚ç‚¹æ˜¾ç¤º
    updateSelectedNodeDisplay();
  } else {
    contextInfo.textContent = '';
    contextInfo.title = '';
    messageInput.placeholder = 'è¯·å…ˆé€‰æ‹©æ€ç»´å¯¼å›¾èŠ‚ç‚¹';
    hideSelectedNodeDisplay();
  }
}

// æ›´æ–°é€‰ä¸­èŠ‚ç‚¹æ˜¾ç¤ºåŒºåŸŸ
function updateSelectedNodeDisplay() {
  let nodeDisplay = document.getElementById('selectedNodeDisplay');

  if (!nodeDisplay) {
    // åˆ›å»ºé€‰ä¸­èŠ‚ç‚¹æ˜¾ç¤ºåŒºåŸŸ
    nodeDisplay = document.createElement('div');
    nodeDisplay.id = 'selectedNodeDisplay';
    nodeDisplay.className = 'selected-node-display';

    const chatMessages = document.getElementById('chatMessages');
    if (chatMessages && chatMessages.parentNode) {
      chatMessages.parentNode.insertBefore(nodeDisplay, chatMessages);
    } else {
      // å¦‚æœæ‰¾ä¸åˆ°chatMessagesï¼Œå°è¯•æ’å…¥åˆ°èŠå¤©çª—å£ä¸­
      const chatWindow = document.getElementById('aiChatWindow');
      if (chatWindow) {
        const header = chatWindow.querySelector('.chat-header');
        if (header && header.nextSibling) {
          chatWindow.insertBefore(nodeDisplay, header.nextSibling);
        } else {
          chatWindow.appendChild(nodeDisplay);
        }
      }
    }
  }

  if (selectedNodeText && selectedNodeHierarchy.length > 0) {
    nodeDisplay.innerHTML = `
      <div class="selected-node-content">
        <div class="node-indicator">
          <div class="indicator-dot"></div>
          <span class="indicator-text">å½“å‰é€‰ä¸­èŠ‚ç‚¹</span>
        </div>
        <div class="node-text">${selectedNodeText}</div>
        <div class="node-path">
          <span class="path-label">è·¯å¾„:</span>
          <span class="path-text">${selectedNodeHierarchy.join(' â€º ')}</span>
        </div>
      </div>
    `;

    nodeDisplay.style.display = 'block';
    // åªåœ¨è°ƒè¯•æ¨¡å¼ä¸‹è¾“å‡º
    if (window.debugMode) {
      console.log('é€‰ä¸­èŠ‚ç‚¹æ˜¾ç¤ºåŒºåŸŸå·²æ›´æ–°:', selectedNodeText, selectedNodeHierarchy);
    }
  } else {
    nodeDisplay.style.display = 'none';
  }
}

// éšè—é€‰ä¸­èŠ‚ç‚¹æ˜¾ç¤º
function hideSelectedNodeDisplay() {
  const nodeDisplay = document.getElementById('selectedNodeDisplay');
  if (nodeDisplay) {
    nodeDisplay.style.display = 'none';
  }
}

// æ˜¾ç¤ºå¿«é€Ÿæ“ä½œ
function showQuickActions() {
  if (!selectedNodeText) return;

  const welcomeMessage = document.querySelector('.welcome-message');
  if (welcomeMessage && messages.length === 0) {
    welcomeMessage.innerHTML = `
      <div class="welcome-content">
        <span class="ai-icon">ğŸ¤–</span>
        <h3>AIæ€ç»´å¯¼å›¾åŠ©æ‰‹</h3>
        <p>å½“å‰é€‰ä¸­ï¼š${selectedNodeText}</p>
        <div class="quick-actions">
          <button onclick="sendQuickMessage('æ‰©å±•è¿™ä¸ªèŠ‚ç‚¹')">æ‰©å±•èŠ‚ç‚¹</button>
          <button onclick="sendQuickMessage('è§£é‡Šè¿™ä¸ªæ¦‚å¿µ')">è§£é‡Šæ¦‚å¿µ</button>
          <button onclick="sendQuickMessage('ç›¸å…³åº”ç”¨åœºæ™¯')">åº”ç”¨åœºæ™¯</button>
        </div>
      </div>
    `;
  }
}

// å‘é€å¿«é€Ÿæ¶ˆæ¯
function sendQuickMessage(message) {
  document.getElementById('messageInput').value = message;
  sendMessage();
}

// å‘é€æ¶ˆæ¯
async function sendMessage() {
  const input = document.getElementById('messageInput');
  const message = input.value.trim();

  if (!message || isLoading) return;

  input.value = '';

  // æ·»åŠ ç”¨æˆ·æ¶ˆæ¯
  addMessage('user', message);

  // è®¾ç½®åŠ è½½çŠ¶æ€
  setLoading(true);

  try {
    // è°ƒç”¨AI APIæˆ–æ¨¡æ‹Ÿå›å¤
    const response = await callAI(message);

    // é€å­—è¾“å‡ºçš„æ¨¡æ‹Ÿå›å¤å·²ç»åœ¨streamResponseä¸­å¤„ç†äº†æ¶ˆæ¯æ˜¾ç¤º
    // çœŸå®APIçš„æµå¼å“åº”ä¹Ÿå·²ç»åœ¨callRealAIä¸­å¤„ç†äº†
    // è¿™é‡Œä¸éœ€è¦å†æ¬¡æ·»åŠ æ¶ˆæ¯
    console.log('âœ… AIå›å¤å®Œæˆ:', response);
  } catch (error) {
    console.error('AIå›å¤å¤±è´¥:', error);
    addMessage('assistant', 'æŠ±æ­‰ï¼Œæˆ‘ç°åœ¨æ— æ³•å›å¤ã€‚è¯·æ£€æŸ¥AIé…ç½®æˆ–ç¨åå†è¯•ã€‚');
  } finally {
    setLoading(false);
  }
}

// è°ƒç”¨AI API
async function callAI(message) {
  // å¦‚æœé…ç½®äº†çœŸå®çš„API Keyï¼Œè°ƒç”¨çœŸå®API
  if (aiConfig.apiKey && aiConfig.apiKey.trim()) {
    return await callRealAI(message);
  } else {
    // å¦åˆ™ä½¿ç”¨é€å­—è¾“å‡ºçš„æ¨¡æ‹Ÿå›å¤
    return await simulateAIResponseStreaming(message);
  }
}

// è°ƒç”¨çœŸå®AI API
async function callRealAI(message) {
  const { provider, apiKey, model, baseURL } = aiConfig;

  // æ„å»ºç³»ç»Ÿæç¤ºè¯
  const systemPrompt = getSystemPrompt();

  const messages = [
    {
      role: 'system',
      content: systemPrompt
    },
    {
      role: 'user',
      content: message
    }
  ];

  // æ‰“å°è¯·æ±‚çš„promptåˆ°æ§åˆ¶å°
  console.log('=== LLM API è¯·æ±‚ ===');
  console.log('ğŸ”§ é…ç½®ä¿¡æ¯:', { provider, model, baseURL: baseURL.replace(/\/+$/, '') });
  console.log('ğŸ“ å®Œæ•´è¯·æ±‚æ¶ˆæ¯:', JSON.stringify(messages, null, 2));
  console.log('ğŸ’¬ ç”¨æˆ·æ¶ˆæ¯:', message);
  console.log('ğŸ¤– ç³»ç»Ÿæç¤ºè¯:', systemPrompt);

  // æ‰“å°èŠ‚ç‚¹é“¾è·¯çš„è¯¦ç»†ä¿¡æ¯
  if (mindMapInstance && mindMapInstance.renderer && mindMapInstance.renderer.activeNodeList && mindMapInstance.renderer.activeNodeList.length > 0) {
    const currentActiveNode = mindMapInstance.renderer.activeNodeList[0];
    const hierarchyWithNotes = getNodeHierarchyWithNotes(currentActiveNode);

    if (hierarchyWithNotes.length > 0) {
      console.log('ğŸ”— èŠ‚ç‚¹é“¾è·¯è¯¦ç»†ä¿¡æ¯:');
      hierarchyWithNotes.forEach((nodeInfo, index) => {
        console.log(`  ${index + 1}. èŠ‚ç‚¹: "${nodeInfo.text}"`);
        if (nodeInfo.note && nodeInfo.note.trim()) {
          console.log(`     å¤‡æ³¨: ${nodeInfo.note.trim()}`);
        }
      });
    }
  }

  console.log('==================');

  const requestBody = {
    model,
    messages,
    max_tokens: 2000,
    temperature: 0.7,
    stream: true
  };

  const response = await fetch(`${baseURL}/chat/completions`, {
    method: 'POST',
    headers: {
      'Content-Type': 'application/json',
      'Authorization': `Bearer ${apiKey}`
    },
    body: JSON.stringify(requestBody)
  });

  if (!response.ok) {
    console.error('âŒ APIè¯·æ±‚å¤±è´¥:', response.status, response.statusText);
    throw new Error(`APIè¯·æ±‚å¤±è´¥: ${response.status} ${response.statusText}`);
  }

  // å¤„ç†æµå¼å“åº”
  const reader = response.body.getReader();
  const decoder = new TextDecoder();
  let rawContent = '';
  let reasoning = '';
  let finalAnswer = '';
  let isReasoningModel = false;
  let buffer = '';

  // ç§»é™¤åŠ è½½æ¶ˆæ¯ï¼Œå‡†å¤‡æ˜¾ç¤ºæµå¼å†…å®¹
  const loadingMessage = document.getElementById('loadingMessage');
  if (loadingMessage) {
    loadingMessage.remove();
  }

  // åˆ›å»ºæµå¼æ¶ˆæ¯å®¹å™¨
  const messageId = 'msg_' + Date.now() + '_' + Math.random().toString(36).substr(2, 5);
  const streamingDiv = document.createElement('div');
  streamingDiv.className = 'message-item assistant';
  streamingDiv.id = messageId;
  streamingDiv.innerHTML = `
    <div class="message-avatar">ğŸ¤–</div>
    <div class="message-content">
      <div id="${messageId}_reasoning" class="reasoning-content" style="display: none;"></div>
      <div id="${messageId}_content" class="message-text"></div>
    </div>
  `;

  const messagesContainer = document.getElementById('chatMessages');
  messagesContainer.appendChild(streamingDiv);
  messagesContainer.scrollTop = messagesContainer.scrollHeight;

  const reasoningElement = document.getElementById(`${messageId}_reasoning`);
  const contentElement = document.getElementById(`${messageId}_content`);

  try {
    while (true) {
      const { done, value } = await reader.read();
      if (done) break;

      buffer += decoder.decode(value, { stream: true });
      const lines = buffer.split('\n');
      buffer = lines.pop(); // ä¿ç•™æœ€åä¸€è¡Œï¼ˆå¯èƒ½ä¸å®Œæ•´ï¼‰

      for (const line of lines) {
        if (line.startsWith('data: ')) {
          const data = line.slice(6);
          if (data === '[DONE]') continue;

          try {
            const parsed = JSON.parse(data);
            const delta = parsed.choices?.[0]?.delta;

            if (!delta) continue;

            // æ£€æµ‹æ˜¯å¦ä¸ºæ¨ç†æ¨¡å‹
            if (delta.reasoning_content !== undefined) {
              isReasoningModel = true;
              if (delta.reasoning_content) {
                reasoning += delta.reasoning_content;
                reasoningElement.textContent = reasoning;
                reasoningElement.style.display = 'block';
              }
            }

            if (delta.content) {
              rawContent += delta.content;
              finalAnswer += delta.content;

              // å®ç°æ‰“å­—æœºæ•ˆæœ
              await typewriterEffect(contentElement, delta.content);
            }

            // è‡ªåŠ¨æ»šåŠ¨åˆ°åº•éƒ¨
            messagesContainer.scrollTop = messagesContainer.scrollHeight;
          } catch (e) {
            console.warn('è§£ææµå¼æ•°æ®å¤±è´¥:', e, data);
          }
        }
      }
    }
  } catch (error) {
    console.error('æµå¼å¤„ç†å¤±è´¥:', error);
    contentElement.textContent = 'æŠ±æ­‰ï¼Œå¤„ç†å“åº”æ—¶å‡ºç°é”™è¯¯ã€‚';
  }

  // å¦‚æœæ˜¯æ¨ç†æ¨¡å‹ä½†æ²¡æœ‰æ£€æµ‹åˆ°reasoning_contentï¼Œå°è¯•ä»å†…å®¹ä¸­æå–
  if (!isReasoningModel && rawContent) {
    const reasoningResult = extractReasoningFromContent(rawContent);
    if (reasoningResult.isReasoningModel) {
      isReasoningModel = true;
      reasoning = reasoningResult.reasoning;
      finalAnswer = reasoningResult.finalAnswer;

      if (reasoning) {
        reasoningElement.textContent = reasoning;
        reasoningElement.style.display = 'block';
      }

      contentElement.innerHTML = `<div class="final-answer">${finalAnswer}</div>`;
    }
  }

  // æ„é€ å®Œæ•´çš„æ•°æ®å¯¹è±¡ç”¨äºåç»­å¤„ç†
  const data = {
    choices: [{
      message: {
        content: rawContent,
        reasoning_content: reasoning
      }
    }],
    model: model
  };

  // æ£€æµ‹å¹¶å¤„ç†æ¨ç†è¿‡ç¨‹
  const reasoningResult = extractReasoningProcess(data, rawContent);

  // æ‰“å°åŸå§‹å“åº”åˆ°æ§åˆ¶å°
  console.log('=== LLM API å“åº” ===');
  console.log('ğŸ“Š å®Œæ•´å“åº”æ•°æ®:', JSON.stringify(data, null, 2));
  console.log('ğŸ’­ åŸå§‹å›ç­”å†…å®¹:', rawContent);

  // å¦‚æœæ˜¯æ¨ç†æ¨¡å‹ï¼Œå•ç‹¬æ˜¾ç¤ºæ¨ç†è¿‡ç¨‹
  if (reasoningResult.isReasoningModel) {
    console.log('ğŸ§  æ¨ç†æ¨¡å‹æ£€æµ‹: æ˜¯');
    if (reasoningResult.reasoning) {
      console.log('ğŸ¤” æ¨ç†è¿‡ç¨‹:');
      console.log('%c' + reasoningResult.reasoning, 'color: #888; font-style: italic;');
    }
    if (reasoningResult.finalAnswer) {
      console.log('âœ… æœ€ç»ˆå›ç­”:', reasoningResult.finalAnswer);
    }
  } else {
    console.log('ğŸ§  æ¨ç†æ¨¡å‹æ£€æµ‹: å¦');
  }

  if (data.usage) {
    console.log('ğŸ“ˆ Tokenä½¿ç”¨æƒ…å†µ:', data.usage);
  }
  console.log('==================');

  // è§£æå›å¤å†…å®¹
  const content = cleanResponseContent(rawContent);
  const suggestions = extractSuggestions(rawContent);
  const structuredPoints = parseStructuredPoints(rawContent);

  // æ‰“å°è§£æåçš„ç»“æœ
  console.log('=== è§£æç»“æœ ===');
  console.log('ğŸ“„ æ¸…ç†åå†…å®¹:', content);
  console.log('ğŸ’¡ æå–çš„å»ºè®®:', suggestions);
  console.log('ğŸ“‹ ç»“æ„åŒ–åˆ†ç‚¹:', structuredPoints);
  console.log('===============');

  // æ¸…ç†æ˜¾ç¤ºå†…å®¹ä¸­çš„JSONéƒ¨åˆ†å¹¶åº”ç”¨Markdownè§£æ
  if (contentElement) {
    const cleanedContent = cleanResponseContent(contentElement.textContent || '');
    if (cleanedContent !== (contentElement.textContent || '')) {
      // å¦‚æœæ˜¯æ¨ç†æ¨¡å‹ä¸”æœ‰æœ€ç»ˆå›ç­”ï¼Œæ˜¾ç¤ºæœ€ç»ˆå›ç­”éƒ¨åˆ†
      if (isReasoningModel && finalAnswer) {
        const cleanedFinalAnswer = cleanResponseContent(finalAnswer);
        const parsedFinalAnswer = parseMarkdown(cleanedFinalAnswer);
        contentElement.innerHTML = `<div class="final-answer">${parsedFinalAnswer}</div>`;
      } else {
        const parsedContent = parseMarkdown(cleanedContent);
        contentElement.innerHTML = parsedContent;
      }
    } else {
      // å³ä½¿å†…å®¹æ²¡æœ‰å˜åŒ–ï¼Œä¹Ÿåº”ç”¨Markdownè§£æ
      const currentContent = contentElement.textContent || '';
      const parsedContent = parseMarkdown(currentContent);
      contentElement.innerHTML = parsedContent;
    }
  }

  // ä¸ºæµå¼æ¶ˆæ¯æ·»åŠ å»ºè®®å’Œç»“æ„åŒ–åˆ†ç‚¹
  if (suggestions.length > 0 || structuredPoints.length > 0) {
    const streamingMessage = document.getElementById(messageId);
    if (streamingMessage) {
      const messageContent = streamingMessage.querySelector('.message-content');

      // æ·»åŠ å»ºè®®
      if (suggestions.length > 0) {
        const suggestionButtons = suggestions.map(s => {
          // æ¸…ç†å»ºè®®æ–‡æœ¬ä¸­çš„Markdownç¬¦å·
          const cleanText = s.text.replace(/\*\*(.*?)\*\*/g, '$1').replace(/\*(.*?)\*/g, '$1').replace(/`(.*?)`/g, '$1');
          return `<button class="suggestion-btn" onclick="addSuggestionToMindMap('${cleanText}', '${s.type || 'child'}')">${cleanText}</button>`;
        }).join('');

        const suggestionsHtml = `
          <div class="suggestions">
            <div class="suggestions-title">ğŸ’¡ AIå»ºè®®</div>
            <div class="suggestions-list">${suggestionButtons}</div>
          </div>
        `;
        messageContent.insertAdjacentHTML('beforeend', suggestionsHtml);
      }

      // æ·»åŠ ç»“æ„åŒ–åˆ†ç‚¹
      if (structuredPoints.length > 0) {
        const pointsHtml = structuredPoints.map((point, index) => `
          <div class="structured-point" data-point-id="${point.id || index}">
            <div class="point-header">
              <input type="checkbox" class="point-checkbox" id="point_${messageId}_${index}">
              <label for="point_${messageId}_${index}" class="point-title">${point.title}</label>
            </div>
            <div class="point-content">${point.content}</div>
            ${point.keywords ? `<div class="point-keywords">${point.keywords.map(k => `<span class="keyword">${k}</span>`).join('')}</div>` : ''}
          </div>
        `).join('');

        const structuredPointsHtml = `
          <div class="structured-points">
            <div class="points-header">
              <div class="points-title">ğŸ“‹ ç»“æ„åŒ–åˆ†ç‚¹</div>
              <div class="points-actions">
                <button class="select-all-btn" onclick="selectAllPoints('${messageId}')">å…¨é€‰</button>
                <button class="add-selected-btn" onclick="addSelectedPoints('${messageId}')">æ·»åŠ é€‰ä¸­</button>
              </div>
            </div>
            <div class="points-list">${pointsHtml}</div>
          </div>
        `;
        messageContent.insertAdjacentHTML('beforeend', structuredPointsHtml);
      }
    }
  }

  // æµå¼å“åº”ä¸éœ€è¦è¿”å›å†…å®¹ï¼Œå› ä¸ºå·²ç»ç›´æ¥æ˜¾ç¤ºäº†
  return null;
}

// è·å–ç”¨æˆ·è‡ªå®šä¹‰æç¤ºè¯
function getCustomPromptFromStorage() {
  try {
    const aiConfig = localStorage.getItem('ai_config');
    if (aiConfig) {
      const config = JSON.parse(aiConfig);
      return config.customPrompt || '';
    }
  } catch (error) {
    console.warn('è·å–è‡ªå®šä¹‰æç¤ºè¯å¤±è´¥:', error);
  }
  return '';
}

// è·å–ç³»ç»Ÿæç¤ºè¯
function getSystemPrompt() {
  // è·å–ç”¨æˆ·è‡ªå®šä¹‰æç¤ºè¯ï¼ˆä»localStorageï¼‰
  const customPrompt = getCustomPromptFromStorage();

  // æ„å»ºåŸºç¡€æç¤ºè¯
  let prompt = '';

  if (customPrompt && customPrompt.trim()) {
    // ä½¿ç”¨ç”¨æˆ·è‡ªå®šä¹‰æç¤ºè¯
    prompt = customPrompt.trim();
  } else {
    // ä½¿ç”¨é»˜è®¤æç¤ºè¯
    prompt = `ä½ æ˜¯ä¸€ä¸ªä¸“ä¸šçš„æ€ç»´å¯¼å›¾AIåŠ©æ‰‹ã€‚ä½ çš„ä»»åŠ¡æ˜¯å¸®åŠ©ç”¨æˆ·æ‰©å±•å’Œå®Œå–„æ€ç»´å¯¼å›¾ã€‚

æ ¸å¿ƒèƒ½åŠ›ï¼š
1. åˆ†ææ€ç»´å¯¼å›¾èŠ‚ç‚¹å†…å®¹
2. æä¾›ç›¸å…³çš„å­èŠ‚ç‚¹å»ºè®®
3. å›ç­”ä¸èŠ‚ç‚¹å†…å®¹ç›¸å…³çš„é—®é¢˜
4. å¸®åŠ©ç”¨æˆ·ç†æ¸…æ€è·¯å’Œé€»è¾‘å…³ç³»

å›å¤è¦æ±‚ï¼š
- é¦–å…ˆæä¾›ä¸€ä¸ªç®€æ´çš„æ€»ä½“å›ç­”ï¼ˆ100-200å­—ï¼‰
- ç„¶åæä¾›ç»“æ„åŒ–çš„åˆ†ç‚¹ä¾›ç”¨æˆ·é€‰æ‹©æ·»åŠ åˆ°æ€ç»´å¯¼å›¾
- ä¿æŒé€»è¾‘æ€§å’Œæ¡ç†æ€§`;
  }

  // æ·»åŠ å›ºå®šçš„JSONæ ¼å¼è¦æ±‚
  const jsonExample = '```json\n{\n  "structuredPoints": [\n    {\n      "id": "point_1",\n      "title": "æ¦‚æ‹¬æ€§æ ‡é¢˜",\n      "content": "è¯¦ç»†è§£é‡Šå†…å®¹",\n      "keywords": ["å…³é”®è¯1", "å…³é”®è¯2"]\n    }\n  ]\n}\n```';

  prompt += `

é‡è¦ï¼šè¯·åœ¨å›ç­”çš„æœ€åï¼Œä½¿ç”¨ä»¥ä¸‹JSONæ ¼å¼é¢å¤–æä¾›åŸç­”æ¡ˆçš„ç»“æ„åŒ–åˆ†ç‚¹ï¼Œç¡®ä¿JSONä¸­çš„å†…å®¹ä¸ä½ çš„åŸå§‹å›ç­”ä¿æŒä¸€è‡´ï¼š
${jsonExample}`;

  // è·å–å½“å‰é€‰ä¸­èŠ‚ç‚¹çš„è¯¦ç»†ä¸Šä¸‹æ–‡ä¿¡æ¯
  if (selectedNodeText && selectedNodeHierarchy.length > 0) {
    prompt += `

å½“å‰ä¸Šä¸‹æ–‡ï¼š
- é€‰ä¸­èŠ‚ç‚¹ï¼š${selectedNodeText}
- èŠ‚ç‚¹è·¯å¾„ï¼š${selectedNodeHierarchy.join(' > ')}`;

    // è·å–èŠ‚ç‚¹é“¾è·¯çš„è¯¦ç»†ä¿¡æ¯ï¼ˆåŒ…æ‹¬å¤‡æ³¨ï¼‰
    if (mindMapInstance && mindMapInstance.renderer && mindMapInstance.renderer.activeNodeList && mindMapInstance.renderer.activeNodeList.length > 0) {
      const currentActiveNode = mindMapInstance.renderer.activeNodeList[0];
      const hierarchyWithNotes = getNodeHierarchyWithNotes(currentActiveNode);

      if (hierarchyWithNotes.length > 0) {
        prompt += `

èŠ‚ç‚¹é“¾è·¯è¯¦ç»†ä¿¡æ¯ï¼š`;
        hierarchyWithNotes.forEach((nodeInfo, index) => {
          prompt += `
${index + 1}. èŠ‚ç‚¹ï¼š"${nodeInfo.text}"`;
          if (nodeInfo.note && nodeInfo.note.trim()) {
            prompt += `
   å¤‡æ³¨ï¼š${nodeInfo.note.trim()}`;
          }
        });
      }
    }

    prompt += `

- è¯·åŸºäºè¿™ä¸ªèŠ‚ç‚¹çš„ä¸Šä¸‹æ–‡å’Œé“¾è·¯ä¿¡æ¯æ¥å›ç­”ç”¨æˆ·çš„é—®é¢˜`;
  }

  return prompt;
}

// æ‰“å­—æœºæ•ˆæœå‡½æ•°
async function typewriterEffect(element, text) {
  return new Promise((resolve) => {
    let currentText = element.textContent || '';
    element.textContent = currentText + text;

    // ç®€å•çš„å»¶è¿Ÿï¼Œå¯ä»¥æ ¹æ®éœ€è¦è°ƒæ•´
    setTimeout(resolve, 10);
  });
}

// ä»å†…å®¹ä¸­æå–æ¨ç†è¿‡ç¨‹ï¼ˆç”¨äºéå®˜æ–¹æ¨ç†æ¨¡å‹æ ¼å¼ï¼‰
function extractReasoningFromContent(content) {
  const result = {
    isReasoningModel: false,
    reasoning: '',
    finalAnswer: content
  };

  // æ£€æµ‹æ¨ç†æ¨¡å¼çš„å…³é”®è¯
  const reasoningKeywords = ['è®©æˆ‘æ€è€ƒ', 'æ€è€ƒè¿‡ç¨‹', 'æ¨ç†è¿‡ç¨‹', '<thinking>', '<reasoning>'];
  const hasReasoningPattern = reasoningKeywords.some(keyword => content.includes(keyword));

  if (hasReasoningPattern) {
    result.isReasoningModel = true;

    // å°è¯•æå–æ¨ç†è¿‡ç¨‹
    const reasoningPatterns = [
      /<thinking>([\s\S]*?)<\/thinking>/i,
      /<reasoning>([\s\S]*?)<\/reasoning>/i,
      /(?:æ€è€ƒè¿‡ç¨‹ï¼š|æ¨ç†è¿‡ç¨‹ï¼š|è®©æˆ‘æ€è€ƒä¸€ä¸‹[ï¼š:]?)([\s\S]*?)(?:ç»“è®ºï¼š|ç­”æ¡ˆï¼š|å›ç­”ï¼š|æœ€ç»ˆç­”æ¡ˆï¼š)/i,
    ];

    for (const pattern of reasoningPatterns) {
      const match = content.match(pattern);
      if (match) {
        result.reasoning = match[1].trim();
        result.finalAnswer = content.replace(match[0], '').trim();
        break;
      }
    }
  }

  return result;
}

// æ£€æµ‹å¹¶æå–æ¨ç†è¿‡ç¨‹
function extractReasoningProcess(data, rawContent) {
  const result = {
    isReasoningModel: false,
    reasoning: null,
    finalAnswer: null
  };

  // æ£€æµ‹æ–¹æ³•1: æ£€æŸ¥æ¨¡å‹åç§°æ˜¯å¦åŒ…å«æ¨ç†ç›¸å…³å…³é”®è¯
  const modelName = (data.model || '').toLowerCase();
  const reasoningKeywords = ['reasoner', 'reasoning', 'think', 'cot', 'chain-of-thought'];
  const isReasoningByModel = reasoningKeywords.some(keyword => modelName.includes(keyword));

  // æ£€æµ‹æ–¹æ³•2: æ£€æŸ¥å“åº”ç»“æ„æ˜¯å¦åŒ…å«æ¨ç†å­—æ®µï¼ˆDeepSeekå®˜æ–¹æ ¼å¼ï¼‰
  const choice = data.choices && data.choices[0];
  const hasDeepSeekReasoningField = choice && choice.message && choice.message.reasoning_content;

  // æ£€æµ‹æ–¹æ³•3: æ£€æŸ¥å“åº”ç»“æ„æ˜¯å¦åŒ…å«å…¶ä»–æ¨ç†å­—æ®µï¼ˆå…¼å®¹å…¶ä»–æ ¼å¼ï¼‰
  const hasOtherReasoningField = choice && (choice.reasoning || choice.message?.reasoning);

  // æ£€æµ‹æ–¹æ³•4: æ£€æŸ¥å†…å®¹æ ¼å¼æ˜¯å¦ç¬¦åˆæ¨ç†æ¨¡å¼
  const hasReasoningPattern = rawContent && (
    rawContent.includes('<thinking>') ||
    rawContent.includes('<reasoning>') ||
    rawContent.includes('è®©æˆ‘æ€è€ƒä¸€ä¸‹') ||
    rawContent.includes('æ€è€ƒè¿‡ç¨‹ï¼š') ||
    rawContent.includes('æ¨ç†è¿‡ç¨‹ï¼š') ||
    /^[\s\S]*?(?:æ€è€ƒ|æ¨ç†|åˆ†æ)[\s\S]*?(?:ç»“è®º|ç­”æ¡ˆ|å›ç­”)[\s\S]*$/i.test(rawContent)
  );

  result.isReasoningModel = isReasoningByModel || hasDeepSeekReasoningField || hasOtherReasoningField || hasReasoningPattern;

  if (result.isReasoningModel) {
    // æå–æ¨ç†è¿‡ç¨‹
    if (choice && choice.message && choice.message.reasoning_content) {
      // æ–¹æ³•1: DeepSeekå®˜æ–¹æ ¼å¼ - ä»message.reasoning_contentå­—æ®µæå–
      result.reasoning = choice.message.reasoning_content;
      result.finalAnswer = rawContent; // rawContentå°±æ˜¯contentå­—æ®µçš„å†…å®¹
    } else if (choice && choice.reasoning) {
      // æ–¹æ³•2: ä»APIå“åº”çš„reasoningå­—æ®µæå–ï¼ˆå…¶ä»–æ ¼å¼ï¼‰
      result.reasoning = choice.reasoning;
      result.finalAnswer = rawContent;
    } else if (choice && choice.message && choice.message.reasoning) {
      // æ–¹æ³•3: ä»message.reasoningå­—æ®µæå–ï¼ˆå…¶ä»–æ ¼å¼ï¼‰
      result.reasoning = choice.message.reasoning;
      result.finalAnswer = rawContent;
    } else if (rawContent) {
      // æ–¹æ³•3: ä»å†…å®¹ä¸­è§£ææ¨ç†è¿‡ç¨‹
      const reasoningPatterns = [
        // <thinking>æ ‡ç­¾æ ¼å¼
        /<thinking>([\s\S]*?)<\/thinking>/i,
        /<reasoning>([\s\S]*?)<\/reasoning>/i,
        // ä¸­æ–‡æ ¼å¼
        /(?:æ€è€ƒè¿‡ç¨‹ï¼š|æ¨ç†è¿‡ç¨‹ï¼š|è®©æˆ‘æ€è€ƒä¸€ä¸‹[ï¼š:]?)([\s\S]*?)(?:ç»“è®ºï¼š|ç­”æ¡ˆï¼š|å›ç­”ï¼š|æœ€ç»ˆç­”æ¡ˆï¼š)/i,
        // åˆ†æ®µæ ¼å¼
        /^([\s\S]*?)(?:\n\n|^)(?:ç»“è®º|ç­”æ¡ˆ|å›ç­”|æœ€ç»ˆç­”æ¡ˆ)[ï¼š:]?([\s\S]*)$/i
      ];

      for (const pattern of reasoningPatterns) {
        const match = rawContent.match(pattern);
        if (match) {
          if (pattern.source.includes('thinking') || pattern.source.includes('reasoning')) {
            result.reasoning = match[1].trim();
            result.finalAnswer = rawContent.replace(match[0], '').trim();
          } else if (pattern.source.includes('æ€è€ƒè¿‡ç¨‹') || pattern.source.includes('æ¨ç†è¿‡ç¨‹')) {
            result.reasoning = match[1].trim();
            const finalMatch = rawContent.match(/(?:ç»“è®ºï¼š|ç­”æ¡ˆï¼š|å›ç­”ï¼š|æœ€ç»ˆç­”æ¡ˆï¼š)([\s\S]*)$/i);
            result.finalAnswer = finalMatch ? finalMatch[1].trim() : rawContent;
          } else {
            result.reasoning = match[1].trim();
            result.finalAnswer = match[2] ? match[2].trim() : rawContent;
          }
          break;
        }
      }

      // å¦‚æœæ²¡æœ‰æ‰¾åˆ°æ˜ç¡®çš„åˆ†éš”ï¼Œä½†æ£€æµ‹åˆ°æ˜¯æ¨ç†æ¨¡å‹ï¼Œå°è¯•æ™ºèƒ½åˆ†å‰²
      if (!result.reasoning && result.isReasoningModel) {
        const lines = rawContent.split('\n');
        const thinkingLines = [];
        const answerLines = [];
        let isInAnswer = false;

        for (const line of lines) {
          const trimmed = line.trim();
          if (trimmed.match(/^(?:ç»“è®º|ç­”æ¡ˆ|å›ç­”|æœ€ç»ˆç­”æ¡ˆ|æ€»ç»“)[ï¼š:]?/i)) {
            isInAnswer = true;
          }

          if (isInAnswer) {
            answerLines.push(line);
          } else {
            thinkingLines.push(line);
          }
        }

        if (thinkingLines.length > 0 && answerLines.length > 0) {
          result.reasoning = thinkingLines.join('\n').trim();
          result.finalAnswer = answerLines.join('\n').trim();
        }
      }
    }
  }

  return result;
}

// æ¸…ç†AIå›å¤å†…å®¹
function cleanResponseContent(content) {
  // ç§»é™¤JSONä»£ç å—ï¼Œåªä¿ç•™æ–‡æœ¬å†…å®¹
  return content.replace(/```json[\s\S]*?```/g, '').trim();
}

// è§£æç»“æ„åŒ–åˆ†ç‚¹
function parseStructuredPoints(content) {
  console.log('ğŸ” parseStructuredPoints å¼€å§‹è§£æå†…å®¹:', content.substring(0, 200) + '...');

  try {
    // æŸ¥æ‰¾JSONä»£ç å—
    const jsonMatch = content.match(/```json\s*(\{[\s\S]*?\})\s*```/);
    console.log('ğŸ” JSONåŒ¹é…ç»“æœ:', jsonMatch ? 'æ‰¾åˆ°JSONå—' : 'æœªæ‰¾åˆ°JSONå—');

    if (!jsonMatch) {
      console.log('âŒ æœªæ‰¾åˆ°JSONä»£ç å—');
      return [];
    }

    const jsonString = jsonMatch[1];
    console.log('ğŸ” æå–çš„JSONå­—ç¬¦ä¸²:', jsonString);

    const jsonData = JSON.parse(jsonString);
    console.log('ğŸ” è§£æåçš„JSONæ•°æ®:', jsonData);

    if (jsonData.structuredPoints && Array.isArray(jsonData.structuredPoints)) {
      const result = jsonData.structuredPoints.map((point, index) => ({
        id: point.id || `point_${index + 1}`,
        title: point.title || `è¦ç‚¹${index + 1}`,
        content: point.content || '',
        keywords: Array.isArray(point.keywords) ? point.keywords : []
      }));
      console.log('âœ… æˆåŠŸè§£æç»“æ„åŒ–åˆ†ç‚¹:', result);
      return result;
    } else {
      console.log('âŒ JSONæ•°æ®ä¸­æ²¡æœ‰æœ‰æ•ˆçš„structuredPointsæ•°ç»„');
    }
  } catch (error) {
    console.error('âŒ è§£æç»“æ„åŒ–åˆ†ç‚¹å¤±è´¥:', error);
    console.error('é”™è¯¯è¯¦æƒ…:', error.message);
  }
  return [];
}

// é€å­—è¾“å‡ºAIå›å¤
async function simulateAIResponseStreaming(message) {
  // ä½¿ç”¨å…¨å±€çš„selectedNodeTextå˜é‡ï¼Œè€Œä¸æ˜¯currentSelectedNode
  let currentSelectedNodeText = selectedNodeText || 'å½“å‰è¯é¢˜';

  // ç¡®ä¿currentSelectedNodeTextå§‹ç»ˆæ˜¯å­—ç¬¦ä¸²
  if (typeof currentSelectedNodeText !== 'string') {
    currentSelectedNodeText = String(currentSelectedNodeText);
  }

  console.log('ğŸ¯ å½“å‰é€‰ä¸­èŠ‚ç‚¹æ–‡æœ¬:', currentSelectedNodeText);

  // å‡†å¤‡å®Œæ•´çš„å›å¤å†…å®¹
  let fullContent = '';
  let suggestions = [];
  let structuredPoints = [];

  if (message.includes('æ‰©å±•')) {
    fullContent = `## å…³äº"${currentSelectedNodeText}"çš„æ‰©å±•å»ºè®®

æˆ‘ä¸ºæ‚¨æä¾›äº†è¯¦ç»†çš„æ‰©å±•æ–¹æ¡ˆï¼ŒåŒ…æ‹¬å¤šä¸ªç»´åº¦çš„åˆ†æï¼š

### ğŸ¯ åŸºç¡€æ¦‚å¿µ
- **å®šä¹‰**: ${currentSelectedNodeText}çš„æ ¸å¿ƒå®šä¹‰å’ŒåŸºæœ¬åŸç†
- **ç‰¹å¾**: ä¸»è¦ç‰¹å¾å’Œè¯†åˆ«è¦ç´ 
- **åˆ†ç±»**: ä¸åŒç±»å‹å’Œåˆ†ç±»æ–¹æ³•

### ğŸ”§ æŠ€æœ¯ç‰¹ç‚¹
- **ä¼˜åŠ¿**: ${currentSelectedNodeText}çš„ä¸»è¦æŠ€æœ¯ä¼˜åŠ¿
- **å±€é™**: å½“å‰å­˜åœ¨çš„æŠ€æœ¯å±€é™
- **åˆ›æ–°**: æœ€æ–°çš„æŠ€æœ¯åˆ›æ–°ç‚¹

### ğŸŒ åº”ç”¨é¢†åŸŸ
- **å•†ä¸š**: åœ¨å•†ä¸šç¯å¢ƒä¸­çš„å…·ä½“åº”ç”¨
- **æŠ€æœ¯**: åœ¨æŠ€æœ¯å¼€å‘ä¸­çš„å®é™…åº”ç”¨
- **æ•™è‚²**: åœ¨æ•™è‚²åŸ¹è®­ä¸­çš„åº”ç”¨æ–¹å¼

### ğŸ“ˆ å‘å±•è¶‹åŠ¿
- **ç°çŠ¶**: ${currentSelectedNodeText}çš„å½“å‰å‘å±•çŠ¶æ€
- **è¶‹åŠ¿**: æœªæ¥å‘å±•æ–¹å‘å’Œè¶‹åŠ¿
- **æœºé‡**: æ½œåœ¨çš„å‘å±•æœºé‡`;

    suggestions = [
      { text: 'å®šä¹‰å’Œæ¦‚å¿µ', type: 'child' },
      { text: 'åº”ç”¨åœºæ™¯', type: 'child' },
      { text: 'ç›¸å…³æŠ€æœ¯', type: 'child' }
    ];

    structuredPoints = [
      {
        id: 'point_1',
        title: 'åŸºç¡€æ¦‚å¿µ',
        content: `${currentSelectedNodeText}çš„æ ¸å¿ƒå®šä¹‰å’ŒåŸºæœ¬åŸç†`,
        keywords: ['å®šä¹‰', 'åŸç†', 'åŸºç¡€']
      },
      {
        id: 'point_2',
        title: 'æŠ€æœ¯ç‰¹ç‚¹',
        content: `${currentSelectedNodeText}çš„ä¸»è¦æŠ€æœ¯ç‰¹å¾å’Œä¼˜åŠ¿`,
        keywords: ['ç‰¹ç‚¹', 'ä¼˜åŠ¿', 'æŠ€æœ¯']
      },
      {
        id: 'point_3',
        title: 'åº”ç”¨é¢†åŸŸ',
        content: `${currentSelectedNodeText}åœ¨å„ä¸ªè¡Œä¸šçš„å…·ä½“åº”ç”¨`,
        keywords: ['åº”ç”¨', 'è¡Œä¸š', 'å®è·µ']
      },
      {
        id: 'point_4',
        title: 'å‘å±•è¶‹åŠ¿',
        content: `${currentSelectedNodeText}çš„æœªæ¥å‘å±•æ–¹å‘å’Œè¶‹åŠ¿`,
        keywords: ['è¶‹åŠ¿', 'å‘å±•', 'æœªæ¥']
      }
    ];
  } else if (message.includes('è§£é‡Š')) {
    fullContent = `## "${currentSelectedNodeText}"çš„è¯¦ç»†è§£é‡Š

æˆ‘ä¸ºæ‚¨æä¾›äº†å…¨é¢çš„è§£é‡Šï¼ŒåŒ…å«å¤šä¸ªå±‚é¢çš„åˆ†æï¼š

### ğŸ“– åŸºæœ¬å«ä¹‰
**${currentSelectedNodeText}** æ˜¯ä¸€ä¸ªé‡è¦çš„æ¦‚å¿µï¼Œå…¶åŸºæœ¬å®šä¹‰åŒ…æ‹¬ï¼š
- æ ¸å¿ƒå®šä¹‰å’ŒåŸºæœ¬å†…æ¶µ
- ä¸»è¦ç‰¹å¾å’Œè¯†åˆ«æ ‡å‡†
- ä¸ç›¸å…³æ¦‚å¿µçš„åŒºåˆ«å’Œè”ç³»

### ğŸ” æ ¸å¿ƒè¦ç´ 
æ„æˆ${currentSelectedNodeText}çš„å…³é”®è¦ç´ åŒ…æ‹¬ï¼š
- **ä¸»è¦ç»„æˆéƒ¨åˆ†**: æ ¸å¿ƒæ„æˆè¦ç´ 
- **å…³é”®ç‰¹å¾**: é‡è¦çš„è¯†åˆ«ç‰¹å¾
- **å†…åœ¨é€»è¾‘**: å„è¦ç´ é—´çš„å…³ç³»

### âš™ï¸ è¿ä½œæœºåˆ¶
${currentSelectedNodeText}çš„å·¥ä½œåŸç†å’Œè¿ä½œæ–¹å¼ï¼š
- **åŸºæœ¬åŸç†**: åº•å±‚çš„å·¥ä½œæœºåˆ¶
- **è¿ä½œæµç¨‹**: å…·ä½“çš„æ“ä½œæ­¥éª¤
- **å½±å“å› ç´ **: å…³é”®çš„å½±å“å˜é‡`;

    suggestions = [
      { text: 'æ ¸å¿ƒç‰¹ç‚¹', type: 'child' },
      { text: 'å·¥ä½œåŸç†', type: 'child' }
    ];

    structuredPoints = [
      {
        id: 'explain_1',
        title: 'åŸºæœ¬å«ä¹‰',
        content: `${currentSelectedNodeText}çš„åŸºæœ¬å®šä¹‰å’Œå«ä¹‰`,
        keywords: ['å®šä¹‰', 'å«ä¹‰', 'åŸºæœ¬']
      },
      {
        id: 'explain_2',
        title: 'æ ¸å¿ƒè¦ç´ ',
        content: `æ„æˆ${currentSelectedNodeText}çš„å…³é”®è¦ç´ å’Œç»„æˆéƒ¨åˆ†`,
        keywords: ['è¦ç´ ', 'ç»„æˆ', 'æ ¸å¿ƒ']
      },
      {
        id: 'explain_3',
        title: 'è¿ä½œæœºåˆ¶',
        content: `${currentSelectedNodeText}çš„å·¥ä½œåŸç†å’Œè¿ä½œæ–¹å¼`,
        keywords: ['åŸç†', 'æœºåˆ¶', 'è¿ä½œ']
      }
    ];
  } else if (message.includes('åº”ç”¨')) {
    fullContent = `## "${currentSelectedNodeText}"çš„åº”ç”¨åœºæ™¯åˆ†æ

æˆ‘æ•´ç†äº†å¤šä¸ªå®é™…åº”ç”¨åœºæ™¯ä¾›æ‚¨å‚è€ƒï¼š

### ğŸ’¼ å•†ä¸šåœºæ™¯
åœ¨å•†ä¸šç¯å¢ƒä¸­ï¼Œ${currentSelectedNodeText}çš„åº”ç”¨åŒ…æ‹¬ï¼š
- **ä¼ä¸šç®¡ç†**: æå‡ç®¡ç†æ•ˆç‡å’Œå†³ç­–è´¨é‡
- **å¸‚åœºè¥é”€**: ä¼˜åŒ–è¥é”€ç­–ç•¥å’Œå®¢æˆ·ä½“éªŒ
- **äº§å“å¼€å‘**: æ”¹è¿›äº§å“è®¾è®¡å’ŒåŠŸèƒ½å®ç°

### ğŸ”§ æŠ€æœ¯åœºæ™¯
åœ¨æŠ€æœ¯å¼€å‘ä¸­çš„å®é™…åº”ç”¨ï¼š
- **ç³»ç»Ÿæ¶æ„**: ä¼˜åŒ–ç³»ç»Ÿè®¾è®¡å’Œæ€§èƒ½
- **å¼€å‘æµç¨‹**: æå‡å¼€å‘æ•ˆç‡å’Œä»£ç è´¨é‡
- **è¿ç»´ç®¡ç†**: æ”¹å–„ç³»ç»Ÿç¨³å®šæ€§å’Œå¯ç»´æŠ¤æ€§

### ğŸ“š æ•™è‚²åœºæ™¯
åœ¨æ•™è‚²åŸ¹è®­ä¸­çš„åº”ç”¨æ–¹å¼ï¼š
- **è¯¾ç¨‹è®¾è®¡**: ä¼˜åŒ–æ•™å­¦å†…å®¹å’Œæ–¹æ³•
- **å­¦ä¹ ä½“éªŒ**: æå‡å­¦ä¹ æ•ˆæœå’Œå‚ä¸åº¦
- **æŠ€èƒ½åŸ¹è®­**: åŠ å¼ºå®è·µèƒ½åŠ›å’Œä¸“ä¸šæŠ€èƒ½`;

    suggestions = [
      { text: 'å•†ä¸šåº”ç”¨', type: 'child' },
      { text: 'æŠ€æœ¯åº”ç”¨', type: 'child' }
    ];

    structuredPoints = [
      {
        id: 'app_1',
        title: 'å•†ä¸šåœºæ™¯',
        content: `${currentSelectedNodeText}åœ¨å•†ä¸šç¯å¢ƒä¸­çš„åº”ç”¨`,
        keywords: ['å•†ä¸š', 'ä¼ä¸š', 'å¸‚åœº']
      },
      {
        id: 'app_2',
        title: 'æŠ€æœ¯åœºæ™¯',
        content: `${currentSelectedNodeText}åœ¨æŠ€æœ¯å¼€å‘ä¸­çš„åº”ç”¨`,
        keywords: ['æŠ€æœ¯', 'å¼€å‘', 'å·¥ç¨‹']
      },
      {
        id: 'app_3',
        title: 'æ•™è‚²åœºæ™¯',
        content: `${currentSelectedNodeText}åœ¨æ•™è‚²åŸ¹è®­ä¸­çš„åº”ç”¨`,
        keywords: ['æ•™è‚²', 'åŸ¹è®­', 'å­¦ä¹ ']
      }
    ];
  } else {
    fullContent = `## å…³äº"${currentSelectedNodeText}"çš„åˆ†æ

æˆ‘ç†è§£æ‚¨çš„é—®é¢˜ï¼Œè¿™æ˜¯ä¸€ä¸ªå¾ˆæœ‰è¶£çš„è¯é¢˜ã€‚è®©æˆ‘ä¸ºæ‚¨æä¾›å¤šè§’åº¦çš„åˆ†æï¼š

### ğŸ¯ æ¦‚è¿°
**${currentSelectedNodeText}** æ˜¯ä¸€ä¸ªé‡è¦çš„ä¸»é¢˜ï¼Œå…·æœ‰ä»¥ä¸‹ç‰¹ç‚¹ï¼š
- æ€»ä½“æ¦‚è¿°å’ŒåŸºæœ¬è®¤çŸ¥
- é‡è¦æ€§å’Œä»·å€¼åˆ†æ
- å½“å‰çš„å‘å±•çŠ¶å†µ

### ğŸ”‘ å…³é”®ç‚¹
éœ€è¦é‡ç‚¹å…³æ³¨çš„æ ¸å¿ƒæ–¹é¢ï¼š
- **æ ¸å¿ƒè¦ç´ **: æœ€é‡è¦çš„ç»„æˆéƒ¨åˆ†
- **å…³é”®ç‰¹å¾**: ä¸»è¦çš„è¯†åˆ«æ ‡å‡†
- **é‡ç‚¹æ–¹å‘**: éœ€è¦æ·±å…¥äº†è§£çš„æ–¹é¢`;

    suggestions = [
      { text: 'æ·±å…¥äº†è§£', type: 'child' },
      { text: 'å®è·µåº”ç”¨', type: 'child' }
    ];

    structuredPoints = [
      {
        id: 'general_1',
        title: 'æ¦‚è¿°',
        content: `${currentSelectedNodeText}çš„æ€»ä½“æ¦‚è¿°å’Œé‡è¦æ€§`,
        keywords: ['æ¦‚è¿°', 'é‡è¦æ€§', 'æ€»ä½“']
      },
      {
        id: 'general_2',
        title: 'å…³é”®ç‚¹',
        content: `å…³äº${currentSelectedNodeText}éœ€è¦é‡ç‚¹å…³æ³¨çš„æ–¹é¢`,
        keywords: ['å…³é”®', 'é‡ç‚¹', 'æ ¸å¿ƒ']
      }
    ];
  }

  // æ‰§è¡Œé€å­—è¾“å‡º
  return await streamResponse(fullContent, suggestions, structuredPoints);
}

// é€å­—è¾“å‡ºå‡½æ•°
async function streamResponse(fullContent, suggestions, structuredPoints) {
  // ç¡®ä¿fullContentæ˜¯å­—ç¬¦ä¸²
  if (typeof fullContent !== 'string') {
    console.error('streamResponseæ¥æ”¶åˆ°éå­—ç¬¦ä¸²fullContent:', typeof fullContent, fullContent);
    fullContent = String(fullContent || '');
  }

  console.log('ğŸš€ å¼€å§‹é€å­—è¾“å‡ºï¼Œå†…å®¹é•¿åº¦:', fullContent.length);
  console.log('ğŸš€ å†…å®¹ç±»å‹:', typeof fullContent);
  console.log('ğŸš€ å†…å®¹é¢„è§ˆ:', fullContent.substring(0, 100));

  // åˆ›å»ºæ¶ˆæ¯å®¹å™¨
  const messagesContainer = document.getElementById('chatMessages');
  const messageId = 'msg_' + Date.now() + '_' + Math.random().toString(36).substr(2, 5);
  const messageDiv = document.createElement('div');
  messageDiv.className = 'message-item assistant';
  messageDiv.id = messageId;

  const avatar = 'ğŸ¤–';
  messageDiv.innerHTML = `
    <div class="message-avatar">${avatar}</div>
    <div class="message-content">
      <div class="message-text" id="${messageId}_text"></div>
    </div>
  `;

  messagesContainer.appendChild(messageDiv);
  messagesContainer.scrollTop = messagesContainer.scrollHeight;

  const textElement = document.getElementById(`${messageId}_text`);
  let currentText = '';

  // ä¼˜åŒ–çš„é€å­—è¾“å‡º - æŒ‰è¯ç»„è¾“å‡ºï¼Œæé«˜é€Ÿåº¦
  let i = 0;
  while (i < fullContent.length) {
    // ç¡®å®šä¸‹ä¸€ä¸ªè¾“å‡ºå—çš„å¤§å°
    let chunkSize = 1;
    const char = fullContent[i];

    // å¦‚æœæ˜¯ä¸­æ–‡å­—ç¬¦ï¼Œä¸€æ¬¡è¾“å‡ºä¸€ä¸ªå­—ç¬¦
    if (/[\u4e00-\u9fa5]/.test(char)) {
      chunkSize = 1;
    }
    // å¦‚æœæ˜¯è‹±æ–‡ï¼Œä¸€æ¬¡è¾“å‡ºä¸€ä¸ªå•è¯
    else if (/[a-zA-Z]/.test(char)) {
      while (i + chunkSize < fullContent.length && /[a-zA-Z]/.test(fullContent[i + chunkSize])) {
        chunkSize++;
      }
    }
    // å¦‚æœæ˜¯æ ‡ç‚¹ç¬¦å·æˆ–ç©ºæ ¼ï¼Œä¸€æ¬¡è¾“å‡º
    else {
      chunkSize = 1;
    }

    // æ·»åŠ å­—ç¬¦å—åˆ°å½“å‰æ–‡æœ¬
    const chunk = fullContent.substr(i, chunkSize);
    currentText += chunk;

    // æ¸…ç†æ–‡æœ¬ç”¨äºæ˜¾ç¤º - ç§»é™¤JSONä»£ç å—å’Œè§„èŒƒåŒ–æ¢è¡Œç¬¦
    let displayText = currentText;
    // ç§»é™¤JSONä»£ç å—ï¼ˆé¿å…æ˜¾ç¤ºç»“æ„åŒ–æ•°æ®ï¼‰
    displayText = displayText.replace(/```json[\s\S]*?```/g, '');
    // æ›´æ¿€è¿›çš„æ¢è¡Œç¬¦å¤„ç†ï¼š
    // 1. å°†å¤šä¸ªè¿ç»­æ¢è¡Œç¬¦åˆå¹¶ä¸ºå•ä¸ªæ¢è¡Œç¬¦
    displayText = displayText.replace(/\n{2,}/g, '\n');
    // 2. ç§»é™¤æ®µè½é—´å¤šä½™çš„ç©ºè¡Œï¼Œåªåœ¨æ ‡é¢˜å’Œåˆ—è¡¨å‰ä¿ç•™æ¢è¡Œ
    displayText = displayText.replace(/\n+(?=#{1,6}\s)/g, '\n'); // æ ‡é¢˜å‰åªä¿ç•™ä¸€ä¸ªæ¢è¡Œ
    displayText = displayText.replace(/\n+(?=[-*]\s)/g, '\n');   // åˆ—è¡¨å‰åªä¿ç•™ä¸€ä¸ªæ¢è¡Œ
    displayText = displayText.replace(/\n+(?=\d+\.\s)/g, '\n');  // æ•°å­—åˆ—è¡¨å‰åªä¿ç•™ä¸€ä¸ªæ¢è¡Œ

    // å®æ—¶æ¸²æŸ“Markdown
    const renderedHtml = parseMarkdown(displayText);
    if (typeof renderedHtml === 'string') {
      textElement.innerHTML = renderedHtml;
    } else {
      console.error('parseMarkdownè¿”å›éå­—ç¬¦ä¸²:', typeof renderedHtml, renderedHtml);
      textElement.innerHTML = String(renderedHtml || displayText);
    }

    // æ»šåŠ¨åˆ°åº•éƒ¨
    messagesContainer.scrollTop = messagesContainer.scrollHeight;

    // æ§åˆ¶è¾“å‡ºé€Ÿåº¦ - æ›´å¿«çš„é€Ÿåº¦
    const delay = char === '\n' ? 30 : (Math.random() * 15 + 5);
    await new Promise(resolve => setTimeout(resolve, delay));

    i += chunkSize;
  }

  // è¾“å‡ºå®Œæˆåæ·»åŠ å»ºè®®å’Œç»“æ„åŒ–åˆ†ç‚¹
  setTimeout(() => {
    addSuggestionsAndPoints(messageDiv, suggestions, structuredPoints, messageId);
  }, 500);

  console.log('âœ… é€å­—è¾“å‡ºå®Œæˆ');
  return { content: fullContent, suggestions, structuredPoints };
}

// æ·»åŠ å»ºè®®å’Œç»“æ„åŒ–åˆ†ç‚¹
function addSuggestionsAndPoints(messageDiv, suggestions, structuredPoints, messageId) {
  const messageContent = messageDiv.querySelector('.message-content');

  // æ·»åŠ å»ºè®®
  if (suggestions && suggestions.length > 0) {
    const suggestionButtons = suggestions.map(s => {
      const cleanText = s.text.replace(/\*\*(.*?)\*\*/g, '$1').replace(/\*(.*?)\*/g, '$1').replace(/`(.*?)`/g, '$1');
      return `<button class="suggestion-btn" onclick="addSuggestionToMindMap('${cleanText}', '${s.type || 'child'}')">${cleanText}</button>`;
    }).join('');

    const suggestionsHtml = `
      <div class="suggestions">
        <div class="suggestions-title">ğŸ’¡ AIå»ºè®®</div>
        <div class="suggestions-list">${suggestionButtons}</div>
      </div>
    `;
    messageContent.insertAdjacentHTML('beforeend', suggestionsHtml);
  }

  // æ·»åŠ ç»“æ„åŒ–åˆ†ç‚¹
  if (structuredPoints && structuredPoints.length > 0) {
    const pointsHtml = structuredPoints.map((point, index) => `
      <div class="structured-point" data-point-id="${point.id || index}">
        <div class="point-header">
          <input type="checkbox" class="point-checkbox" id="point_${messageId}_${index}">
          <label for="point_${messageId}_${index}" class="point-title">${point.title}</label>
        </div>
        <div class="point-content">${point.content}</div>
        ${point.keywords ? `<div class="point-keywords">${point.keywords.map(k => `<span class="keyword">${k}</span>`).join('')}</div>` : ''}
      </div>
    `).join('');

    const structuredPointsHtml = `
      <div class="structured-points">
        <div class="points-header">
          <div class="points-title">ğŸ“‹ ç»“æ„åŒ–åˆ†ç‚¹</div>
          <div class="points-actions">
            <button class="select-all-btn" onclick="selectAllPoints('${messageId}')">å…¨é€‰</button>
            <button class="add-selected-btn" onclick="addSelectedPoints('${messageId}')">æ·»åŠ é€‰ä¸­</button>
          </div>
        </div>
        <div class="points-list">${pointsHtml}</div>
      </div>
    `;
    messageContent.insertAdjacentHTML('beforeend', structuredPointsHtml);
  }

  // æ»šåŠ¨åˆ°åº•éƒ¨
  const messagesContainer = document.getElementById('chatMessages');
  messagesContainer.scrollTop = messagesContainer.scrollHeight;
}

// è½»é‡çº§å®æ—¶Markdownè§£æå™¨
class StreamingMarkdownParser {
  constructor() {
    this.buffer = '';
    this.inCodeBlock = false;
    this.inList = false;
    this.listLevel = 0;
  }

  // å®æ—¶è§£æMarkdownå†…å®¹
  parseStreaming(content) {
    const lines = content.split('\n');
    let html = '';
    let currentList = null;
    let inCodeBlock = false;
    let codeBlockType = '';

    for (let i = 0; i < lines.length; i++) {
      const line = lines[i];
      const trimmed = line.trim();

      // å¤„ç†ä»£ç å—
      if (trimmed.startsWith('```')) {
        if (!inCodeBlock) {
          inCodeBlock = true;
          codeBlockType = trimmed.substring(3);
          html += `<div class="code-block" style="background: #f5f5f5; padding: 8px; margin: 4px 0; border-radius: 4px; font-family: monospace; font-size: 0.9em; line-height: 1.3;">`;
          continue;
        } else {
          inCodeBlock = false;
          html += '</div>';
          continue;
        }
      }

      if (inCodeBlock) {
        html += this.escapeHtml(line) + '\n';
        continue;
      }

      // å¤„ç†æ ‡é¢˜
      if (trimmed.startsWith('# ')) {
        html += `<h1 style="margin: 6px 0 3px 0; line-height: 1.2; font-size: 1.4em; font-weight: bold;">${this.parseInline(trimmed.substring(2))}</h1>`;
      } else if (trimmed.startsWith('## ')) {
        html += `<h2 style="margin: 5px 0 2px 0; line-height: 1.2; font-size: 1.3em; font-weight: bold;">${this.parseInline(trimmed.substring(3))}</h2>`;
      } else if (trimmed.startsWith('### ')) {
        html += `<h3 style="margin: 4px 0 2px 0; line-height: 1.2; font-size: 1.2em; font-weight: bold;">${this.parseInline(trimmed.substring(4))}</h3>`;
      } else if (trimmed.startsWith('#### ')) {
        html += `<h4 style="margin: 3px 0 1px 0; line-height: 1.2; font-size: 1.1em; font-weight: bold;">${this.parseInline(trimmed.substring(5))}</h4>`;
      }
      // å¤„ç†åˆ—è¡¨
      else if (trimmed.startsWith('- ') || trimmed.startsWith('* ')) {
        if (currentList !== 'ul') {
          if (currentList) html += currentList === 'ol' ? '</ol>' : '</ul>';
          html += '<ul style="margin: 2px 0; padding-left: 16px; line-height: 1.2;">';
          currentList = 'ul';
        }
        html += `<li style="margin: 0; line-height: 1.2; padding: 1px 0;">${this.parseInline(trimmed.substring(2))}</li>`;
      } else if (/^\d+\.\s/.test(trimmed)) {
        if (currentList !== 'ol') {
          if (currentList) html += currentList === 'ol' ? '</ol>' : '</ul>';
          html += '<ol style="margin: 2px 0; padding-left: 16px; line-height: 1.2;">';
          currentList = 'ol';
        }
        html += `<li style="margin: 0; line-height: 1.2; padding: 1px 0;">${this.parseInline(trimmed.replace(/^\d+\.\s/, ''))}</li>`;
      }
      // å¤„ç†æ™®é€šæ®µè½
      else if (trimmed.length > 0) {
        if (currentList) {
          html += currentList === 'ol' ? '</ol>' : '</ul>';
          currentList = null;
        }
        html += `<div style="margin: 1px 0; line-height: 1.3;">${this.parseInline(trimmed)}</div>`;
      }
      // å¤„ç†ç©ºè¡Œ
      else {
        if (currentList) {
          html += currentList === 'ol' ? '</ol>' : '</ul>';
          currentList = null;
        }
        // ç©ºè¡Œåªæ·»åŠ å¾ˆå°çš„é—´è·
        html += '<div style="height: 2px;"></div>';
      }
    }

    // å…³é—­æœªå…³é—­çš„åˆ—è¡¨
    if (currentList) {
      html += currentList === 'ol' ? '</ol>' : '</ul>';
    }

    return html;
  }

  // è§£æè¡Œå†…å…ƒç´ 
  parseInline(text) {
    return text
      .replace(/\*\*(.*?)\*\*/g, '<strong>$1</strong>')
      .replace(/\*(.*?)\*/g, '<em>$1</em>')
      .replace(/`(.*?)`/g, '<code style="background: #f0f0f0; padding: 1px 3px; border-radius: 2px; font-family: monospace; font-size: 0.9em;">$1</code>')
      .replace(/\[([^\]]+)\]\(([^)]+)\)/g, '<a href="$2" style="color: #409eff; text-decoration: none;">$1</a>');
  }

  // HTMLè½¬ä¹‰
  escapeHtml(text) {
    const div = document.createElement('div');
    div.textContent = text;
    return div.innerHTML;
  }
}

// åˆ›å»ºè§£æå™¨å®ä¾‹
const streamingParser = new StreamingMarkdownParser();

// åˆå§‹åŒ–marked.jsé…ç½® - ä½¿ç”¨ç®€å•é…ç½®ï¼Œå‚è€ƒdemo_markdown_parser.html
if (typeof marked !== 'undefined') {
  // é…ç½®markedé€‰é¡¹ - ä¿æŒç®€å•
  marked.setOptions({
    breaks: true,        // æ”¯æŒæ¢è¡Œ
    gfm: true,          // æ”¯æŒGitHubé£æ ¼Markdown
    sanitize: false,    // ä¸è¿‡æ»¤HTML
    smartLists: true,   // æ™ºèƒ½åˆ—è¡¨
    smartypants: false  // ä¸è½¬æ¢å¼•å·
  });

  console.log('marked.jsé…ç½®å®Œæˆ');
}

// ä½¿ç”¨marked.jsçš„Markdownè§£æå‡½æ•° - å‚è€ƒdemo_markdown_parser.htmlçš„ç®€å•ç”¨æ³•
function parseMarkdown(content) {
  // ç¡®ä¿contentæ˜¯å­—ç¬¦ä¸²
  if (typeof content !== 'string') {
    console.warn('parseMarkdownæ¥æ”¶åˆ°éå­—ç¬¦ä¸²å†…å®¹:', typeof content, content);
    return String(content || '');
  }

  // æ£€æŸ¥marked.jsæ˜¯å¦å¯ç”¨
  if (typeof marked === 'undefined') {
    console.warn('marked.jsæœªåŠ è½½ï¼Œä½¿ç”¨é™çº§è§£æ');
    return fallbackParseMarkdown(content);
  }

  try {
    // æ›´æ¿€è¿›çš„é¢„å¤„ç†ï¼šå½»åº•æ¸…ç†ç©ºç™½
    let preprocessedContent = content
      // ç§»é™¤æ‰€æœ‰è¿ç»­çš„ç©ºç™½è¡Œï¼Œåªä¿ç•™å•ä¸ªæ¢è¡Œ
      .replace(/\n\s*\n/g, '\n')
      // ç§»é™¤è¡Œé¦–è¡Œå°¾çš„æ‰€æœ‰ç©ºç™½å­—ç¬¦
      .replace(/^[ \t\r\f\v]+|[ \t\r\f\v]+$/gm, '')
      // ç§»é™¤å®Œå…¨ç©ºç™½çš„è¡Œ
      .replace(/^\s*$/gm, '')
      // å°†å¤šä¸ªè¿ç»­æ¢è¡Œå‹ç¼©ä¸ºå•ä¸ªæ¢è¡Œ
      .replace(/\n+/g, '\n')
      // ç§»é™¤å¼€å¤´å’Œç»“å°¾çš„æ¢è¡Œç¬¦
      .trim();

    // ä½¿ç”¨ç®€å•çš„marked.parseï¼Œå°±åƒdemoä¸­ä¸€æ ·
    let html = marked.parse(preprocessedContent);

    // ç¡®ä¿è¿”å›å€¼æ˜¯å­—ç¬¦ä¸²
    if (typeof html !== 'string') {
      console.warn('marked.parseè¿”å›éå­—ç¬¦ä¸²:', typeof html, html);
      return fallbackParseMarkdown(content);
    }

    // æ›´å½»åº•çš„HTMLæ¸…ç†
    html = html
      // ç§»é™¤æ‰€æœ‰ç©ºçš„æ®µè½æ ‡ç­¾
      .replace(/<p>\s*<\/p>/g, '')
      .replace(/<p>[\s\u00A0\u200B]*<\/p>/g, '')
      // ç§»é™¤ç©ºçš„divå’Œå…¶ä»–å®¹å™¨
      .replace(/<div>\s*<\/div>/g, '')
      .replace(/<span>\s*<\/span>/g, '')
      // ç§»é™¤HTMLä¸­çš„å¤šä½™æ¢è¡Œå’Œç©ºç™½
      .replace(/>\s+</g, '><')
      .replace(/\n\s*\n/g, '\n')
      // å‹ç¼©æ‰€æœ‰è¿ç»­çš„ç©ºç™½å­—ç¬¦
      .replace(/\s{2,}/g, ' ')
      // ç§»é™¤æ ‡ç­¾é—´çš„æ¢è¡Œç¬¦
      .replace(/>\n+</g, '><');

    // åº”ç”¨è¶…çº§ç´§å‡‘çš„æ ·å¼ - å‡ ä¹æ— é—´è·
    html = html
      .replace(/<h([1-6])>/g, '<h$1 style="margin: 1px 0 0 0; line-height: 1.0; font-weight: 600; display: inline-block; width: 100%;">')
      .replace(/<p>/g, '<p style="margin: 0; line-height: 1.1; display: inline-block; width: 100%;">')
      .replace(/<ul>/g, '<ul style="margin: 0; padding-left: 12px; line-height: 1.0;">')
      .replace(/<ol>/g, '<ol style="margin: 0; padding-left: 12px; line-height: 1.0;">')
      .replace(/<li>/g, '<li style="margin: 0; line-height: 1.0; padding: 0; display: list-item;">')
      .replace(/<strong>/g, '<strong style="font-weight: 600;">')
      .replace(/<em>/g, '<em style="font-style: italic;">')
      .replace(/<code>/g, '<code style="background: #f0f0f0; padding: 1px 3px; border-radius: 2px; font-family: monospace; font-size: 0.9em;">');

    return html;
  } catch (error) {
    console.warn('marked.jsè§£æå¤±è´¥:', error);
    return fallbackParseMarkdown(content);
  }
}

// é™çº§Markdownè§£æå‡½æ•°
function fallbackParseMarkdown(content) {
  // ç¡®ä¿contentæ˜¯å­—ç¬¦ä¸²
  if (typeof content !== 'string') {
    console.warn('fallbackParseMarkdownæ¥æ”¶åˆ°éå­—ç¬¦ä¸²å†…å®¹:', typeof content, content);
    return String(content || '');
  }

  return content
    .replace(/\n/g, '<br>')
    .replace(/\*\*(.*?)\*\*/g, '<strong style="font-weight: 600;">$1</strong>')
    .replace(/\*(.*?)\*/g, '<em style="font-style: italic;">$1</em>')
    .replace(/`(.*?)`/g, '<code style="background: #f0f0f0; padding: 1px 3px; border-radius: 2px; font-family: monospace; font-size: 0.9em;">$1</code>')
    .replace(/^### (.*$)/gim, '<h3 style="margin: 1px 0 1px 0; line-height: 1.1; font-size: 1.1em; font-weight: bold;">$1</h3>')
    .replace(/^## (.*$)/gim, '<h2 style="margin: 2px 0 1px 0; line-height: 1.1; font-size: 1.2em; font-weight: bold;">$1</h2>')
    .replace(/^# (.*$)/gim, '<h1 style="margin: 2px 0 1px 0; line-height: 1.1; font-size: 1.3em; font-weight: bold;">$1</h1>')
    .replace(/^- (.*$)/gim, '<li style="margin: 0; line-height: 1.1; padding: 0;">$1</li>')
    .replace(/(<li.*?<\/li>)/gs, '<ul style="margin: 0; padding-left: 14px; line-height: 1.1;">$1</ul>');
}

// æ”¹è¿›çš„AIå»ºè®®æå–é€»è¾‘
function extractSuggestions(content) {
  const suggestions = [];

  // é¦–å…ˆå°è¯•ä»ç»“æ„åŒ–JSONä¸­æå–ï¼ˆè¿™æ˜¯æˆ‘ä»¬æ¨èçš„æ–¹å¼ï¼‰
  const structuredPoints = parseStructuredPoints(content);
  if (structuredPoints.length > 0) {
    // ä»ç»“æ„åŒ–åˆ†ç‚¹ä¸­æå–å‰3ä¸ªä½œä¸ºå¿«é€Ÿå»ºè®®
    structuredPoints.slice(0, 3).forEach(point => {
      if (point.title && point.title.length <= 50) {
        suggestions.push({
          text: point.title,
          type: 'child',
          description: point.content || 'æ¥è‡ªç»“æ„åŒ–åˆ†ç‚¹'
        });
      }
    });
    return suggestions;
  }

  // å¦‚æœæ²¡æœ‰ç»“æ„åŒ–åˆ†ç‚¹ï¼Œåˆ™ä»Markdownåˆ—è¡¨ä¸­æå–
  const lines = content.split('\n');
  let inCodeBlock = false;

  lines.forEach(line => {
    const trimmed = line.trim();

    // è·³è¿‡ä»£ç å—å†…å®¹
    if (trimmed.startsWith('```')) {
      inCodeBlock = !inCodeBlock;
      return;
    }
    if (inCodeBlock) return;

    // æå–åˆ—è¡¨é¡¹ï¼Œä½†æ’é™¤ä¸€äº›æ˜æ˜¾ä¸é€‚åˆä½œä¸ºèŠ‚ç‚¹çš„å†…å®¹
    if (trimmed.startsWith('- ') || trimmed.startsWith('â€¢ ') || trimmed.match(/^\d+\.\s/)) {
      let text = trimmed.replace(/^[-â€¢]\s*/, '').replace(/^\d+\.\s*/, '').trim();

      // è¿‡æ»¤æ¡ä»¶ï¼š
      // 1. é•¿åº¦åœ¨3-50å­—ç¬¦ä¹‹é—´
      // 2. ä¸åŒ…å«ç‰¹æ®Šæ ‡è®°ï¼ˆå¦‚JSONã€ä»£ç ç­‰ï¼‰
      // 3. ä¸æ˜¯çº¯æ•°å­—æˆ–ç‰¹æ®Šç¬¦å·
      if (text.length >= 3 && text.length <= 50 &&
          !text.includes('{') && !text.includes('}') &&
          !text.includes('```') && !text.includes('json') &&
          !/^[\d\s\-_=]+$/.test(text)) {

        suggestions.push({
          text,
          type: 'child',
          description: 'æ¥è‡ªAIå›å¤åˆ—è¡¨'
        });
      }
    }
  });

  return suggestions.slice(0, 3);
}

// æ·»åŠ æ¶ˆæ¯
function addMessage(role, content, suggestions = [], structuredPoints = []) {
  const messagesContainer = document.getElementById('chatMessages');

  // ç§»é™¤æ¬¢è¿æ¶ˆæ¯
  const welcomeMessage = messagesContainer.querySelector('.welcome-message');
  if (welcomeMessage && messages.length === 0) {
    welcomeMessage.remove();
  }

  const messageId = 'msg_' + Date.now() + '_' + Math.random().toString(36).substr(2, 5);
  const messageDiv = document.createElement('div');
  messageDiv.className = `message-item ${role}`;
  messageDiv.id = messageId;

  const avatar = role === 'user' ? 'ğŸ‘¤' : 'ğŸ¤–';

  // æ™®é€šå»ºè®®HTML
  let suggestionsHtml = '';
  if (suggestions && suggestions.length > 0) {
    const suggestionButtons = suggestions.map(s => {
      // æ¸…ç†å»ºè®®æ–‡æœ¬ä¸­çš„Markdownç¬¦å·
      const cleanText = s.text.replace(/\*\*(.*?)\*\*/g, '$1').replace(/\*(.*?)\*/g, '$1').replace(/`(.*?)`/g, '$1');
      return `<button class="suggestion-btn" onclick="addSuggestionToMindMap('${cleanText}', '${s.type || 'child'}')">${cleanText}</button>`;
    }).join('');

    suggestionsHtml = `
      <div class="suggestions">
        <div class="suggestions-title">ğŸ’¡ AIå»ºè®®</div>
        <div class="suggestions-list">${suggestionButtons}</div>
      </div>
    `;
  }

  // ç»“æ„åŒ–åˆ†ç‚¹HTML
  let structuredPointsHtml = '';
  if (structuredPoints && structuredPoints.length > 0) {
    const pointsHtml = structuredPoints.map((point, index) => `
      <div class="structured-point" data-point-id="${point.id || index}">
        <div class="point-header">
          <input type="checkbox" class="point-checkbox" id="point_${messageId}_${index}">
          <label for="point_${messageId}_${index}" class="point-title">${point.title}</label>
        </div>
        <div class="point-content">${point.content}</div>
        ${point.keywords ? `<div class="point-keywords">${point.keywords.map(k => `<span class="keyword">${k}</span>`).join('')}</div>` : ''}
      </div>
    `).join('');

    structuredPointsHtml = `
      <div class="structured-points">
        <div class="points-header">
          <div class="points-title">ğŸ“‹ ç»“æ„åŒ–åˆ†ç‚¹</div>
          <div class="points-actions">
            <button class="select-all-btn" onclick="selectAllPoints('${messageId}')">å…¨é€‰</button>
            <button class="add-selected-btn" onclick="addSelectedPoints('${messageId}')">æ·»åŠ é€‰ä¸­</button>
          </div>
        </div>
        <div class="points-list">${pointsHtml}</div>
      </div>
    `;
  }

  // å¯¹AIå›å¤è¿›è¡ŒMarkdownè§£æ
  const processedContent = role === 'assistant' ? parseMarkdown(content) : content;

  messageDiv.innerHTML = `
    <div class="message-avatar">${avatar}</div>
    <div class="message-content">
      <div class="message-text">${processedContent}</div>
      ${suggestionsHtml}
      ${structuredPointsHtml}
    </div>
  `;

  messagesContainer.appendChild(messageDiv);
  messagesContainer.scrollTop = messagesContainer.scrollHeight;

  messages.push({ role, content, suggestions, structuredPoints });
}

// æ·»åŠ ç³»ç»Ÿæ¶ˆæ¯
function addSystemMessage(content) {
  const messagesContainer = document.getElementById('chatMessages');

  const messageDiv = document.createElement('div');
  messageDiv.className = 'message-item system';
  messageDiv.innerHTML = `
    <div class="message-content">
      ${content}
    </div>
  `;

  messagesContainer.appendChild(messageDiv);
  messagesContainer.scrollTop = messagesContainer.scrollHeight;
}

// è®¾ç½®åŠ è½½çŠ¶æ€
function setLoading(loading) {
  isLoading = loading;
  const sendBtn = document.getElementById('sendBtn');
  const input = document.getElementById('messageInput');

  if (loading) {
    sendBtn.textContent = 'å‘é€ä¸­...';
    sendBtn.disabled = true;
    input.disabled = true;

    // æ·»åŠ åŠ è½½æ¶ˆæ¯
    const messagesContainer = document.getElementById('chatMessages');
    const loadingDiv = document.createElement('div');
    loadingDiv.className = 'message-item assistant';
    loadingDiv.id = 'loadingMessage';
    loadingDiv.innerHTML = `
      <div class="message-avatar loading">ğŸ¤–</div>
      <div class="message-content">
        <div class="message-text">AIæ­£åœ¨æ€è€ƒä¸­<span class="thinking-dots"><span class="dot"></span><span class="dot"></span><span class="dot"></span></span></div>
      </div>
    `;
    messagesContainer.appendChild(loadingDiv);
    messagesContainer.scrollTop = messagesContainer.scrollHeight;
  } else {
    sendBtn.textContent = 'å‘é€';
    sendBtn.disabled = false;
    input.disabled = false;

    // ç§»é™¤åŠ è½½æ¶ˆæ¯
    const loadingMessage = document.getElementById('loadingMessage');
    if (loadingMessage) {
      loadingMessage.remove();
    }
  }
}

// æ·»åŠ å»ºè®®åˆ°æ€ç»´å¯¼å›¾
function addSuggestionToMindMap(text, type = 'child') {
  if (!mindMapInstance) {
    showNotification('âŒ æ€ç»´å¯¼å›¾æœªåˆå§‹åŒ–ï¼Œè¯·ç­‰å¾…åŠ è½½å®Œæˆ', 'error');
    return;
  }

  try {
    // è·å–å½“å‰æ¿€æ´»çš„èŠ‚ç‚¹
    const activeNodes = mindMapInstance.renderer.activeNodeList;
    if (!activeNodes || activeNodes.length === 0) {
      showNotification('âš ï¸ è¯·å…ˆç‚¹å‡»é€‰æ‹©ä¸€ä¸ªæ€ç»´å¯¼å›¾èŠ‚ç‚¹', 'warning');
      return;
    }

    const parentNode = activeNodes[0];
    console.log('æ·»åŠ èŠ‚ç‚¹åˆ°:', parentNode, 'æ–‡æœ¬:', text, 'ç±»å‹:', type);

    // æ ¹æ®ç±»å‹æ·»åŠ èŠ‚ç‚¹ - ä½¿ç”¨æ­£ç¡®çš„å‚æ•°æ ¼å¼
    if (type === 'child') {
      // æ·»åŠ å­èŠ‚ç‚¹
      mindMapInstance.execCommand('INSERT_CHILD_NODE', false, [], {
        text: text,
        uid: generateNodeId()
      });
    } else if (type === 'sibling') {
      // æ·»åŠ å…„å¼ŸèŠ‚ç‚¹
      mindMapInstance.execCommand('INSERT_NODE', false, [], {
        text: text,
        uid: generateNodeId()
      });
    }

    showNotification(`âœ… å·²æ·»åŠ "${text}"åˆ°æ€ç»´å¯¼å›¾`, 'success');

    // è§¦å‘æ•°æ®ä¿å­˜
    try {
      if (typeof window.takeOverAppMethods?.saveMindMapData === 'function') {
        const data = mindMapInstance.getData();
        window.takeOverAppMethods.saveMindMapData(data);
      }
    } catch (saveError) {
      console.warn('ä¿å­˜æ•°æ®å¤±è´¥:', saveError);
    }

  } catch (error) {
    console.error('æ·»åŠ èŠ‚ç‚¹å¤±è´¥:', error);
    showNotification('âŒ æ·»åŠ èŠ‚ç‚¹å¤±è´¥: ' + error.message, 'error');
  }
}

// ç”Ÿæˆå”¯ä¸€èŠ‚ç‚¹ID
function generateNodeId() {
  return 'ai_node_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9);
}

// æ‰‹åŠ¨åŒæ­¥å½“å‰æ¿€æ´»èŠ‚ç‚¹
function syncCurrentActiveNode() {
  if (!mindMapInstance) {
    console.log('æ€ç»´å¯¼å›¾å®ä¾‹ä¸å­˜åœ¨ï¼Œæ— æ³•åŒæ­¥');
    showNotification('âŒ æ€ç»´å¯¼å›¾æœªåˆå§‹åŒ–', 'error');
    return false;
  }

  try {
    const activeNodes = mindMapInstance.renderer.activeNodeList;
    if (activeNodes && activeNodes.length > 0) {
      const currentActiveNode = activeNodes[0];
      console.log('æ‰‹åŠ¨åŒæ­¥æ¿€æ´»èŠ‚ç‚¹:', currentActiveNode);
      updateSelectedNode(currentActiveNode);

      // è·å–èŠ‚ç‚¹æ–‡æœ¬ç”¨äºé€šçŸ¥
      let rawNodeText = currentActiveNode.nodeData ?
        currentActiveNode.nodeData.data.text :
        (currentActiveNode.getData ? currentActiveNode.getData('text') : 'æœªçŸ¥èŠ‚ç‚¹');

      // æ¸…ç†HTMLæ ‡ç­¾
      let nodeText = '';
      if (typeof rawNodeText === 'string') {
        const tempDiv = document.createElement('div');
        tempDiv.innerHTML = rawNodeText;
        nodeText = tempDiv.textContent || tempDiv.innerText || rawNodeText;
      } else {
        nodeText = rawNodeText || 'æœªçŸ¥èŠ‚ç‚¹';
      }

      showNotification(`âœ… å·²åŒæ­¥èŠ‚ç‚¹: ${nodeText}`, 'success');
      return true;
    } else {
      console.log('æ²¡æœ‰æ¿€æ´»çš„èŠ‚ç‚¹');
      showNotification('âš ï¸ æ²¡æœ‰é€‰ä¸­çš„èŠ‚ç‚¹ï¼Œè¯·å…ˆç‚¹å‡»æ€ç»´å¯¼å›¾ä¸­çš„èŠ‚ç‚¹', 'warning');
      return false;
    }
  } catch (error) {
    console.error('åŒæ­¥æ¿€æ´»èŠ‚ç‚¹å¤±è´¥:', error);
    showNotification('âŒ åŒæ­¥å¤±è´¥: ' + error.message, 'error');
    return false;
  }
}

// æ‰¹é‡æ·»åŠ ç»“æ„åŒ–åˆ†ç‚¹
async function addStructuredPoints(points) {
  console.log('ğŸš€ addStructuredPoints è¢«è°ƒç”¨ï¼Œæ¥æ”¶åˆ°çš„æ•°æ®:', points);
  console.log('ğŸš€ æ•°æ®ç±»å‹:', typeof points, 'æ•°æ®é•¿åº¦:', points ? points.length : 'undefined');

  if (!points || points.length === 0) {
    console.error('âŒ æ— æ•ˆçš„å‚æ•°ï¼šæ²¡æœ‰åˆ†ç‚¹æ•°æ®');
    showNotification('âŒ æ— æ•ˆçš„å‚æ•°ï¼šæ²¡æœ‰åˆ†ç‚¹æ•°æ®', 'error');
    return;
  }

  if (!mindMapInstance) {
    console.error('âŒ æ€ç»´å¯¼å›¾æœªåˆå§‹åŒ–');
    showNotification('âŒ æ€ç»´å¯¼å›¾æœªåˆå§‹åŒ–ï¼Œè¯·ç­‰å¾…åŠ è½½å®Œæˆ', 'error');
    return;
  }

  // å°è¯•æ‰‹åŠ¨åŒæ­¥å½“å‰æ¿€æ´»èŠ‚ç‚¹
  syncCurrentActiveNode();

  try {
    const activeNodes = mindMapInstance.renderer.activeNodeList;
    console.log('ğŸ” å½“å‰æ¿€æ´»èŠ‚ç‚¹:', activeNodes);

    if (!activeNodes || activeNodes.length === 0) {
      console.error('âŒ æ²¡æœ‰æ¿€æ´»çš„èŠ‚ç‚¹');
      showNotification('âš ï¸ è¯·å…ˆç‚¹å‡»é€‰æ‹©ä¸€ä¸ªæ€ç»´å¯¼å›¾èŠ‚ç‚¹', 'warning');
      return;
    }

    const parentNode = activeNodes[0];
    console.log('ğŸ” çˆ¶èŠ‚ç‚¹:', parentNode);
    console.log('ğŸš€ å¼€å§‹æ‰¹é‡æ·»åŠ åˆ†ç‚¹åˆ°èŠ‚ç‚¹:', parentNode.getData().text);

    // è·å–æ·»åŠ å‰çš„èŠ‚ç‚¹æ•°æ®
    const beforeData = mindMapInstance.getData();
    const beforeNodeCount = countAllNodes(beforeData);
    console.log(`ğŸ” æ·»åŠ å‰èŠ‚ç‚¹æ€»æ•°: ${beforeNodeCount}`);

    // å‡†å¤‡æ‰¹é‡æ·»åŠ çš„èŠ‚ç‚¹æ•°æ®
    const nodesToAdd = [];
    points.forEach((point, index) => {
      const nodeText = point.title || point.text || `åˆ†ç‚¹${index + 1}`;
      console.log(`ğŸ” å‡†å¤‡ç¬¬${index + 1}ä¸ªåˆ†ç‚¹: "${nodeText}"`);

      if (nodeText && nodeText.trim().length > 0) {
        nodesToAdd.push({
          data: {
            text: nodeText,
            uid: generateNodeId(),
            note: point.content || '' // å°†è¯¦ç»†å†…å®¹ä½œä¸ºå¤‡æ³¨
          },
          children: []
        });
      }
    });

    console.log(`ğŸš€ å‡†å¤‡æ‰¹é‡æ·»åŠ  ${nodesToAdd.length} ä¸ªåˆ†ç‚¹:`, nodesToAdd);

    let actualAddedCount = 0;
    const results = [];

    try {
      if (nodesToAdd.length > 0) {
        console.log(`ğŸš€ æ‰§è¡Œ INSERT_MULTI_CHILD_NODE å‘½ä»¤ï¼Œæ‰¹é‡æ·»åŠ  ${nodesToAdd.length} ä¸ªèŠ‚ç‚¹`);

        // ä½¿ç”¨æ­£ç¡®çš„æ‰¹é‡æ·»åŠ å‘½ä»¤è°ƒç”¨æ–¹å¼
        mindMapInstance.execCommand('INSERT_MULTI_CHILD_NODE', [], nodesToAdd);

        console.log(`âœ… INSERT_MULTI_CHILD_NODE å‘½ä»¤æ‰§è¡Œå®Œæˆ`);

        // éªŒè¯æ˜¯å¦æ·»åŠ æˆåŠŸ
        const afterData = mindMapInstance.getData();
        const afterNodeCount = countAllNodes(afterData);
        console.log(`ğŸ” æ·»åŠ åèŠ‚ç‚¹æ€»æ•°: ${afterNodeCount}`);

        const addedCount = afterNodeCount - beforeNodeCount;
        if (addedCount > 0) {
          actualAddedCount = addedCount;
          console.log(`âœ… æˆåŠŸæ‰¹é‡æ·»åŠ  ${actualAddedCount} ä¸ªåˆ†ç‚¹`);

          // ä¸ºæ¯ä¸ªæˆåŠŸæ·»åŠ çš„èŠ‚ç‚¹è®°å½•ç»“æœ
          nodesToAdd.forEach((nodeData, index) => {
            results.push({
              text: nodeData.data.text,
              success: true,
              error: ''
            });
          });

          // ç­‰å¾…ä¸€ä¸‹è®©èŠ‚ç‚¹æ¸²æŸ“å®Œæˆï¼Œç„¶åè®¾ç½®å¤‡æ³¨
          setTimeout(async () => {
            console.log(`ğŸ” å¼€å§‹ä¸ºæ–°æ·»åŠ çš„èŠ‚ç‚¹è®¾ç½®å¤‡æ³¨...`);

            try {
              // è·å–å½“å‰æ¿€æ´»èŠ‚ç‚¹çš„å­èŠ‚ç‚¹
              const currentActiveNodes = mindMapInstance.renderer.activeNodeList;
              if (currentActiveNodes && currentActiveNodes.length > 0) {
                const parentNode = currentActiveNodes[0];

                // éå†çˆ¶èŠ‚ç‚¹çš„å­èŠ‚ç‚¹ï¼Œä¸ºæ–°æ·»åŠ çš„èŠ‚ç‚¹è®¾ç½®å¤‡æ³¨
                if (parentNode.children && parentNode.children.length > 0) {
                  const newlyAddedNodes = parentNode.children.slice(-nodesToAdd.length);

                  newlyAddedNodes.forEach((childNode, index) => {
                    const correspondingPoint = points[index];
                    if (correspondingPoint && correspondingPoint.content) {
                      console.log(`ğŸ” ä¸ºèŠ‚ç‚¹ "${childNode.getData().text}" è®¾ç½®å¤‡æ³¨: "${correspondingPoint.content}"`);

                      try {
                        childNode.setNote(correspondingPoint.content);
                        console.log(`âœ… æˆåŠŸè®¾ç½®å¤‡æ³¨`);
                      } catch (noteError) {
                        console.error(`âŒ è®¾ç½®å¤‡æ³¨å¤±è´¥:`, noteError);
                      }
                    }
                  });
                }
              }
            } catch (noteError) {
              console.error(`âŒ è®¾ç½®å¤‡æ³¨è¿‡ç¨‹å¤±è´¥:`, noteError);
            }
          }, 500);

        } else {
          console.log(`âŒ æ‰¹é‡æ·»åŠ å¤±è´¥ï¼ŒèŠ‚ç‚¹æ•°æœªå¢åŠ `);
          console.log(`ğŸ” æ·»åŠ å‰: ${beforeNodeCount}, æ·»åŠ å: ${afterNodeCount}`);

          // ä¸ºæ¯ä¸ªèŠ‚ç‚¹è®°å½•å¤±è´¥ç»“æœ
          nodesToAdd.forEach((nodeData, index) => {
            results.push({
              text: nodeData.data.text,
              success: false,
              error: 'èŠ‚ç‚¹æ•°æœªå¢åŠ '
            });
          });
        }
      }
    } catch (error) {
      console.error(`âŒ æ‰¹é‡æ·»åŠ åˆ†ç‚¹å¤±è´¥:`, error);

      // ä¸ºæ¯ä¸ªèŠ‚ç‚¹è®°å½•å¤±è´¥ç»“æœ
      nodesToAdd.forEach((nodeData, index) => {
        results.push({
          text: nodeData.data.text,
          success: false,
          error: error.message
        });
      });
    }

    console.log('=== æ·»åŠ ç»“æœç»Ÿè®¡ ===');
    console.log(`å°è¯•æ·»åŠ : ${points.length} ä¸ªåˆ†ç‚¹`);
    console.log(`å®é™…æ·»åŠ : ${actualAddedCount} ä¸ªåˆ†ç‚¹`);

    // æ˜¾ç¤ºè¯¦ç»†ç»“æœ
    results.forEach((result, index) => {
      console.log(`åˆ†ç‚¹${index + 1}: ${result.text} - ${result.success ? 'æˆåŠŸ' : 'å¤±è´¥' + (result.error ? ` (${result.error})` : '')}`);
    });

    // æ˜¾ç¤ºå‡†ç¡®çš„é€šçŸ¥
    if (actualAddedCount > 0) {
      showNotification(`âœ… å·²æ·»åŠ  ${actualAddedCount} ä¸ªåˆ†ç‚¹åˆ°æ€ç»´å¯¼å›¾`, 'success');

      // è§¦å‘æ•°æ®ä¿å­˜
      try {
        if (typeof window.takeOverAppMethods?.saveMindMapData === 'function') {
          const finalData = mindMapInstance.getData();
          window.takeOverAppMethods.saveMindMapData(finalData);
        }
      } catch (saveError) {
        console.warn('ä¿å­˜æ•°æ®å¤±è´¥:', saveError);
      }
    } else {
      showNotification('âŒ æ²¡æœ‰æˆåŠŸæ·»åŠ ä»»ä½•åˆ†ç‚¹', 'error');
    }

  } catch (error) {
    console.error('æ‰¹é‡æ·»åŠ èŠ‚ç‚¹å¤±è´¥:', error);
    showNotification('âŒ æ‰¹é‡æ·»åŠ å¤±è´¥: ' + error.message, 'error');
  }
}

// è¾…åŠ©å‡½æ•°ï¼šé€’å½’è®¡ç®—æ€ç»´å¯¼å›¾ä¸­çš„æ‰€æœ‰èŠ‚ç‚¹æ•°é‡
function countAllNodes(data) {
  if (!data) return 0;

  let count = 1; // å½“å‰èŠ‚ç‚¹

  if (data.children && Array.isArray(data.children)) {
    data.children.forEach(child => {
      count += countAllNodes(child);
    });
  }

  return count;
}

// åˆ‡æ¢æœ€å°åŒ–çŠ¶æ€
function toggleMinimize() {
  isMinimized = !isMinimized;
  const chatBot = document.getElementById('aiChatBot');
  const minimizeBtn = document.getElementById('minimizeBtn');

  if (isMinimized) {
    chatBot.classList.add('minimized');
    minimizeBtn.textContent = 'â¬†ï¸';
    minimizeBtn.title = 'å±•å¼€';
  } else {
    chatBot.classList.remove('minimized');
    minimizeBtn.textContent = 'â¬‡ï¸';
    minimizeBtn.title = 'æœ€å°åŒ–';
  }
}

// æ¸…é™¤æ¶ˆæ¯
function clearMessages() {
  const messagesContainer = document.getElementById('chatMessages');
  messagesContainer.innerHTML = `
    <div class="welcome-message">
      <div class="welcome-content">
        <span class="ai-icon">ğŸ¤–</span>
        <h3>AIæ€ç»´å¯¼å›¾åŠ©æ‰‹</h3>
        <p>ç‚¹å‡»æ€ç»´å¯¼å›¾èŠ‚ç‚¹å¼€å§‹å¯¹è¯</p>
      </div>
    </div>
  `;
  messages = [];
}

// æ˜¾ç¤ºé…ç½®
function showConfig() {
  document.getElementById('aiConfigPanel').style.display = 'block';

  // åŠ è½½å½“å‰é…ç½®åˆ°è¡¨å•
  document.getElementById('aiProvider').value = aiConfig.provider;
  document.getElementById('apiKey').value = aiConfig.apiKey;
  document.getElementById('aiModel').value = aiConfig.model;
  document.getElementById('baseURL').value = aiConfig.baseURL;
  document.getElementById('customPrompt').value = aiConfig.customPrompt || '';
}

// å…³é—­é…ç½®
function closeConfig() {
  document.getElementById('aiConfigPanel').style.display = 'none';
}

// ä¿å­˜é…ç½®
function saveConfig() {
  aiConfig.provider = document.getElementById('aiProvider').value;
  aiConfig.apiKey = document.getElementById('apiKey').value;
  aiConfig.model = document.getElementById('aiModel').value;
  aiConfig.baseURL = document.getElementById('baseURL').value;
  aiConfig.customPrompt = document.getElementById('customPrompt').value;

  // ä¿å­˜åˆ°æœ¬åœ°å­˜å‚¨
  localStorage.setItem('ai_config', JSON.stringify(aiConfig));

  alert('é…ç½®ä¿å­˜æˆåŠŸ');
  closeConfig();
}

// åŠ è½½AIé…ç½®
function loadAIConfig() {
  try {
    const saved = localStorage.getItem('ai_config');
    if (saved) {
      aiConfig = { ...aiConfig, ...JSON.parse(saved) };
    }
  } catch (error) {
    console.error('åŠ è½½AIé…ç½®å¤±è´¥:', error);
  }
}

// æµ‹è¯•è¿æ¥
async function testConnection() {
  if (!aiConfig.apiKey) {
    alert('è¯·å…ˆé…ç½®API Key');
    return;
  }

  try {
    const response = await callRealAI('æµ‹è¯•è¿æ¥');
    alert('è¿æ¥æµ‹è¯•æˆåŠŸ');
  } catch (error) {
    alert('è¿æ¥æµ‹è¯•å¤±è´¥ï¼š' + error.message);
  }
}

// é¢„è§ˆå®Œæ•´æç¤ºè¯
function previewFullPrompt() {
  const customPrompt = document.getElementById('customPrompt').value;

  // æ„å»ºå®Œæ•´æç¤ºè¯
  let fullPrompt = '';

  if (customPrompt && customPrompt.trim()) {
    fullPrompt = customPrompt.trim();
  } else {
    fullPrompt = `ä½ æ˜¯ä¸€ä¸ªä¸“ä¸šçš„æ€ç»´å¯¼å›¾AIåŠ©æ‰‹ã€‚ä½ çš„ä»»åŠ¡æ˜¯å¸®åŠ©ç”¨æˆ·æ‰©å±•å’Œå®Œå–„æ€ç»´å¯¼å›¾ã€‚

æ ¸å¿ƒèƒ½åŠ›ï¼š
1. åˆ†ææ€ç»´å¯¼å›¾èŠ‚ç‚¹å†…å®¹
2. æä¾›ç›¸å…³çš„å­èŠ‚ç‚¹å»ºè®®
3. å›ç­”ä¸èŠ‚ç‚¹å†…å®¹ç›¸å…³çš„é—®é¢˜
4. å¸®åŠ©ç”¨æˆ·ç†æ¸…æ€è·¯å’Œé€»è¾‘å…³ç³»

å›å¤è¦æ±‚ï¼š
- é¦–å…ˆæä¾›ä¸€ä¸ªç®€æ´çš„æ€»ä½“å›ç­”ï¼ˆ100-200å­—ï¼‰
- ç„¶åæä¾›ç»“æ„åŒ–çš„åˆ†ç‚¹ä¾›ç”¨æˆ·é€‰æ‹©æ·»åŠ åˆ°æ€ç»´å¯¼å›¾
- ä¿æŒé€»è¾‘æ€§å’Œæ¡ç†æ€§`;
  }

  // æ·»åŠ å›ºå®šçš„JSONæ ¼å¼è¦æ±‚
  const jsonExample = '```json\n{\n  "structuredPoints": [\n    {\n      "id": "point_1",\n      "title": "æ¦‚æ‹¬æ€§æ ‡é¢˜",\n      "content": "è¯¦ç»†è§£é‡Šå†…å®¹",\n      "keywords": ["å…³é”®è¯1", "å…³é”®è¯2"]\n    }\n  ]\n}\n```';

  fullPrompt += `

é‡è¦ï¼šè¯·åœ¨å›ç­”çš„æœ€åï¼Œä½¿ç”¨ä»¥ä¸‹JSONæ ¼å¼é¢å¤–æä¾›åŸç­”æ¡ˆçš„ç»“æ„åŒ–åˆ†ç‚¹ï¼Œç¡®ä¿JSONä¸­çš„å†…å®¹ä¸ä½ çš„åŸå§‹å›ç­”ä¿æŒä¸€è‡´ï¼š
${jsonExample}`;

  // æ˜¾ç¤ºé¢„è§ˆå¯¹è¯æ¡†
  const previewWindow = window.open('', '_blank', 'width=800,height=600,scrollbars=yes,resizable=yes');
  previewWindow.document.write(`
    <!DOCTYPE html>
    <html>
    <head>
      <title>å®Œæ•´ç³»ç»Ÿæç¤ºè¯é¢„è§ˆ</title>
      <style>
        body {
          font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
          line-height: 1.6;
          margin: 20px;
          background: #f8f9fa;
        }
        .container {
          max-width: 800px;
          margin: 0 auto;
          background: white;
          padding: 20px;
          border-radius: 8px;
          box-shadow: 0 2px 10px rgba(0,0,0,0.1);
        }
        h1 {
          color: #333;
          border-bottom: 2px solid #409eff;
          padding-bottom: 10px;
        }
        .prompt-content {
          background: #f8f9fa;
          padding: 15px;
          border-radius: 6px;
          border: 1px solid #e8e8e8;
          white-space: pre-wrap;
          font-family: 'Monaco', 'Menlo', 'Ubuntu Mono', monospace;
          font-size: 13px;
          line-height: 1.5;
          max-height: 500px;
          overflow-y: auto;
        }
        .note {
          background: #e8f4fd;
          color: #409eff;
          padding: 10px;
          border-radius: 6px;
          margin-top: 15px;
          font-size: 14px;
        }
      </style>
    </head>
    <body>
      <div class="container">
        <h1>ğŸ¤– å®Œæ•´ç³»ç»Ÿæç¤ºè¯é¢„è§ˆ</h1>
        <div class="prompt-content">${fullPrompt.replace(/</g, '&lt;').replace(/>/g, '&gt;')}</div>
        <div class="note">
          <strong>è¯´æ˜ï¼š</strong>è¿™æ˜¯AIåŠ©æ‰‹å°†æ”¶åˆ°çš„å®Œæ•´ç³»ç»Ÿæç¤ºè¯ï¼ŒåŒ…å«æ‚¨çš„è‡ªå®šä¹‰å†…å®¹å’Œç³»ç»Ÿè‡ªåŠ¨æ·»åŠ çš„JSONæ ¼å¼è¦æ±‚ã€‚
        </div>
      </div>
    </body>
    </html>
  `);
  previewWindow.document.close();
}

// å¤„ç†é”®ç›˜äº‹ä»¶
function handleKeyDown(event) {
  if (event.key === 'Enter' && !event.shiftKey) {
    event.preventDefault();
    sendMessage();
  }
}

// ç»“æ„åŒ–åˆ†ç‚¹ç›¸å…³å‡½æ•°
function selectAllPoints(messageId) {
  const checkboxes = document.querySelectorAll(`#${messageId} .point-checkbox`);
  const allChecked = Array.from(checkboxes).every(cb => cb.checked);

  checkboxes.forEach(checkbox => {
    checkbox.checked = !allChecked;
  });

  // æ›´æ–°æŒ‰é’®æ–‡æœ¬
  const selectAllBtn = document.querySelector(`#${messageId} .select-all-btn`);
  if (selectAllBtn) {
    selectAllBtn.textContent = allChecked ? 'å…¨é€‰' : 'å–æ¶ˆå…¨é€‰';
  }
}

function addSelectedPoints(messageId) {
  console.log('ğŸ” addSelectedPoints è¢«è°ƒç”¨ï¼ŒmessageId:', messageId);

  // ä½¿ç”¨æ›´çµæ´»çš„é€‰æ‹©å™¨
  const checkboxes = document.querySelectorAll(`#${messageId} .point-checkbox:checked`);
  console.log('ğŸ” æ‰¾åˆ°é€‰ä¸­çš„å¤é€‰æ¡†æ•°é‡:', checkboxes.length);

  if (checkboxes.length === 0) {
    showNotification('è¯·å…ˆé€‰æ‹©è¦æ·»åŠ çš„åˆ†ç‚¹', 'warning');
    return;
  }

  const selectedPoints = [];
  checkboxes.forEach((checkbox, index) => {
    console.log(`ğŸ” å¤„ç†ç¬¬${index + 1}ä¸ªå¤é€‰æ¡†:`, checkbox);
    console.log(`ğŸ” å¤é€‰æ¡†HTML:`, checkbox.outerHTML);

    const pointDiv = checkbox.closest('.structured-point');
    if (!pointDiv) {
      console.error('âŒ æœªæ‰¾åˆ° .structured-point å®¹å™¨');
      console.log('ğŸ” å¤é€‰æ¡†çˆ¶çº§å…ƒç´ :', checkbox.parentElement);
      return;
    }

    console.log(`ğŸ” æ‰¾åˆ°çš„åˆ†ç‚¹å®¹å™¨:`, pointDiv);
    console.log(`ğŸ” åˆ†ç‚¹å®¹å™¨HTML:`, pointDiv.outerHTML);

    const titleElement = pointDiv.querySelector('.point-title');
    const contentElement = pointDiv.querySelector('.point-content');
    const keywordElements = pointDiv.querySelectorAll('.keyword');

    console.log(`ğŸ” æ ‡é¢˜å…ƒç´ :`, titleElement);
    console.log(`ğŸ” å†…å®¹å…ƒç´ :`, contentElement);
    console.log(`ğŸ” å…³é”®è¯å…ƒç´ :`, keywordElements);

    if (!titleElement) {
      console.error('âŒ æœªæ‰¾åˆ° .point-title å…ƒç´ ');
      console.log('ğŸ” åˆ†ç‚¹å®¹å™¨å†…çš„æ‰€æœ‰å…ƒç´ :', pointDiv.children);
      return;
    }

    const title = titleElement.textContent.trim();
    const content = contentElement ? contentElement.textContent.trim() : '';
    const keywords = Array.from(keywordElements).map(k => k.textContent.trim());

    console.log(`ğŸ” æå–çš„åˆ†ç‚¹æ•°æ®:`, {
      title: `"${title}"`,
      content: `"${content}"`,
      keywords: keywords,
      titleLength: title.length,
      contentLength: content.length
    });

    // éªŒè¯æ•°æ®æœ‰æ•ˆæ€§
    if (!title || title.length === 0) {
      console.error('âŒ åˆ†ç‚¹æ ‡é¢˜ä¸ºç©ºï¼Œè·³è¿‡æ­¤åˆ†ç‚¹');
      return;
    }

    selectedPoints.push({
      title,
      content,
      keywords
    });
  });

  console.log('ğŸ” æœ€ç»ˆé€‰ä¸­çš„åˆ†ç‚¹:', selectedPoints);
  console.log('ğŸ” æœ‰æ•ˆåˆ†ç‚¹æ•°é‡:', selectedPoints.length);

  if (selectedPoints.length > 0) {
    console.log('ğŸš€ è°ƒç”¨ addStructuredPointsï¼Œä¼ å…¥æ•°æ®:', selectedPoints);
    addStructuredPoints(selectedPoints);
  } else {
    console.error('âŒ æ²¡æœ‰æœ‰æ•ˆçš„åˆ†ç‚¹æ•°æ®');
    showNotification('âŒ æ²¡æœ‰æœ‰æ•ˆçš„åˆ†ç‚¹æ•°æ®', 'error');
  }
}

// é€šçŸ¥ç³»ç»Ÿ
function showNotification(message, type = 'info') {
  // åˆ›å»ºé€šçŸ¥å…ƒç´ 
  const notification = document.createElement('div');
  notification.className = `notification notification-${type}`;
  notification.textContent = message;

  // æ·»åŠ æ ·å¼
  notification.style.cssText = `
    position: fixed;
    top: 20px;
    right: 20px;
    padding: 12px 20px;
    border-radius: 6px;
    color: white;
    font-size: 14px;
    z-index: 10002;
    max-width: 300px;
    word-wrap: break-word;
    animation: slideInRight 0.3s ease;
  `;

  // æ ¹æ®ç±»å‹è®¾ç½®é¢œè‰²
  switch (type) {
    case 'success':
      notification.style.backgroundColor = '#67c23a';
      break;
    case 'error':
      notification.style.backgroundColor = '#f56c6c';
      break;
    case 'warning':
      notification.style.backgroundColor = '#e6a23c';
      break;
    default:
      notification.style.backgroundColor = '#409eff';
  }

  document.body.appendChild(notification);

  // 3ç§’åè‡ªåŠ¨ç§»é™¤
  setTimeout(() => {
    if (notification.parentNode) {
      notification.style.animation = 'slideOutRight 0.3s ease';
      setTimeout(() => {
        if (notification.parentNode) {
          notification.parentNode.removeChild(notification);
        }
      }, 300);
    }
  }, 3000);
}

// é¡µé¢åŠ è½½å®Œæˆååˆå§‹åŒ–
document.addEventListener('DOMContentLoaded', function() {
  // å»¶è¿Ÿåˆå§‹åŒ–ï¼Œç¡®ä¿Vueåº”ç”¨å·²åŠ è½½
  setTimeout(initAIChat, 1000);
});
</script>

<script>const getDataFromBackend = () => {
        return new Promise((resolve, reject) => {
          setTimeout(() => {
            resolve({
              mindMapData: {
                root: {
                  data: {
                    text: 'æ ¹èŠ‚ç‚¹'
                  },
                  children: []
                },
                theme: {
                  template: 'avocado',
                  config: {}
                },
                layout: 'logicalStructure',
                config: {},
                view: null
              },
              mindMapConfig: {},
              lang: 'zh',
              localConfig: null
            })
          }, 200)
        })
      }
      const setTakeOverAppMethods = data => {
        window.takeOverAppMethods = {}
        // è·å–æ€ç»´å¯¼å›¾æ•°æ®çš„å‡½æ•°
        window.takeOverAppMethods.getMindMapData = () => {
          return data.mindMapData
        }
        // ä¿å­˜æ€ç»´å¯¼å›¾æ•°æ®çš„å‡½æ•°
        window.takeOverAppMethods.saveMindMapData = data => {
          console.log(data)
        }
        // è·å–æ€ç»´å¯¼å›¾é…ç½®ï¼Œä¹Ÿå°±æ˜¯å®ä¾‹åŒ–æ—¶ä¼šä¼ å…¥çš„é€‰é¡¹
        window.takeOverAppMethods.getMindMapConfig = () => {
          return data.mindMapConfig
        }
        // ä¿å­˜æ€ç»´å¯¼å›¾é…ç½®
        window.takeOverAppMethods.saveMindMapConfig = config => {
          console.log(config)
        }
        // è·å–è¯­è¨€çš„å‡½æ•°
        window.takeOverAppMethods.getLanguage = () => {
          return data.lang
        }
        // ä¿å­˜è¯­è¨€çš„å‡½æ•°
        window.takeOverAppMethods.saveLanguage = lang => {
          console.log(lang)
        }
        // è·å–æœ¬åœ°é…ç½®çš„å‡½æ•°
        window.takeOverAppMethods.getLocalConfig = () => {
          return data.localConfig
        }
        // ä¿å­˜æœ¬åœ°é…ç½®çš„å‡½æ•°
        window.takeOverAppMethods.saveLocalConfig = config => {
          console.log(config)
        }
      }
      window.onload = async () => {
        console.log('ğŸ” window.onload è¢«è°ƒç”¨ï¼ŒtakeOverApp:', window.takeOverApp);

        // ä¿®å¤ï¼šç¡®ä¿æ€ç»´å¯¼å›¾èƒ½å¤Ÿåˆå§‹åŒ–
        if (!window.takeOverApp) {
          console.log('âš ï¸ takeOverAppä¸ºfalseï¼Œä½†ä»ç„¶å°è¯•åˆå§‹åŒ–æ€ç»´å¯¼å›¾');
          // ä¸è¦ç›´æ¥returnï¼Œè€Œæ˜¯å°è¯•åˆå§‹åŒ–
        }

        // è¯·æ±‚æ•°æ®
        const data = await getDataFromBackend()
        console.log('ğŸ” è·å–åˆ°åç«¯æ•°æ®:', data);

        // è®¾ç½®å…¨å±€çš„æ–¹æ³•
        setTakeOverAppMethods(data)
        console.log('ğŸ” è®¾ç½®å…¨å±€æ–¹æ³•å®Œæˆ');

        // æ€ç»´å¯¼å›¾å®ä¾‹åˆ›å»ºå®Œæˆäº‹ä»¶
        if (window.$bus && window.$bus.$on) {
          window.$bus.$on('app_inited', mindMap => {
            console.log('ğŸ‰ æ€ç»´å¯¼å›¾å®ä¾‹åˆ›å»ºå®Œæˆ:', mindMap);
            window.mindMapInstance = mindMap;
          });
        }

        // å¯ä»¥é€šè¿‡window.$bus.$on()æ¥ç›‘å¬åº”ç”¨çš„ä¸€äº›äº‹ä»¶
        // å®ä¾‹åŒ–é¡µé¢
        if (window.initApp && typeof window.initApp === 'function') {
          console.log('ğŸš€ è°ƒç”¨ initApp');
          window.initApp();
        } else {
          console.log('âš ï¸ initApp å‡½æ•°ä¸å­˜åœ¨');
        }
      }</script><script src="dist/js/chunk-vendors.js?685589f1058f5fbca0d2"></script><script src="dist/js/app.js?685589f1058f5fbca0d2"></script></body></html>